<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rpg-game</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      image-rendering: pixelated;
      border: 4px solid #444;
      cursor: pointer;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 10px;
    }
    #dialog {
      display: none;
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 20px;
      border: 4px solid #444;
      font-family: monospace;
      max-width: 80%;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="ui">Click to move your character. The camera follows you but stays within map borders. Click the NPC to talk.</div>
  <div id="dialog">
    <div id="dialogText"></div>
    <div style="margin-top: 10px; font-size: 0.8em; color: #666; text-align: right;">Click anywhere to close</div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Config
    const TILE_SIZE = 64;
    const MAP_SIZE_TILES = 30;
    const MAP_PIXEL_SIZE = MAP_SIZE_TILES * TILE_SIZE;
    const PLAYER_SPEED = 4;
    
    // State
    const player = {
      x: MAP_PIXEL_SIZE / 2,
      y: MAP_PIXEL_SIZE / 2,
      targetX: MAP_PIXEL_SIZE / 2,
      targetY: MAP_PIXEL_SIZE / 2,
      size: 40,
      isWalking: false,
      animFrame: 0
    };

    const npc = {
      tileX: 16,
      tileY: 15,
      dialog: "Hello fellow adventurer, how is your quest going ?"
    };
    let isInteractingWithNpc = false;
    let dialogActive = false;

    const map = [];
    function initMap() {
      for (let y = 0; y < MAP_SIZE_TILES; y++) {
        map[y] = [];
        for (let x = 0; x < MAP_SIZE_TILES; x++) {
          // Procedural grass colors
          map[y][x] = `rgb(50, ${150 + Math.floor(Math.random() * 50)}, 50)`;
        }
      }
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();
    initMap();

    function showDialog(text) {
      document.getElementById('dialogText').innerText = text;
      document.getElementById('dialog').style.display = 'block';
      dialogActive = true;
    }

    function hideDialog() {
      document.getElementById('dialog').style.display = 'none';
      dialogActive = false;
    }

    canvas.addEventListener('mousedown', (e) => {
      if (dialogActive) {
        hideDialog();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      
      const cam = getCameraOffset();
      const worldX = screenX + cam.x;
      const worldY = screenY + cam.y;
      
      const targetTileX = Math.floor(worldX / TILE_SIZE);
      const targetTileY = Math.floor(worldY / TILE_SIZE);

      if (targetTileX === npc.tileX && targetTileY === npc.tileY) {
        const dx = targetTileX - player.x / TILE_SIZE;
        const dy = targetTileY - player.y / TILE_SIZE;
        let adjX = npc.tileX;
        let adjY = npc.tileY;
        if (Math.abs(dx) > Math.abs(dy)) adjX -= Math.sign(dx) || 1;
        else adjY -= Math.sign(dy) || 1;
        player.targetX = adjX * TILE_SIZE + TILE_SIZE / 2;
        player.targetY = adjY * TILE_SIZE + TILE_SIZE / 2;
        isInteractingWithNpc = true;
      } else {
        player.targetX = targetTileX * TILE_SIZE + TILE_SIZE / 2;
        player.targetY = targetTileY * TILE_SIZE + TILE_SIZE / 2;
        isInteractingWithNpc = false;
      }
    });

    function getCameraOffset() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      
      // Clamping to map borders
      const maxCamX = MAP_PIXEL_SIZE - canvas.width;
      const maxCamY = MAP_PIXEL_SIZE - canvas.height;
      
      // If map is smaller than screen, center it
      if (MAP_PIXEL_SIZE < canvas.width) camX = (MAP_PIXEL_SIZE - canvas.width) / 2;
      else camX = Math.max(0, Math.min(camX, maxCamX));

      if (MAP_PIXEL_SIZE < canvas.height) camY = (MAP_PIXEL_SIZE - canvas.height) / 2;
      else camY = Math.max(0, Math.min(camY, maxCamY));

      return { x: camX, y: camY };
    }

    function update() {
      if (dialogActive) return;
      const dx = player.targetX - player.x;
      const dy = player.targetY - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > PLAYER_SPEED) {
        player.isWalking = true;
        player.x += (dx / dist) * PLAYER_SPEED;
        player.y += (dy / dist) * PLAYER_SPEED;
        player.animFrame += 0.15;
      } else {
        player.x = player.targetX;
        player.y = player.targetY;
        if (isInteractingWithNpc) {
          showDialog(npc.dialog);
          isInteractingWithNpc = false;
        }
        player.isWalking = false;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = getCameraOffset();

      ctx.save();
      ctx.translate(-cam.x, -cam.y);

      // Draw Tiles
      const startTileX = Math.floor(cam.x / TILE_SIZE);
      const endTileX = Math.floor((cam.x + canvas.width) / TILE_SIZE) + 1;
      const startTileY = Math.floor(cam.y / TILE_SIZE);
      const endTileY = Math.floor((cam.y + canvas.height) / TILE_SIZE) + 1;

      for (let y = Math.max(0, startTileY); y < Math.min(MAP_SIZE_TILES, endTileY); y++) {
        for (let x = Math.max(0, startTileX); x < Math.min(MAP_SIZE_TILES, endTileX); x++) {
          ctx.fillStyle = map[y][x];
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw NPC
      const npcX = npc.tileX * TILE_SIZE + TILE_SIZE / 2;
      const npcY = npc.tileY * TILE_SIZE + TILE_SIZE / 2;
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(npcX, npcY + 15, 15, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#4444ff';
      ctx.beginPath();
      ctx.roundRect(npcX - 15, npcY - 45, 30, 45, 10);
      ctx.fill();
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(npcX, npcY - 50, 12, 0, Math.PI * 2);
      ctx.fill();

      // Draw Player Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 15, 15, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Draw Player (Body)
      const bob = player.isWalking ? Math.abs(Math.sin(player.animFrame)) * 8 : 0;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.roundRect(player.x - 15, player.y - 45 - bob, 30, 45, 10);
      ctx.fill();
      
      // Draw Head
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(player.x, player.y - 50 - bob, 12, 0, Math.PI * 2);
      ctx.fill();

      // Draw Feet (Walking animation)
      if (player.isWalking) {
        const legMove = Math.sin(player.animFrame) * 10;
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5 + legMove, 8, 5);  // Left foot
        ctx.fillRect(player.x + 4, player.y - 5 - legMove, 8, 5);   // Right foot
      } else {
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5, 8, 5);
        ctx.fillRect(player.x + 4, player.y - 5, 8, 5);
      }

      ctx.restore();

      requestAnimationFrame(() => {
        update();
        draw();
      });
    }

    draw();
  </script>
</body>
</html>