<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rpg-game</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      image-rendering: pixelated;
      border: 4px solid #444;
      cursor: pointer;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 10px;
    }
    #dialog {
      display: none;
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 20px;
      border: 4px solid #444;
      font-family: monospace;
      max-width: 80%;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      z-index: 100;
    }
    #shop, #menu-modal {
      display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border: 4px solid #444; font-family: monospace;
      width: 280px; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 250;
    }
    .menu-btn { width: 100%; padding: 10px; margin: 5px 0; cursor: pointer; background: #eee; border: 1px solid #ccc; font-family: monospace; }
    .menu-btn:hover { background: #ddd; }
    .shop-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #eee; }
    .shop-item button { cursor: pointer; padding: 5px 10px; background: #4caf50; color: white; border: none; }
    #battle-screen {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #111;
      color: white;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      z-index: 200;
    }
    .battle-stats { display: flex; gap: 40px; margin-bottom: 30px; font-size: 1.4em; text-align: center; }
    .battle-actions button {
      padding: 15px 30px; font-size: 1.1em; cursor: pointer; margin: 10px; background: #444; color: white; border: 2px solid #888;
    }
    .battle-actions button:hover { background: #666; }
    #battle-msg { font-size: 1.2em; margin-bottom: 20px; color: #ffeb3b; height: 1.5em; }
    #flash-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: white; opacity: 0; pointer-events: none; z-index: 300;
    }
    @keyframes flash-anim { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
    .flashing { animation: flash-anim 0.5s ease-out; }
    .dungeon-info { color: #ff66ff; font-weight: bold; } .bar-container { width: 120px; height: 12px; background: #333; border: 2px solid #555; margin: 4px auto; position: relative; } .bar-fill { height: 100%; width: 100%; transition: width 0.3s ease; } .hp-fill { background: #4caf50; } .mp-fill { background: #2196f3; } .party-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 6px; padding: 4px; font-size: 0.75em; border: 1px solid transparent; } .active-actor { border-color: #ffeb3b; background: rgba(255,235,59,0.1); } #starter-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #222; z-index: 500; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-family: monospace; } .starter-cards { display: flex; gap: 20px; margin-top: 30px; } .starter-card { background: #333; border: 4px solid #555; padding: 20px; width: 180px; text-align: center; cursor: pointer; transition: transform 0.2s, border-color 0.2s; } .starter-card:hover { transform: scale(1.05); border-color: #ffeb3b; } .starter-card h3 { margin: 10px 0; color: #ffeb3b; } .starter-card .stats { font-size: 0.8em; text-align: left; margin: 10px 0; line-height: 1.4; }
  </style>
</head>
<body>
  <div id="starter-screen">
    <h1>Choose Your Starter Monster</h1>
    <div class="starter-cards"></div>
  </div>
  <div id="ui">Click to move. <span class="dungeon-info">Purple zone = Dungeon (Battles!)</span> | <span id="player-hud"></span><button onclick="toggleMenu()" style="pointer-events: auto; margin-left: 10px; cursor: pointer; background: #444; color: white; border: 1px solid #888; font-family: monospace;">Menu</button></div>
  <div id="flash-overlay"></div>
  <div id="battle-screen">
    <div id="battle-msg">A wild monster appears!</div>
    <div class="battle-stats">
      <div id="party-stats" style="flex: 1; text-align: left;"></div>
      <div style="font-size: 1.5em; display: flex; flex-direction: column; align-items: center; justify-content: center;">
        <canvas id="monster-canvas" width="100" height="100" style="background: #222; border: 2px solid #555; border-radius: 50%; margin-bottom: 10px;"></canvas>
        VS
      </div>
      <div style="flex: 1; text-align: right;">ENEMY<br><span id="e-name" style="font-size: 0.8em;"></span><br><span id="e-hp" style="font-size: 0.8em;"></span><div class="bar-container"><div id="e-hp-bar" class="bar-fill hp-fill"></div></div></div>
    </div>
    <div class="battle-actions">
      <div id="acting-name" style="color: #4caf50; font-weight: bold; margin-bottom: 10px;"></div>
      <button onclick="battleAction('attack')">Attack</button>
      <button onclick="battleAction('skill')">Skill (5MP)</button>
      <button onclick="openBattleBag()">Bag</button>
      <button onclick="battleAction('flee')">Flee</button>
    </div>
  </div>
  <div id="dialog">
    <div id="dialogText"></div>
    <div style="margin-top: 10px; font-size: 0.8em; color: #666; text-align: right;">Click anywhere to close</div>
  </div>
  <div id="shop">
    <h3 style="margin: 0 0 10px 0;">Village Shop</h3>
    <div id="shop-items"></div>
    <button onclick="closeShop()" style="margin-top: 15px; width: 100%; cursor: pointer;">Exit Shop</button>
  </div>
  <div id="menu-modal">
    <div id="menu-content"></div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Config
    const TILE_SIZE = 64;
    const MAP_SIZE_TILES = 30;
    const MAP_PIXEL_SIZE = MAP_SIZE_TILES * TILE_SIZE;
    const PLAYER_SPEED = 4;
    
    // State
    let gameState = 'EXPLORE'; // EXPLORE, BATTLE
    const player = {
      x: MAP_PIXEL_SIZE / 2,
      y: MAP_PIXEL_SIZE / 2,
      targetX: MAP_PIXEL_SIZE / 2,
      targetY: MAP_PIXEL_SIZE / 2,
      size: 40,
      isWalking: false,
      animFrame: 0
    };

    const playerStats = {
      party: [],
      gold: 50, inventory: []
    };
    const STARTERS = [
      { name: 'Leafy', hp: 120, maxHp: 120, mp: 15, maxMp: 15, atk: 8, lvl: 1, xp: 0, skill: { name: 'Solar Bloom', cost: 5, mult: 1.2, heal: 15 } },
      { name: 'Ignis', hp: 80, maxHp: 80, mp: 10, maxMp: 10, atk: 16, lvl: 1, xp: 0, skill: { name: 'Inferno', cost: 5, mult: 2.5 } },
      { name: 'Aquos', hp: 100, maxHp: 100, mp: 25, maxMp: 25, atk: 11, lvl: 1, xp: 0, skill: { name: 'Tsunami', cost: 6, mult: 2.0 } }
    ];
    let currentActorIndex = 0;
    
    let currentEnemy = null;
    let battleBusy = false;

    const npc = {
      tileX: 16, tileY: 15,
      dialog: "Hello fellow adventurer, how is your quest going ?"
    };
    const merchant = {
      tileX: 14, tileY: 15,
      items: [
        { name: 'Health Potion', price: 15, type: 'hp', value: 50 },
        { name: 'Mana Potion', price: 15, type: 'mp', value: 10 },
        { name: 'Monster Ball', price: 50, type: 'capture' }
      ]
    };
    let activeInteractionTarget = null;
    let dialogActive = false;

    const map = [];
    function initMap() {
      for (let y = 0; y < MAP_SIZE_TILES; y++) {
        map[y] = [];
        for (let x = 0; x < MAP_SIZE_TILES; x++) {
          if (x < 10 && y < 10) {
            map[y][x] = { type: 'dungeon', levelRange: [1, 3], color: `rgb(${40 + Math.random() * 20}, 30, ${60 + Math.random() * 20})` };
          } else if (x > 20 && y > 20) {
            map[y][x] = { type: 'dungeon', levelRange: [10, 15], color: `rgb(${60 + Math.random() * 20}, 20, ${40 + Math.random() * 20})` };
          } else if (x > 22 && y < 8) {
            map[y][x] = { type: 'dungeon', levelRange: [5, 8], color: `rgb(40, ${40 + Math.random() * 20}, ${80 + Math.random() * 20})` };
          } else {
            map[y][x] = { type: 'grass', color: `rgb(50, ${150 + Math.floor(Math.random() * 50)}, 50)` };
          }
        }
      }
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();
    initMap();

    function showDialog(text) {
      document.getElementById('dialogText').innerText = text;
      document.getElementById('dialog').style.display = 'block';
      dialogActive = true;
    }

    function hideDialog() {
      document.getElementById('dialog').style.display = 'none';
      document.getElementById('shop').style.display = 'none';
      dialogActive = false;
    }

    function openShop() {
      const container = document.getElementById('shop-items');
      container.innerHTML = '';
      merchant.items.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item';
        div.innerHTML = `<span>${item.name} (${item.price}G)</span><button onclick="buyItem('${item.name}', '${item.type}', ${item.price}, ${item.value})">Buy</button>`;
        container.appendChild(div);
      });
      document.getElementById('shop').style.display = 'block';
      dialogActive = true;
    }

    function buyItem(name, type, price, val) {
      if (playerStats.gold >= price) {
        playerStats.gold -= price;
        const existing = playerStats.inventory.find(i => i.name === name);
        if (existing) {
          existing.count++;
        } else {
          playerStats.inventory.push({ name, type, val, count: 1 });
        }
        updateHud();
        openShop();
      } else {
        alert("Not enough gold!");
      }
    }

    function closeShop() {
      document.getElementById('shop').style.display = 'none';
      dialogActive = false;
    }

    function toggleMenu() {
      const m = document.getElementById('menu-modal');
      if (m.style.display === 'block') {
        m.style.display = 'none';
        dialogActive = false;
        return;
      }
      if (gameState !== 'EXPLORE' || document.getElementById('shop').style.display === 'block') return;
      m.style.display = 'block';
      showMainMenu();
      dialogActive = true;
    }

    function showMainMenu() {
      const content = document.getElementById('menu-content');
      content.innerHTML = `
        <h3 style="margin-top: 0;">Menu</h3>
        <button class="menu-btn" onclick="showParty()">Party</button>
        <button class="menu-btn" onclick="showInventory()">Inventory</button>
        <button class="menu-btn" onclick="toggleMenu()">Close</button>
      `;
    }

    function showParty() {
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Party</h3><div style="max-height: 260px; overflow-y: auto;">`;
      playerStats.party.forEach((p, i) => {
        html += `
          <button class="menu-btn" onclick="showMemberDetail(${i})" style="text-align: left;">
            <div style="font-weight: bold;">${p.name} (Lvl ${p.lvl})</div>
            <div style="font-size: 0.8em; margin-top: 4px;">HP: ${Math.ceil(p.hp)}/${p.maxHp} | MP: ${Math.ceil(p.mp)}/${p.maxMp}</div>
          </button>
        `;
      });
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="showMainMenu()">Back</button>`;
      content.innerHTML = html;
    }

    function showMemberDetail(idx) {
      const p = playerStats.party[idx];
      const content = document.getElementById('menu-content');
      const req = p.lvl * 50;
      content.innerHTML = `
        <h3 style="margin-top: 0;">${p.name} Details</h3>
        <div style="font-size: 0.9em; line-height: 1.4; text-align: left; padding: 0 5px;">
          <div style="margin-bottom: 5px;"><strong>Level:</strong> ${p.lvl}</div>
          <div style="margin-bottom: 5px;"><strong>HP:</strong> ${Math.ceil(p.hp)} / ${p.maxHp}</div>
          <div style="margin-bottom: 5px;"><strong>MP:</strong> ${Math.ceil(p.mp)} / ${p.maxMp}</div>
          <div style="margin-bottom: 5px;"><strong>Attack:</strong> ${p.atk}</div>
          <div style="margin-bottom: 5px;"><strong>XP:</strong> ${p.xp || 0} / ${req}</div>
          <hr style="border: 0; border-top: 1px solid #eee; margin: 10px 0;">
          <strong>Skills:</strong><br>
          • Basic Attack<br>
          • ${p.skill ? p.skill.name : 'Power Strike'} (${p.skill ? p.skill.cost : 5} MP)
        </div>
        <button class="menu-btn" style="margin-top: 15px;" onclick="showParty()">Back</button>
      `;
    }

    function openBattleBag() {
      showInventory(true);
      document.getElementById('menu-modal').style.display = 'block';
      dialogActive = true;
    }

    function showInventory(isBattle = false) {
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Inventory</h3><div style="max-height: 200px; overflow-y: auto;">`;
      if (playerStats.inventory.length === 0) {
        html += `<p>Empty</p>`;
      } else {
        playerStats.inventory.forEach((item, idx) => {
          html += `<div class="shop-item"><span>${item.name} (x${item.count})</span><button onclick="useItem(${idx}, ${isBattle})">Use</button></div>`;
        });
      }
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="${isBattle ? 'toggleMenu()' : 'showMainMenu()'}">Back</button>`;
      content.innerHTML = html;
    }

    function useItem(idx, isBattle = false) {
      if (isBattle) { battleAction('item', idx); return; }
      const item = playerStats.inventory[idx];
      const hero = playerStats.party[0];
      if (item.type === 'hp') {
        if (hero.hp >= hero.maxHp) { alert("HP already full!"); return; }
        hero.hp = Math.min(hero.maxHp, hero.hp + item.val);
      } else if (item.type === 'mp') {
        if (hero.mp >= hero.maxMp) { alert("MP already full!"); return; }
        hero.mp = Math.min(hero.maxMp, hero.mp + item.val);
      } else { alert("Cannot use this now!"); return; }
      item.count--;
      if (item.count <= 0) playerStats.inventory.splice(idx, 1);
      showInventory(false);
      updateHud();
    }

    canvas.addEventListener('mousedown', (e) => {
      if (dialogActive || gameState === 'BATTLE') {
        if (dialogActive && document.getElementById('dialog').style.display === 'block') hideDialog();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const cam = getCameraOffset();
      const worldX = screenX + cam.x;
      const worldY = screenY + cam.y;
      const targetTileX = Math.floor(worldX / TILE_SIZE);
      const targetTileY = Math.floor(worldY / TILE_SIZE);

      let clicked = null;
      if (targetTileX === npc.tileX && targetTileY === npc.tileY) clicked = 'npc';
      if (targetTileX === merchant.tileX && targetTileY === merchant.tileY) clicked = 'merchant';

      if (clicked) {
        const tx = clicked === 'npc' ? npc.tileX : merchant.tileX;
        const ty = clicked === 'npc' ? npc.tileY : merchant.tileY;
        const dx = tx - player.x / TILE_SIZE;
        const dy = ty - player.y / TILE_SIZE;
        let adjX = tx; let adjY = ty;
        if (Math.abs(dx) > Math.abs(dy)) adjX -= Math.sign(dx) || 1;
        else adjY -= Math.sign(dy) || 1;
        player.targetX = adjX * TILE_SIZE + TILE_SIZE / 2;
        player.targetY = adjY * TILE_SIZE + TILE_SIZE / 2;
        activeInteractionTarget = clicked;
      } else {
        player.targetX = targetTileX * TILE_SIZE + TILE_SIZE / 2;
        player.targetY = targetTileY * TILE_SIZE + TILE_SIZE / 2;
        activeInteractionTarget = null;
      }
    });

    function getCameraOffset() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      
      // Clamping to map borders
      const maxCamX = MAP_PIXEL_SIZE - canvas.width;
      const maxCamY = MAP_PIXEL_SIZE - canvas.height;
      
      // If map is smaller than screen, center it
      if (MAP_PIXEL_SIZE < canvas.width) camX = (MAP_PIXEL_SIZE - canvas.width) / 2;
      else camX = Math.max(0, Math.min(camX, maxCamX));

      if (MAP_PIXEL_SIZE < canvas.height) camY = (MAP_PIXEL_SIZE - canvas.height) / 2;
      else camY = Math.max(0, Math.min(camY, maxCamY));

      return { x: camX, y: camY };
    }

    function updateHud() {
      if (playerStats.party.length === 0) return;
      const hero = playerStats.party[0];
      document.getElementById('player-hud').innerText = `Lvl ${hero.lvl} | HP ${Math.ceil(hero.hp)}/${hero.maxHp} | Gold ${playerStats.gold} | Party: ${playerStats.party.length}`;
    }

    function update() {
      if (dialogActive || gameState === 'BATTLE') return;
      updateHud();
      const dx = player.targetX - player.x;
      const dy = player.targetY - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > PLAYER_SPEED) {
        player.isWalking = true;
        player.x += (dx / dist) * PLAYER_SPEED;
        player.y += (dy / dist) * PLAYER_SPEED;
        player.animFrame += 0.15;

        const tx = Math.floor(player.x / TILE_SIZE);
        const ty = Math.floor(player.y / TILE_SIZE);
        if (map[ty] && map[ty][tx] && map[ty][tx].type === 'dungeon') {
          if (Math.random() < 0.012) startBattle(map[ty][tx]);
        }
      } else {
        player.x = player.targetX;
        player.y = player.targetY;
        if (activeInteractionTarget === 'npc') {
          showDialog(npc.dialog);
        } else if (activeInteractionTarget === 'merchant') {
          openShop();
        }
        activeInteractionTarget = null;
        player.isWalking = false;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = getCameraOffset();

      ctx.save();
      ctx.translate(-cam.x, -cam.y);

      // Draw Tiles
      const startTileX = Math.floor(cam.x / TILE_SIZE);
      const endTileX = Math.floor((cam.x + canvas.width) / TILE_SIZE) + 1;
      const startTileY = Math.floor(cam.y / TILE_SIZE);
      const endTileY = Math.floor((cam.y + canvas.height) / TILE_SIZE) + 1;

      for (let y = Math.max(0, startTileY); y < Math.min(MAP_SIZE_TILES, endTileY); y++) {
        for (let x = Math.max(0, startTileX); x < Math.min(MAP_SIZE_TILES, endTileX); x++) {
          ctx.fillStyle = map[y][x].color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw NPCs
      const drawNpc = (tx, ty, color) => {
        const nx = tx * TILE_SIZE + TILE_SIZE / 2;
        const ny = ty * TILE_SIZE + TILE_SIZE / 2;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(nx, ny + 15, 15, 8, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.roundRect(nx - 15, ny - 45, 30, 45, 10); ctx.fill();
        ctx.fillStyle = '#ffdbac';
        ctx.beginPath(); ctx.arc(nx, ny - 50, 12, 0, Math.PI * 2); ctx.fill();
      };
      drawNpc(npc.tileX, npc.tileY, '#4444ff');
      drawNpc(merchant.tileX, merchant.tileY, '#f1c40f');

      // Draw Player Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 15, 15, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Draw Player (Body)
      const bob = player.isWalking ? Math.abs(Math.sin(player.animFrame)) * 8 : 0;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.roundRect(player.x - 15, player.y - 45 - bob, 30, 45, 10);
      ctx.fill();
      
      // Draw Head
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(player.x, player.y - 50 - bob, 12, 0, Math.PI * 2);
      ctx.fill();

      // Draw Feet (Walking animation)
      if (player.isWalking) {
        const legMove = Math.sin(player.animFrame) * 10;
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5 + legMove, 8, 5);  // Left foot
        ctx.fillRect(player.x + 4, player.y - 5 - legMove, 8, 5);   // Right foot
      } else {
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5, 8, 5);
        ctx.fillRect(player.x + 4, player.y - 5, 8, 5);
      }

      ctx.restore();

      requestAnimationFrame(() => {
        update();
        draw();
      });
    }

    function startBattle(zone) {
      player.isWalking = false; player.targetX = player.x; player.targetY = player.y;
      document.getElementById('flash-overlay').classList.add('flashing');
      setTimeout(() => document.getElementById('flash-overlay').classList.remove('flashing'), 500);
      gameState = 'BATTLE';
      const range = zone.levelRange || [1, 5];
      const level = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
      const eName = ["Gorgon", "Skeleton", "Slime", "Shadow"][Math.floor(Math.random() * 4)];
      currentEnemy = {
        name: eName, level: level,
        hp: 15 + level * 12, maxHp: 15 + level * 12, atk: 4 + level * 3, xp: 15 + level * 10, gold: 10 + level * 8,
        mp: 10 + level * 2, maxMp: 10 + level * 2, lvl: level,
        skill: { name: eName === "Shadow" ? "Curse" : "Smash", cost: 5, mult: 1.7 }
      };
      currentActorIndex = 0;
      while (playerStats.party[currentActorIndex] && playerStats.party[currentActorIndex].hp <= 0) currentActorIndex++;
      document.getElementById('battle-screen').style.display = 'flex';
      updateBattleUI(`A wild Lvl ${currentEnemy.level} ${currentEnemy.name} appeared!`);
    }

    function updateBattleUI(msg) {
      const partyContainer = document.getElementById('party-stats');
      partyContainer.innerHTML = 'PARTY<br>';
      playerStats.party.forEach((p, i) => {
        const div = document.createElement('div');
        div.className = 'party-row' + (i === currentActorIndex ? ' active-actor' : '');
        div.innerHTML = `<div>${p.name}<br>HP:${Math.ceil(p.hp)}/${p.maxHp}</div><div class="bar-container" style="width:60px;"><div class="bar-fill hp-fill" style="width:${(p.hp/p.maxHp*100)}%"></div></div>`;
        partyContainer.appendChild(div);
      });
      document.getElementById('acting-name').innerText = playerStats.party[currentActorIndex] ? `Turn: ${playerStats.party[currentActorIndex].name}` : "";
      document.getElementById('e-name').innerText = `Lvl ${currentEnemy.level} ${currentEnemy.name}`;
      document.getElementById('e-hp').innerText = `HP: ${Math.ceil(currentEnemy.hp)}/${currentEnemy.maxHp}`;
      document.getElementById('e-hp-bar').style.width = (currentEnemy.hp / currentEnemy.maxHp * 100) + '%';
      if (msg) document.getElementById('battle-msg').innerText = msg;
      drawMonster(currentEnemy.name);
    }

    function drawMonsterIcon(mCtx, name) {
      mCtx.clearRect(0, 0, 100, 100);
      mCtx.save(); mCtx.translate(50, 75);
      if (name === 'Leafy') {
        mCtx.fillStyle = '#84cc16'; mCtx.beginPath(); mCtx.ellipse(0, 0, 30, 20, 0, 0, Math.PI*2); mCtx.fill();
        mCtx.fillStyle = '#4d7c0f'; mCtx.beginPath(); mCtx.moveTo(0, -20); mCtx.quadraticCurveTo(20, -40, 0, -50); mCtx.quadraticCurveTo(-20, -40, 0, -20); mCtx.fill();
      } else if (name === 'Ignis') {
        mCtx.fillStyle = '#ef4444'; mCtx.beginPath(); mCtx.moveTo(-25, 0); mCtx.lineTo(0, -60); mCtx.lineTo(25, 0); mCtx.closePath(); mCtx.fill();
        mCtx.fillStyle = '#f59e0b'; mCtx.beginPath(); mCtx.moveTo(-15, 0); mCtx.lineTo(0, -40); mCtx.lineTo(15, 0); mCtx.closePath(); mCtx.fill();
      } else if (name === 'Aquos') {
        mCtx.fillStyle = '#0ea5e9'; mCtx.beginPath(); mCtx.moveTo(0, -60); mCtx.bezierCurveTo(30, -30, 30, 0, 0, 0); mCtx.bezierCurveTo(-30, 0, -30, -30, 0, -60); mCtx.fill();
      } else if (name === 'Slime') {
        mCtx.fillStyle = '#4ade80'; mCtx.beginPath(); mCtx.arc(0, 0, 30, Math.PI, 0); mCtx.ellipse(0, 0, 30, 15, 0, 0, Math.PI); mCtx.fill();
        mCtx.fillStyle = 'white'; mCtx.beginPath(); mCtx.arc(-10, -10, 4, 0, Math.PI*2); mCtx.fill();
        mCtx.beginPath(); mCtx.arc(10, -10, 4, 0, Math.PI*2); mCtx.fill();
      } else if (name === 'Skeleton') {
        mCtx.fillStyle = '#f3f4f6'; mCtx.fillRect(-12, -35, 24, 35);
        mCtx.beginPath(); mCtx.arc(0, -45, 15, 0, Math.PI*2); mCtx.fill();
        mCtx.fillStyle = '#111'; mCtx.beginPath(); mCtx.arc(-6, -48, 3, 0, Math.PI*2); mCtx.fill();
        mCtx.beginPath(); mCtx.arc(6, -48, 3, 0, Math.PI*2); mCtx.fill();
      } else if (name === 'Gorgon') {
        mCtx.fillStyle = '#166534'; mCtx.beginPath(); mCtx.arc(0, -25, 20, 0, Math.PI*2); mCtx.fill();
        mCtx.strokeStyle = '#15803d'; mCtx.lineWidth = 4;
        for(let i=0; i<8; i++) {
          mCtx.beginPath(); mCtx.moveTo(0, -35); mCtx.quadraticCurveTo(Math.sin(i)*50, -60, Math.sin(i)*40, -40); mCtx.stroke();
        }
      } else if (name === 'Shadow') {
        mCtx.fillStyle = 'rgba(0,0,0,0.8)'; mCtx.beginPath(); mCtx.moveTo(-25, 0); mCtx.quadraticCurveTo(0, -90, 25, 0); mCtx.fill();
        mCtx.fillStyle = '#ef4444'; mCtx.beginPath(); mCtx.arc(-8, -45, 3, 0, Math.PI*2); mCtx.fill();
        mCtx.beginPath(); mCtx.arc(8, -45, 3, 0, Math.PI*2); mCtx.fill();
      }
      mCtx.restore();
    }
    function drawMonster(name) {
      const mCanvas = document.getElementById('monster-canvas');
      if (!mCanvas) return;
      drawMonsterIcon(mCanvas.getContext('2d'), name);
    }

    function battleAction(type, itemIdx = null) {
      if (battleBusy || gameState !== 'BATTLE') return;
      battleBusy = true;
      const actor = playerStats.party[currentActorIndex];
      let msg = "";

      if (type === 'attack') {
        const dmg = actor.atk + Math.floor(Math.random() * 5);
        currentEnemy.hp = Math.max(0, currentEnemy.hp - dmg);
        msg = `${actor.name} hit for ${dmg}! `;
      } else if (type === 'skill') {
        const skill = actor.skill || { name: 'Power Strike', cost: 5, mult: 1.8 };
        if (actor.mp >= skill.cost) {
          actor.mp -= skill.cost;
          const dmg = Math.floor(actor.atk * skill.mult);
          currentEnemy.hp = Math.max(0, currentEnemy.hp - dmg);
          if (skill.heal) actor.hp = Math.min(actor.maxHp, actor.hp + skill.heal);
          msg = `${actor.name} used ${skill.name} for ${dmg}! `;
        } else { alert("Not enough MP!"); battleBusy = false; return; }
      } else if (type === 'flee') {
        if (Math.random() > 0.4) { endBattle("You escaped!"); return; }
        msg = "Flee failed! ";
      } else if (type === 'item') {
        const item = playerStats.inventory[itemIdx];
        if (item.type === 'capture') {
          const captured = JSON.parse(JSON.stringify(currentEnemy));
          playerStats.party.push(captured); item.count--; if (item.count <= 0) playerStats.inventory.splice(itemIdx, 1);
          if (document.getElementById('menu-modal').style.display === 'block') toggleMenu();
          endBattle(`Captured ${captured.name}!`); return;
        } else if (item.type === 'hp') { actor.hp = Math.min(actor.maxHp, actor.hp + item.val); msg = `${actor.name} healed! `; }
        else if (item.type === 'mp') { actor.mp = Math.min(actor.maxMp, actor.mp + item.val); msg = `${actor.name} restored MP! `; }
        item.count--; if (item.count <= 0) playerStats.inventory.splice(itemIdx, 1);
        if (document.getElementById('menu-modal').style.display === 'block') toggleMenu();
      }

      updateBattleUI(msg);
      if (currentEnemy.hp <= 0) {
        playerStats.gold += currentEnemy.gold; gainXp(currentEnemy.xp);
        endBattle(`Victorious! Gained ${currentEnemy.xp}XP & ${currentEnemy.gold}G.`);
      } else {
        setTimeout(() => {
          currentActorIndex++;
          while (currentActorIndex < playerStats.party.length && playerStats.party[currentActorIndex].hp <= 0) currentActorIndex++;
          if (currentActorIndex >= playerStats.party.length) {
            const targets = playerStats.party.filter(p => p.hp > 0);
            const target = targets[Math.floor(Math.random() * targets.length)];
            const eDmg = Math.max(1, currentEnemy.atk + Math.floor(Math.random() * 3));
            target.hp = Math.max(0, target.hp - eDmg);
            updateBattleUI(`${msg}${currentEnemy.name} hits ${target.name} for ${eDmg}!`);
            if (playerStats.party.every(p => p.hp <= 0)) { alert("The party has fallen..."); location.reload(); }
            setTimeout(() => {
              currentActorIndex = 0; while (playerStats.party[currentActorIndex].hp <= 0) currentActorIndex++;
              battleBusy = false; updateBattleUI();
            }, 800);
          } else { battleBusy = false; updateBattleUI(); }
        }, 600);
      }
    }

    function gainXp(amt) {
      playerStats.party.forEach(member => {
        if (member.hp <= 0) return;
        member.xp = (member.xp || 0) + amt;
        const req = member.lvl * 50;
        if (member.xp >= req) {
          member.lvl++; member.maxHp += 15; member.hp = member.maxHp;
          member.maxMp += 5; member.mp = member.maxMp; member.atk += 3;
        }
      });
    }

    function endBattle(msg) {
      updateBattleUI(msg);
      setTimeout(() => {
        document.getElementById('battle-screen').style.display = 'none';
        gameState = 'EXPLORE';
        battleBusy = false;
      }, 1500);
    }

    function initStarterScreen() {
      const screen = document.getElementById('starter-screen');
      const container = screen.querySelector('.starter-cards');
      STARTERS.forEach((s, i) => {
        const card = document.createElement('div');
        card.className = 'starter-card';
        card.onclick = () => selectStarter(i);
        card.innerHTML = `<canvas id="starter-canvas-${i}" width="100" height="100"></canvas><h3>${s.name}</h3><div class="stats">HP: ${s.maxHp}<br>ATK: ${s.atk}<br>MP: ${s.maxMp}<br>Skill: ${s.skill.name}</div><button class="menu-btn" style="pointer-events:none">Select</button>`;
        container.appendChild(card);
        drawMonsterIcon(document.getElementById(`starter-canvas-${i}`).getContext('2d'), s.name);
      });
    }
    function selectStarter(idx) {
      playerStats.party = [JSON.parse(JSON.stringify(STARTERS[idx]))];
      document.getElementById('starter-screen').style.display = 'none';
      updateHud();
    }
    initStarterScreen();
    draw();
  </script>
</body>
</html>