<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rpg-game</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      image-rendering: pixelated;
      border: 4px solid #444;
      cursor: pointer;
    }
    #dialog {
      display: none; position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
      background: white; padding: 20px; border: 4px solid #444; font-family: monospace;
      width: 90%; max-width: 400px; box-sizing: border-box; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 100;
    }
    #shop {
      display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border: 4px solid #444; font-family: monospace;
      width: 90%; max-width: 320px; box-sizing: border-box; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 250;
    }
    #menu-modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 250;
    }
    .modal-inner {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border: 4px solid #444; font-family: monospace;
      width: 90%; max-width: 320px; box-sizing: border-box; box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    #menu-trigger {
      position: absolute; bottom: 20px; right: 20px; z-index: 150;
      padding: 10px 20px; cursor: pointer; background: #444; color: white;
      border: 2px solid #888; font-family: monospace; pointer-events: auto;
    }
    .menu-btn { width: 100%; padding: 12px; margin: 5px 0; cursor: pointer; background: #eee; border: 1px solid #ccc; font-family: monospace; font-size: 14px; }
    .menu-btn:hover { background: #ddd; }
    .shop-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #eee; }
    .shop-item button { cursor: pointer; padding: 8px 12px; background: #4caf50; color: white; border: none; }
    #battle-screen {
      display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: #111; color: white; flex-direction: column; align-items: center; justify-content: center;
      font-family: monospace; z-index: 200; padding: 15px; box-sizing: border-box;
    }
    .battle-stats { display: flex; gap: 10px; margin-bottom: 10px; font-size: 0.9em; width: 100%; flex: 1; min-height: 0; overflow-y: auto; }
    .battle-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; width: 100%; max-width: 400px; margin-top: auto; }
    .battle-actions button { padding: 12px; font-size: 1em; cursor: pointer; background: #444; color: white; border: 2px solid #888; flex: 1 1 120px; }
    .battle-actions button:hover { background: #666; }
    #battle-msg { font-size: 1.1em; color: #ffeb3b; text-align: center; margin: 10px 0; min-height: 1.5em; }
    #flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 300; }
    @keyframes flash-anim { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
    .flashing { animation: flash-anim 0.5s ease-out; }
    .dungeon-info { color: #ff66ff; font-weight: bold; }
    .bar-container { width: 100px; height: 14px; background: #333; border: 1px solid #555; margin: 4px 0; position: relative; border-radius: 2px; overflow: hidden; }
    .bar-fill { height: 100%; width: 100%; transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1); }
    .bar-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; font-size: 9px; line-height: 14px; text-align: center; color: white; text-shadow: 1px 1px 1px black; font-weight: bold; pointer-events: none; }
    .hp-fill { background: #4caf50; } .mp-fill { background: #2196f3; } .xp-fill { background: #ffeb3b; }
    .battle-card { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; padding: 6px; font-size: 0.75em; border: 2px solid transparent; background: rgba(255,255,255,0.05); border-radius: 4px; width: 100%; box-sizing: border-box; }
    .active-actor { border-color: #ffeb3b; background: rgba(255,235,59,0.1); }
    .battle-card-canvas { background: #222; border: 1px solid #444; border-radius: 50%; width: 50px; height: 50px; flex-shrink: 0; }
    #starter-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #222; z-index: 500;
      display: flex; flex-direction: column; align-items: center; justify-content: center; color: white;
      font-family: monospace; overflow-y: auto; padding: 20px; box-sizing: border-box;
    }
    #starter-screen h1 { font-size: 1.5em; text-align: center; margin: 10px 0; }
    .starter-cards { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; justify-content: center; width: 100%; }
    .starter-card { background: #333; border: 4px solid #555; padding: 15px; width: 140px; text-align: center; cursor: pointer; transition: transform 0.2s, border-color 0.2s; }
    .starter-card:hover { transform: scale(1.05); border-color: #ffeb3b; }
    .starter-card h3 { margin: 8px 0; color: #ffeb3b; font-size: 1em; }
    .starter-card .stats { font-size: 0.75em; text-align: left; margin: 8px 0; line-height: 1.3; }
  </style>
</head>
<body>
  <div id="starter-screen">
    <h1>Choose Your Starter Monster</h1>
    <div class="starter-cards"></div>
  </div>
  <button id="menu-trigger" onclick="toggleMenu()">Menu</button>
  <div id="flash-overlay"></div>
  <div id="battle-screen">
    <div class="battle-stats">
      <div style="flex: 1; display: flex; flex-direction: column; border-right: 1px solid #333; padding-right: 8px; min-width: 0;">
        <div style="font-weight: bold; border-bottom: 1px solid #555; margin-bottom: 5px; font-size: 0.8em;">PARTY</div>
        <div id="party-list"></div>
      </div>
      <div style="flex: 1; display: flex; flex-direction: column; padding-left: 8px; align-items: flex-end; min-width: 0;">
        <div style="font-weight: bold; border-bottom: 1px solid #555; margin-bottom: 5px; width: 100%; text-align: right; font-size: 0.8em;">ENEMIES</div>
        <div id="enemy-list"></div>
      </div>
    </div>
    <div id="acting-name" style="color: #4caf50; font-weight: bold; margin: 8px 0; text-align: center; font-size: 0.9em;"></div>
    <div id="battle-msg">A wild monster appears!</div>
    <div class="battle-actions">
      <button onclick="battleAction('attack')">Attack</button>
      <button onclick="battleAction('skill')">Skill</button>
      <button onclick="openBattleBag()">Bag</button>
      <button onclick="battleAction('flee')">Flee</button>
    </div>
  </div>
  <div id="dialog">
    <div id="dialogText"></div>
    <div style="margin-top: 10px; font-size: 0.8em; color: #666; text-align: right;">Click anywhere to close</div>
  </div>
  <div id="shop">
    <h3 style="margin: 0 0 10px 0;">Village Shop</h3>
    <div id="shop-items"></div>
    <button onclick="closeShop()" style="margin-top: 15px; width: 100%; cursor: pointer;">Exit Shop</button>
  </div>
  <div id="menu-modal" onclick="if(event.target === this) toggleMenu()">
    <div class="modal-inner">
      <div id="menu-content"></div>
    </div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Config
    const TILE_SIZE = 64;
    let currentMapId = 'world';
    let mapWidth = 60;
    let mapHeight = 60;
    const PLAYER_SPEED = 4;
    
    // State
    let gameState = 'EXPLORE'; // EXPLORE, BATTLE
    const player = {
      x: 52 * TILE_SIZE + 32,
      y: 30 * TILE_SIZE + 32,
      path: [],
      size: 40,
      isWalking: false,
      animFrame: 0,
      stepsToEncounter: Math.floor(Math.random() * 16) + 15
    };

    function findPath(startTX, startTY, endTX, endTY) {
      if (startTX === endTX && startTY === endTY) return [];
      const queue = [[startTX, startTY, []]];
      const visited = new Set([`${startTX},${startTY}`]);
      while (queue.length > 0) {
        const [cx, cy, path] = queue.shift();
        const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dx, dy] of neighbors) {
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && nx < mapWidth && ny >= 0 && ny < mapHeight && map[ny][nx].traversable && !visited.has(`${nx},${ny}`)) {
            const newPath = [...path, { x: nx * TILE_SIZE + TILE_SIZE / 2, y: ny * TILE_SIZE + TILE_SIZE / 2 }];
            if (nx === endTX && ny === endTY) return newPath;
            visited.add(`${nx},${ny}`);
            queue.push([nx, ny, newPath]);
          }
        }
      }
      return null;
    }

    const playerStats = {
      party: [],
      gold: 150, inventory: [],
      lastHealLocation: null,
      defeatedNpcIds: []
    };
    const MORPHOLOGY_SLOTS = {
      'Bipedal': ['Head', 'Chest', 'Hands', 'Feet'],
      'Quadrupedal': ['Head', 'Chest', 'Feet'],
      'Aerial': ['Head', 'Chest', 'Wings'],
      'Serpentine': ['Head', 'Body'],
      'Amorphous': ['Core'],
      'Arthropod': ['Head', 'Thorax', 'Legs'],
      'Robotic': ['Chassis', 'Module']
    };
    const SLOT_TO_TYPE = {
      'Head': 'Helmet', 'Chest': 'Armor', 'Hands': 'Gloves', 'Feet': 'Boots', 'Wings': 'Wing-Guard', 'Body': 'Scale-Mail', 'Core': 'Gem', 'Thorax': 'Carapace', 'Legs': 'Greaves', 'Chassis': 'Plate', 'Module': 'Chip'
    };
    const EQUIPMENT_DB = {
      'Iron Helmet': { type: 'Helmet', stats: { def: 5 } },
      'Leather Vest': { type: 'Armor', stats: { def: 3 } },
      'Swift Sandals': { type: 'Boots', stats: { spd: 10 } },
      'Power Bracers': { type: 'Gloves', stats: { atk: 8 } },
      'Steel Plate': { type: 'Plate', stats: { def: 18 } },
      'Obsidian Scales': { type: 'Scale-Mail', stats: { def: 12, resist: ['Fire'] } },
      'Fire Orb': { type: 'Gem', stats: { FireBoost: 0.3, skill: { name: 'Ember Blast', cost: 10, mult: 2.2, type: 'Fire' } } },
      'Wind Feather': { type: 'Wing-Guard', stats: { spd: 15, resist: ['Air'] } }
    };
    const TYPE_CHART = {
      'Fire': { weakTo: ['Water', 'Earth'], resist: ['Nature', 'Fire'] },
      'Water': { weakTo: ['Nature', 'Electric'], resist: ['Fire', 'Water'] },
      'Nature': { weakTo: ['Fire', 'Air'], resist: ['Water', 'Nature', 'Earth'] },
      'Dark': { weakTo: ['Holy'], resist: ['Dark', 'Psionic'] },
      'Holy': { weakTo: ['Dark'], resist: ['Holy'] },
      'Normal': { weakTo: [], resist: [] },
      'Earth': { weakTo: ['Nature', 'Water'], resist: ['Fire', 'Electric', 'Earth'] },
      'Electric': { weakTo: ['Earth'], resist: ['Air', 'Electric'] },
      'Air': { weakTo: ['Electric'], resist: ['Earth', 'Nature'] },
      'Psionic': { weakTo: ['Dark', 'Cyber'], resist: ['Normal', 'Psionic'] },
      'Cyber': { weakTo: ['Electric', 'Kaiju'], resist: ['Psionic', 'Air'] },
      'Aether': { weakTo: ['Aether'], resist: ['Fire', 'Water', 'Nature', 'Earth', 'Electric', 'Air', 'Dark', 'Holy', 'Normal', 'Psionic', 'Cyber', 'Kaiju'] },
      'Kaiju': { weakTo: ['Aether', 'Psionic'], resist: ['Fire', 'Water', 'Earth', 'Normal'] }
    };
    const MONSTER_DB = {
      'Leafy': { captureRate: 1, morphology: 'Serpentine', growth: 'fast', hp: 45, mp: 10, atk: 7, spd: 10, type: 'Nature', draw: (c) => { c.fillStyle = '#84cc16'; c.beginPath(); c.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#4d7c0f'; c.beginPath(); c.moveTo(0, -15); c.quadraticCurveTo(15, -35, 0, -45); c.quadraticCurveTo(-15, -35, 0, -15); c.fill(); }, skills: [{ name: 'Leaf Blade', lvl: 1, cost: 0, mult: 1.3, type: 'Nature' }] },
      'Sprout': { captureRate: 1, morphology: 'Amorphous', growth: 'fast', hp: 42, mp: 15, atk: 6, spd: 12, type: 'Nature', draw: (c) => { c.fillStyle = '#a3e635'; c.beginPath(); c.arc(0, 0, 15, 0, Math.PI*2); c.fill(); c.fillStyle = '#3f6212'; c.beginPath(); c.moveTo(0,-15); c.lineTo(8,-22); c.moveTo(0,-15); c.lineTo(-8,-22); c.stroke(); }, skills: [{ name: 'Vine Whip', lvl: 1, cost: 0, mult: 1.2, type: 'Nature' }] },
      'Cliff-Ram': { captureRate: 0.3, morphology: 'Quadrupedal', hp: 100, mp: 20, atk: 18, spd: 15, type: 'Earth', draw: (c) => { c.fillStyle = '#94a3b8'; c.beginPath(); c.roundRect(-25, -35, 50, 35, 8); c.fill(); c.strokeStyle = 'white'; c.lineWidth = 4; c.beginPath(); c.moveTo(-15,-35); c.quadraticCurveTo(-25,-55, -35, -35); c.moveTo(15,-35); c.quadraticCurveTo(25,-55, 35, -35); c.stroke(); }, skills: [{ name: 'Headbutt', lvl: 1, cost: 5, mult: 1.5, type: 'Earth' }] },
      'Sky-Shredder': { captureRate: 0.3, morphology: 'Aerial', hp: 85, mp: 30, atk: 22, spd: 28, type: 'Air', draw: (c) => { c.fillStyle = '#38bdf8'; c.beginPath(); c.ellipse(0, -20, 25, 15, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#ef4444'; c.beginPath(); c.moveTo(-25,-20); c.lineTo(-45, -35); c.lineTo(-25, -10); c.fill(); c.beginPath(); c.moveTo(25,-20); c.lineTo(45, -35); c.lineTo(25, -10); c.fill(); }, skills: [{ name: 'Aerial Ace', lvl: 1, cost: 8, mult: 1.6, type: 'Air' }] },
      'Sand-Stinger': { captureRate: 0.2, morphology: 'Arthropod', hp: 140, mp: 40, atk: 30, spd: 20, type: 'Dark', draw: (c) => { c.fillStyle = '#9333ea'; c.beginPath(); c.ellipse(0, 0, 20, 12, 0, 0, Math.PI*2); c.fill(); c.strokeStyle = '#9333ea'; c.lineWidth = 5; c.beginPath(); c.moveTo(0,-10); c.quadraticCurveTo(30, -50, 10, -60); c.stroke(); }, skills: [{ name: 'Poison Jab', lvl: 1, cost: 10, mult: 1.8, type: 'Dark' }] },
      'Sun-Cactus': { captureRate: 0.2, morphology: 'Bipedal', hp: 160, mp: 50, atk: 26, spd: 12, type: 'Fire', draw: (c) => { c.fillStyle = '#166534'; c.beginPath(); c.roundRect(-15, -50, 30, 50, 10); c.fill(); c.fillStyle = '#fde047'; c.beginPath(); c.arc(0, -55, 8, 0, Math.PI*2); c.fill(); }, skills: [{ name: 'Needle Blast', lvl: 1, cost: 12, mult: 2.0, type: 'Fire' }] },
      'Rabbite': { captureRate: 1, morphology: 'Quadrupedal', growth: 'fast', hp: 35, mp: 5, atk: 5, spd: 8, type: 'Normal', draw: (c) => { c.fillStyle = 'white'; c.beginPath(); c.arc(0, -15, 20, 0, Math.PI*2); c.fill(); c.beginPath(); c.ellipse(-8, -40, 6, 15, -0.1, 0, Math.PI*2); c.fill(); c.beginPath(); c.ellipse(8, -40, 6, 15, 0.1, 0, Math.PI*2); c.fill(); }, skills: [{ name: 'Bite', lvl: 1, cost: 0, mult: 1.2, type: 'Normal' }] },
      'Birby': { captureRate: 1, morphology: 'Aerial', growth: 'fast', hp: 30, mp: 5, atk: 4, spd: 12, type: 'Normal', draw: (c) => { c.fillStyle = '#facc15'; c.beginPath(); c.arc(0, -15, 18, 0, Math.PI*2); c.fill(); c.fillStyle = '#f97316'; c.beginPath(); c.moveTo(10, -15); c.lineTo(22, -12); c.lineTo(10, -9); c.fill(); }, skills: [{ name: 'Peck', lvl: 1, cost: 0, mult: 1.1, type: 'Normal' }] },
      'Cattus': { captureRate: 0.9, morphology: 'Quadrupedal', hp: 40, mp: 8, atk: 6, spd: 10, type: 'Normal', draw: (c) => { c.fillStyle = '#fb923c'; c.beginPath(); c.arc(0, -20, 22, 0, Math.PI*2); c.fill(); c.beginPath(); c.moveTo(-18,-35); c.lineTo(-10,-45); c.lineTo(-2,-35); c.fill(); c.beginPath(); c.moveTo(18,-35); c.lineTo(10,-45); c.lineTo(2,-35); c.fill(); }, skills: [{ name: 'Scratch', lvl: 1, cost: 0, mult: 1.3, type: 'Normal' }] },
      'Terramole': { captureRate: 0.5, morphology: 'Quadrupedal', hp: 120, mp: 20, atk: 12, spd: 6, type: 'Earth', draw: (c) => { c.fillStyle = '#78350f'; c.beginPath(); c.ellipse(0, -15, 25, 20, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#451a03'; c.beginPath(); c.moveTo(-20, 0); c.lineTo(-30, -10); c.lineTo(-20, -5); c.fill(); c.beginPath(); c.moveTo(20, 0); c.lineTo(30, -10); c.lineTo(20, -5); c.fill(); }, skills: [ { name: 'Mud Slap', lvl: 1, cost: 5, mult: 1.4, type: 'Earth' }, { name: 'Earthquake', lvl: 12, cost: 18, mult: 2.8, type: 'Earth' } ]},
      'Rockogolem': { captureRate: 0.4, morphology: 'Bipedal', hp: 150, mp: 15, atk: 15, spd: 4, type: 'Earth', draw: (c) => { c.fillStyle = '#475569'; c.fillRect(-25, -25, 50, 25); c.fillRect(-15, -50, 30, 25); c.fillStyle = '#06b6d4'; c.beginPath(); c.arc(-8, -38, 3, 0, Math.PI*2); c.fill(); c.arc(8, -38, 3, 0, Math.PI*2); c.fill(); }, skills: [ { name: 'Rock Throw', lvl: 1, cost: 6, mult: 1.6, type: 'Earth' }, { name: 'Stone Smash', lvl: 14, cost: 22, mult: 3.2, type: 'Earth' } ]},
      'Sparkat': { captureRate: 0.5, morphology: 'Quadrupedal', hp: 80, mp: 30, atk: 14, spd: 22, type: 'Electric', draw: (c) => { c.fillStyle = '#eab308'; c.beginPath(); c.arc(0, -20, 20, 0, Math.PI*2); c.fill(); c.strokeStyle = '#eab308'; c.lineWidth = 4; c.beginPath(); c.moveTo(0,0); c.lineTo(-10, 15); c.lineTo(5, 10); c.lineTo(0, 25); c.stroke(); }, skills: [ { name: 'Zapping Claw', lvl: 1, cost: 8, mult: 1.5, type: 'Electric' }, { name: 'Thunder Bolt', lvl: 15, cost: 25, mult: 3.5, type: 'Electric' } ]},
      'Voltix': { captureRate: 0.6, morphology: 'Amorphous', hp: 70, mp: 45, atk: 10, spd: 18, type: 'Electric', draw: (c) => { c.fillStyle = '#60a5fa'; c.beginPath(); c.arc(0, -30, 20, 0, Math.PI*2); c.fill(); c.strokeStyle = 'white'; c.beginPath(); for(let i=0; i<8; i++) { let a = i*Math.PI/4; c.moveTo(0,-30); c.lineTo(Math.cos(a)*35, -30+Math.sin(a)*35); } c.stroke(); }, skills: [ { name: 'Static Shock', lvl: 1, cost: 5, mult: 1.3, type: 'Electric' }, { name: 'Overload', lvl: 16, cost: 30, mult: 4.2, type: 'Electric' } ]},
      'Zephyros': { captureRate: 0.5, morphology: 'Aerial', hp: 85, mp: 35, atk: 12, spd: 25, type: 'Air', draw: (c) => { c.fillStyle = 'white'; c.beginPath(); c.arc(-15, -20, 15, 0, Math.PI*2); c.arc(15, -20, 15, 0, Math.PI*2); c.arc(0, -35, 20, 0, Math.PI*2); c.fill(); }, skills: [ { name: 'Air Slash', lvl: 1, cost: 7, mult: 1.4, type: 'Air' }, { name: 'Tornado', lvl: 14, cost: 24, mult: 3.4, type: 'Air' } ]},
      'Galehawk': { captureRate: 0.4, morphology: 'Aerial', hp: 95, mp: 25, atk: 18, spd: 20, type: 'Air', draw: (c) => { c.fillStyle = '#713f12'; c.beginPath(); c.moveTo(0, -10); c.lineTo(-50, -40); c.lineTo(0, -60); c.lineTo(50, -40); c.closePath(); c.fill(); c.fillStyle = '#ca8a04'; c.beginPath(); c.arc(0,-35,12,0,Math.PI*2); c.fill(); }, skills: [ { name: 'Gust', lvl: 1, cost: 6, mult: 1.6, type: 'Air' }, { name: 'Sky Dive', lvl: 15, cost: 28, mult: 3.8, type: 'Air' } ]},
      'Mindbug': { captureRate: 0.1, morphology: 'Arthropod', growth: 'slow', hp: 110, mp: 80, atk: 15, spd: 15, type: 'Psionic', draw: (c) => { c.fillStyle = '#d946ef'; c.beginPath(); c.ellipse(0, -30, 25, 18, 0, 0, Math.PI*2); c.fill(); c.strokeStyle = '#701a75'; c.beginPath(); c.moveTo(-10,-45); c.lineTo(-20,-60); c.moveTo(10,-45); c.lineTo(20,-60); c.stroke(); }, skills: [ { name: 'Psy-Beam', lvl: 1, cost: 12, mult: 2.0, type: 'Psionic' }, { name: 'Mind Crush', lvl: 25, cost: 45, mult: 4.5, type: 'Psionic' } ]},
      'Telecrane': { captureRate: 0.1, morphology: 'Bipedal', hp: 130, mp: 60, atk: 22, spd: 18, type: 'Psionic', draw: (c) => { c.fillStyle = '#fda4af'; c.beginPath(); c.ellipse(0, -40, 10, 30, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#f43f5e'; c.beginPath(); c.arc(0,-70,12,0,Math.PI*2); c.fill(); c.fillStyle = '#22d3ee'; c.beginPath(); c.arc(0,-75,4,0,Math.PI*2); c.fill(); }, skills: [ { name: 'Kinesis', lvl: 1, cost: 10, mult: 1.8, type: 'Psionic' }, { name: 'Thought Wave', lvl: 22, cost: 35, mult: 3.8, type: 'Psionic' } ]},
      'Droid-X': { captureRate: 0.1, morphology: 'Robotic', hp: 140, mp: 50, atk: 25, spd: 16, type: 'Cyber', draw: (c) => { c.fillStyle = '#94a3b8'; c.fillRect(-20,-50,40,50); c.fillStyle = '#22d3ee'; c.fillRect(-15,-40,30,8); }, skills: [ { name: 'Laser Shot', lvl: 1, cost: 15, mult: 2.2, type: 'Cyber' }, { name: 'Sync Pulse', lvl: 24, cost: 40, mult: 4.0, type: 'Cyber' } ]},
      'Glitcher': { captureRate: 0.05, morphology: 'Robotic', growth: 'slow', hp: 100, mp: 100, atk: 20, spd: 28, type: 'Cyber', draw: (c) => { c.fillStyle = '#22c55e'; c.fillRect(-20,-40,40,40); c.fillStyle = 'black'; c.fillRect(-10,-30,5,5); c.fillRect(5,-30,5,5); c.fillRect(-10,-15,20,3); }, skills: [ { name: 'Bug Strike', lvl: 1, cost: 12, mult: 1.9, type: 'Cyber' }, { name: 'System Crash', lvl: 26, cost: 50, mult: 5.5, type: 'Cyber' } ]},
      'Omnistar': { captureRate: 0.01, morphology: 'Amorphous', growth: 'slow', hp: 300, mp: 150, atk: 45, spd: 40, type: 'Aether', draw: (c) => { c.fillStyle = '#fde047'; c.beginPath(); for(let i=0;i<5;i++){ let a=(i*72-90)*Math.PI/180; c.lineTo(Math.cos(a)*40, -30+Math.sin(a)*40); a=((i*72+36)-90)*Math.PI/180; c.lineTo(Math.cos(a)*15, -30+Math.sin(a)*15); } c.closePath(); c.fill(); }, skills: [ { name: 'Aether Flash', lvl: 1, cost: 25, mult: 3.0, type: 'Aether' }, { name: 'Cosmic End', lvl: 35, cost: 80, mult: 7.0, type: 'Aether' } ]},
      'Cosmogazer': { captureRate: 0.02, morphology: 'Amorphous', growth: 'slow', hp: 250, mp: 200, atk: 35, spd: 45, type: 'Aether', draw: (c) => { c.fillStyle = '#6366f1'; c.beginPath(); c.arc(0,-30,30,0,Math.PI*2); c.fill(); c.fillStyle = 'white'; for(let i=0;i<10;i++) c.fillRect(Math.random()*40-20, -50+Math.random()*40, 2, 2); }, skills: [ { name: 'Star Dust', lvl: 1, cost: 20, mult: 2.5, type: 'Aether' }, { name: 'Universe Warp', lvl: 38, cost: 90, mult: 8.5, type: 'Aether' } ]},
      'Giga-Rex': { captureRate: 0.01, morphology: 'Bipedal', growth: 'slow', hp: 500, mp: 100, atk: 55, spd: 25, type: 'Kaiju', draw: (c) => { c.fillStyle = '#ef4444'; c.beginPath(); c.moveTo(-30,0); c.lineTo(-20,-60); c.lineTo(20,-60); c.lineTo(40,0); c.closePath(); c.fill(); c.fillStyle = 'white'; c.beginPath(); c.moveTo(0,-50); c.lineTo(10,-40); c.lineTo(20,-50); c.fill(); }, skills: [ { name: 'Primal Roar', lvl: 1, cost: 30, mult: 3.5, type: 'Kaiju' }, { name: 'Atomic Breath', lvl: 40, cost: 100, mult: 9.0, type: 'Kaiju' } ]},
      'Abyssal-Terror': { captureRate: 0.01, morphology: 'Amorphous', growth: 'slow', hp: 400, mp: 120, atk: 65, spd: 30, type: 'Kaiju', draw: (c) => { c.fillStyle = 'black'; c.beginPath(); c.ellipse(0,-10,40,20,0,0,Math.PI*2); c.fill(); c.fillStyle = 'red'; for(let i=0;i<5;i++) { c.beginPath(); c.arc(-30+i*15, -20+Math.random()*10, 4, 0, Math.PI*2); c.fill(); } }, skills: [ { name: 'Void Grip', lvl: 1, cost: 35, mult: 4.0, type: 'Kaiju' }, { name: 'Calamity', lvl: 42, cost: 110, mult: 10.0, type: 'Kaiju' } ]},
      'Sylvaris': { captureRate: 0.5, morphology: 'Bipedal', hp: 120, mp: 15, atk: 8, spd: 10, type: 'Nature', draw: (c) => { c.fillStyle = '#22c55e'; c.beginPath(); c.ellipse(0,-35,15,35,0,0,Math.PI*2); c.fill(); c.fillStyle = '#84cc16'; c.beginPath(); c.moveTo(-15,-40); c.lineTo(-40,-60); c.lineTo(-15,-50); c.fill(); c.beginPath(); c.moveTo(15,-40); c.lineTo(40,-60); c.lineTo(15,-50); c.fill(); }, skills: [ { name: 'Solar Bloom', lvl: 1, cost: 5, mult: 1.2, heal: 15, type: 'Nature' }, { name: 'Razor Leaf', lvl: 5, cost: 8, mult: 1.8, type: 'Nature' }, { name: 'Nature Embrace', lvl: 16, cost: 18, mult: 2.2, heal: 30, type: 'Nature' }, { name: 'Thorn Blast', lvl: 24, cost: 25, mult: 3.5, type: 'Nature' }, { name: 'Genesis Wave', lvl: 38, cost: 60, mult: 5.5, type: 'Nature' } ]},
      'Ignifrit': { captureRate: 0.5, morphology: 'Bipedal', hp: 80, mp: 10, atk: 16, spd: 15, type: 'Fire', draw: (c) => { c.fillStyle = '#f97316'; c.beginPath(); c.moveTo(-20,0); c.lineTo(0,-70); c.lineTo(20,0); c.fill(); c.fillStyle = '#fde047'; c.beginPath(); c.moveTo(-10,0); c.lineTo(0,-40); c.lineTo(10,0); c.fill(); }, skills: [ { name: 'Ember', lvl: 1, cost: 4, mult: 1.5, type: 'Fire' }, { name: 'Fireball', lvl: 7, cost: 10, mult: 2.2, type: 'Fire' }, { name: 'Lava Burst', lvl: 14, cost: 20, mult: 3.2, type: 'Fire' }, { name: 'Phoenix Strike', lvl: 26, cost: 35, mult: 4.5, type: 'Fire' }, { name: 'Supernova', lvl: 41, cost: 70, mult: 6.5, type: 'Fire' } ]},
      'Aquasaur': { captureRate: 0.5, morphology: 'Quadrupedal', hp: 100, mp: 25, atk: 11, spd: 8, type: 'Water', draw: (c) => { c.fillStyle = '#3b82f6'; c.beginPath(); c.roundRect(-25,-40,50,40,10); c.fill(); c.fillStyle = '#93c5fd'; c.beginPath(); c.moveTo(25,-30); c.lineTo(45,-50); c.lineTo(25,-10); c.fill(); }, skills: [ { name: 'Bubble', lvl: 1, cost: 4, mult: 1.4, type: 'Water' }, { name: 'Tsunami', lvl: 4, cost: 12, mult: 2.0, type: 'Water' }, { name: 'Hydro Cannon', lvl: 15, cost: 22, mult: 3.0, type: 'Water' }, { name: 'Ice Beam', lvl: 25, cost: 38, mult: 4.2, type: 'Water' }, { name: 'Oceanic Ruin', lvl: 39, cost: 65, mult: 5.8, type: 'Water' } ]},
      'Gloop': { captureRate: 0.8, morphology: 'Amorphous', growth: 'fast', hp: 40, mp: 10, atk: 4, spd: 5, type: 'Nature', draw: (c) => { c.fillStyle = '#4ade80'; c.beginPath(); c.arc(0, 0, 30, Math.PI, 0); c.ellipse(0, 0, 30, 15, 0, 0, Math.PI); c.fill(); }, skills: [ { name: 'Bouncy Slam', lvl: 1, cost: 4, mult: 1.4, type: 'Normal' }, { name: 'Slime Trap', lvl: 10, cost: 12, mult: 2.5, type: 'Nature' } ]},
      'Boneguard': { captureRate: 0.7, morphology: 'Bipedal', hp: 50, mp: 12, atk: 7, spd: 12, type: 'Dark', draw: (c) => { c.fillStyle = '#e2e8f0'; c.fillRect(-10,-40,20,40); c.beginPath(); c.arc(0,-50,15,0,Math.PI*2); c.fill(); c.fillStyle = '#475569'; c.fillRect(10,-35,5,30); }, skills: [ { name: 'Bone Shard', lvl: 1, cost: 5, mult: 1.8, type: 'Dark' }, { name: 'Grave Chill', lvl: 12, cost: 15, mult: 3.0, type: 'Dark' } ]},
      'Medusoid': { captureRate: 0.4, morphology: 'Serpentine', hp: 60, mp: 20, atk: 6, spd: 7, type: 'Nature', draw: (c) => { c.fillStyle = '#166534'; c.beginPath(); c.arc(0, -30, 25, 0, Math.PI*2); c.fill(); c.strokeStyle = '#22c55e'; c.lineWidth = 3; for(let i=0;i<6;i++) { c.beginPath(); c.moveTo(0,-45); c.quadraticCurveTo(Math.sin(i)*40,-70, Math.sin(i)*30,-50); c.stroke(); } }, skills: [ { name: 'Gaze', lvl: 1, cost: 6, mult: 1.6, type: 'Dark' }, { name: 'Stone Curse', lvl: 15, cost: 20, mult: 3.5, type: 'Dark' } ]},
      'Voidshade': { captureRate: 0.2, morphology: 'Amorphous', hp: 45, mp: 30, atk: 8, spd: 20, type: 'Dark', draw: (c) => { c.fillStyle = 'rgba(0,0,0,0.7)'; c.beginPath(); c.moveTo(-20,0); c.quadraticCurveTo(0,-80,20,0); c.fill(); c.fillStyle = 'red'; c.beginPath(); c.arc(-5,-45,2,0,Math.PI*2); c.fill(); c.beginPath(); c.arc(5,-45,2,0,Math.PI*2); c.fill(); }, skills: [ { name: 'Abyssal Pulse', lvl: 1, cost: 7, mult: 1.9, type: 'Dark' }, { name: 'Event Horizon', lvl: 20, cost: 40, mult: 4.5, type: 'Dark' } ]},
      'Aetherwing': { captureRate: 0.1, morphology: 'Aerial', hp: 90, mp: 40, atk: 14, spd: 25, type: 'Fire', draw: (c) => { c.fillStyle = '#a855f7'; c.beginPath(); c.ellipse(0,-30,25,20,0,0,Math.PI*2); c.fill(); c.beginPath(); c.moveTo(-25,-35); c.lineTo(-50,-55); c.lineTo(-20,-45); c.fill(); c.beginPath(); c.moveTo(25,-35); c.lineTo(50,-55); c.lineTo(20,-45); c.fill(); }, skills: [ { name: 'Sky Dive', lvl: 1, cost: 10, mult: 2.5, type: 'Fire' }, { name: 'Star Fall', lvl: 22, cost: 50, mult: 5.0, type: 'Fire' } ]}
    };
    function getMonsterFinalStats(m) {
      const stats = { atk: m.atk, def: m.def || 0, spd: m.spd, resists: [], boosts: {} };
      for (let slot in m.equipment) {
        const item = EQUIPMENT_DB[m.equipment[slot]];
        if (!item) continue;
        if (item.stats.atk) stats.atk += item.stats.atk;
        if (item.stats.def) stats.def += item.stats.def;
        if (item.stats.spd) stats.spd += item.stats.spd;
        if (item.stats.resist) stats.resists.push(...item.stats.resist);
        for (let key in item.stats) {
          if (key.endsWith('Boost')) { stats.boosts[key.replace('Boost', '')] = (stats.boosts[key.replace('Boost', '')] || 0) + item.stats[key]; }
        }
      }
      return stats;
    }
    function calculateSkillDamage(attacker, defender, skill) {
      const a = getMonsterFinalStats(attacker), d = getMonsterFinalStats(defender);
      let dmg = a.atk * (skill.mult || 1.5);
      const boost = a.boosts[skill.type] || 0;
      dmg *= (1 + boost);
      if (skill.type === attacker.type) dmg *= 1.5;
      const chart = TYPE_CHART[defender.type] || { weakTo: [], resist: [] };
      const res = [...chart.resist, ...d.resists];
      if (chart.weakTo.includes(skill.type)) dmg *= 2;
      if (res.includes(skill.type)) dmg *= 0.5;
      return Math.max(1, Math.floor(dmg - d.def));
    }
    const ENCOUNTER_ZONES = {
      1: { name: 'Forest', encounters: [
        { weight: 0.4, enemies: [{ key: 'Leafy', lvl: [2, 5], equipment: {} }] },
        { weight: 0.3, enemies: [{ key: 'Sprout', lvl: [1, 4] }, { key: 'Sprout', lvl: [1, 4] }] },
        { weight: 0.3, enemies: [{ key: 'Rabbite', lvl: [3, 6] }] }
      ]},
      2: { name: 'Mountain', encounters: [
        { weight: 0.4, enemies: [{ key: 'Cliff-Ram', lvl: [10, 14], equipment: { 'Head': 'Iron Helmet' } }] },
        { weight: 0.3, enemies: [{ key: 'Sky-Shredder', lvl: [12, 15] }, { key: 'Zephyros', lvl: [11, 13] }] },
        { weight: 0.3, enemies: [{ key: 'Rockogolem', lvl: [13, 16] }] }
      ]},
      3: { name: 'Desert', encounters: [
        { weight: 0.3, enemies: [{ key: 'Sand-Stinger', lvl: [22, 28], equipment: { 'Hands': 'Power Bracers' } }] },
        { weight: 0.3, enemies: [{ key: 'Sun-Cactus', lvl: [20, 25] }, { key: 'Sun-Cactus', lvl: [20, 25] }] },
        { weight: 0.2, enemies: [{ key: 'Droid-X', lvl: [24, 30] }] },
        { weight: 0.2, enemies: [{ key: 'Mindbug', lvl: [25, 32] }] }
      ]}
    };
    function getExpRequired(lvl, growth) {
      const mult = growth === 'fast' ? 0.8 : (growth === 'slow' ? 1.2 : 1.0);
      return Math.floor(mult * Math.pow(lvl, 3));
    }
    function createMonster(key, lvl, isWild = false, zonePoolKey = null) {
      const t = MONSTER_DB[key]; if (!t) return null;
      const m = JSON.parse(JSON.stringify(t));
      m.name = key; m.lvl = lvl; m.ap = 0; m.growth = t.growth || 'normal'; m.xp = lvl > 1 ? getExpRequired(lvl - 1, m.growth) : 0;
      m.maxHp = t.hp + (lvl - 1) * 15; m.hp = m.maxHp;
      m.maxMp = t.mp + (lvl - 1) * 5; m.mp = m.maxMp;
      m.atk = t.atk + (lvl - 1) * 3;
      m.spd = (t.spd || 10) + (lvl - 1) * 2;
      m.def = 0; m.equipment = {}; m.morphology = t.morphology;
      m.rewardXp = lvl * 5;
      m.gold = lvl * 10;
      if (isWild) {
        const slots = MORPHOLOGY_SLOTS[m.morphology] || [];
        const poolItems = zonePoolKey ? (ZONE_EQUIPMENT_POOLS[zonePoolKey] || []) : Object.keys(EQUIPMENT_DB);
        slots.forEach(slot => {
          if (Math.random() < 0.15) {
            const targetType = SLOT_TO_TYPE[slot];
            const choices = poolItems.filter(k => EQUIPMENT_DB[k].type === targetType);
            if (choices.length > 0) m.equipment[slot] = choices[Math.floor(Math.random() * choices.length)];
          }
        });
      }
      m.learnedSkills = (t.skills || []).filter(s => s.lvl <= lvl);
      if (m.learnedSkills.length > 0) m.skill = m.learnedSkills[m.learnedSkills.length - 1];
      return m;
    }
    const STARTERS = [ createMonster('Sylvaris', 5), createMonster('Ignifrit', 5), createMonster('Aquasaur', 5) ];
    let activeActor = null;
    let enemies = [];
    let battleBusy = false;
    let pendingAction = null;
    let pendingSkillIdx = null;

    let NPC_LOCATIONS = [
      { 
        id: 'guide', x: 52, y: 34, mapId: 'world', type: 'dialog', color: '#4444ff', 
        text: "Hello! Follow the road west through the forest. You'll find a lake and the merchant there.",
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.ellipse(x, y + 15, 15, 8, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#4444ff'; c.beginPath(); c.roundRect(x - 12, y - 35, 24, 35, 5); c.fill();
          c.fillStyle = '#ffdbac'; c.beginPath(); c.arc(x, y - 40, 10, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#eab308'; c.beginPath(); c.ellipse(x, y - 45, 15, 5, 0, 0, Math.PI*2); c.fill();
          c.beginPath(); c.arc(x, y - 48, 6, Math.PI, 0); c.fill();
        }
      },
      { 
        id: 'boss_cliffram', x: 18, y: 30, mapId: 'world', type: 'boss', monsterKey: 'Cliff-Ram', level: 12,
        equipment: { 'Head': 'Iron Helmet', 'Chest': 'Steel Plate' },
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.ellipse(x, y + 15, 18, 10, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#94a3b8'; c.beginPath(); c.roundRect(x - 15, y - 25, 30, 25, 5); c.fill();
          c.strokeStyle = 'white'; c.lineWidth = 3; c.beginPath(); c.moveTo(x-10, y-25); c.quadraticCurveTo(x-15, y-35, x-20, y-25); c.moveTo(x+10, y-25); c.quadraticCurveTo(x+15, y-35, x+20, y-25); c.stroke();
        }
      },
      { 
        id: 'merchant', x: 12, y: 26, mapId: 'world', type: 'merchant', color: '#f1c40f', 
        items: [
          { name: 'Health Potion', price: 15, type: 'hp', value: 50 },
          { name: 'Mana Potion', price: 15, type: 'mp', value: 10 },
          { name: 'Monster Ball', price: 50, type: 'capture' },
          { name: 'Iron Helmet', price: 80, type: 'equipment' },
          { name: 'Swift Sandals', price: 120, type: 'equipment' },
          { name: 'Power Bracers', price: 150, type: 'equipment' },
          { name: 'Obsidian Scales', price: 200, type: 'equipment' }
        ],
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.ellipse(x, y + 15, 15, 8, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#78350f'; c.fillRect(x - 18, y - 35, 10, 25);
          c.fillStyle = '#f1c40f'; c.beginPath(); c.roundRect(x - 12, y - 35, 24, 35, 5); c.fill();
          c.fillStyle = '#ffdbac'; c.beginPath(); c.arc(x, y - 40, 10, 0, Math.PI * 2); c.fill();
          c.fillStyle = 'white'; c.beginPath(); c.ellipse(x, y - 48, 12, 6, 0, 0, Math.PI*2); c.fill();
          c.fillStyle = '#f1c40f'; c.fillRect(x-2, y-55, 4, 4);
        }
      },
      { 
        id: 'healer', x: 52, y: 26, mapId: 'world', type: 'healer', color: '#10b981', 
        text: "Welcome to the adventure! I have healed your monsters to full health.",
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.ellipse(x, y + 15, 15, 8, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#10b981'; c.beginPath(); c.roundRect(x - 12, y - 40, 24, 40, 8); c.fill();
          c.fillStyle = 'white'; c.fillRect(x-8, y-30, 16, 20);
          c.fillStyle = '#ef4444'; c.fillRect(x-1, y-25, 2, 10); c.fillRect(x-5, y-21, 10, 2);
          c.fillStyle = '#ffdbac'; c.beginPath(); c.arc(x, y - 45, 10, 0, Math.PI * 2); c.fill();
          c.fillStyle = 'white'; c.beginPath(); c.moveTo(x-8, y-52); c.lineTo(x+8, y-52); c.lineTo(x, y-60); c.closePath(); c.fill();
        }
      },
      {
        id: 'boss_omnistar', x: 16, y: 56, mapId: 'world', type: 'boss', monsterKey: 'Omnistar', level: 40,
        equipment: { 'Core': 'Fire Orb' },
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.4)'; c.beginPath(); c.ellipse(x, y + 15, 20, 10, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#fde047'; c.beginPath();
          for(let i=0;i<5;i++){
            let a=(i*72-90)*Math.PI/180;
            c.lineTo(x + Math.cos(a)*25, y - 20 + Math.sin(a)*25);
            a=((i*72+36)-90)*Math.PI/180;
            c.lineTo(x + Math.cos(a)*10, y - 20 + Math.sin(a)*10);
          }
          c.closePath(); c.fill();
          c.strokeStyle = '#facc15'; c.lineWidth = 2; c.stroke();
          c.fillStyle = 'white'; c.beginPath(); c.arc(x-5, y-22, 3, 0, Math.PI * 2); c.arc(x+5, y-22, 3, 0, Math.PI * 2); c.fill();
        }
      },
      { 
        id: 'forest_chest_1', x: 24, y: 24, mapId: 'world', type: 'item',
        items: [{ name: 'Monster Ball', type: 'capture', count: 5 }],
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.ellipse(x, y + 15, 12, 6, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#78350f'; c.beginPath(); c.roundRect(x - 12, y - 10, 24, 18, 3); c.fill();
          c.fillStyle = '#a16207'; c.beginPath(); c.roundRect(x - 12, y - 10, 24, 6, 3); c.fill();
          c.fillStyle = '#facc15'; c.fillRect(x - 2, y - 6, 4, 8);
        }
      },
      {
        id: 'shrine_sage', x: 5, y: 3, mapId: 'secret_shrine', type: 'dialog', color: '#ff44ff',
        text: "You have discovered the Secret Shrine! Use the portal south to return.",
        draw: (c, x, y) => {
          c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.ellipse(x, y + 15, 15, 8, 0, 0, Math.PI * 2); c.fill();
          c.fillStyle = '#ff44ff'; c.beginPath(); c.roundRect(x - 12, y - 40, 24, 40, 8); c.fill();
          c.fillStyle = '#ffdbac'; c.beginPath(); c.arc(x, y - 45, 10, 0, Math.PI * 2); c.fill();
        }
      }
    ];
    let activeInteractionTarget = null;
    let activeBossNpc = null;
    let dialogActive = false;

    const map = [];
    const encounterMap = [];
    const MAP_DATA = {
      'world': {
        warps: [{ x: 50, y: 23, destMap: 'secret_shrine', destX: 4, destY: 8 }],
        encounters: [
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "002222222222220022222222222222222222222222220022222222222200",
      "002222222222220022222222222222222222222222220022222222222200",
      "002222002222222222222222222222222222222222222222222222222200",
      "002222002222222222222222222222222222222222222222222222222200",
      "002222002222222222222222222200222222222222222222222222222200",
      "002222002222222222222222222200222222222222222222222222222200",
      "000022000000000000000000000000000000000000000000000000000000",
      "000022000000000000000000000000000000000000000000000000000000",
      "002222222222220022222222222222222222222222222222222222222200",
      "002222222222220022222222222222222222222222222222222222222200",
      "002222222222222222222222222200222222222222220022222222222200",
      "002222222222222222222222222200222222222222220022222222222200",
      "000000000000000000000000000000000000000000220000000000000000",
      "000000000000000000000000000000000000000000220000000000000000",
      "002222002222222222222222222222222222222222220000000000000000",
      "002222002222222222222222222222222222222222220000000000000000",
      "002222222222222222222222222200222222222222220000000000000000",
      "002222222222222222222222222200222222222222220000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000            0000001111111111110011110000            00",
      "000000            0000001111111111110011110000            00",
      "000000000000      0000001100110011111111111100            00",
      "000000000000      0000001100110011111111111100            00",
      "000000000000      0000000000110011111100000000            00",
      "000000000000      0000000000110011111100000000            00",
      "000000000000      00111111001100111100111100              00",
      "000000000000      00001111001100111100111100              00",
      "000000000000      0000001100110011110011110000            00",
      "000000000000      0000001100110011110011110000            00",
      "000000000000      0000001100110011111111111100            00",
      "000000000000      0000001100110011111111111100            00",
      "000000            0000001111110011111111111100            00",
      "000000            0000001111110011111111111100            00",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "003333333333333333333333333333333333333333333333333333333300",
      "003333333333333333333333333333333333333333333333333333333300",
      "003333333333333333003333333333333333333333333333333333333300",
      "003333333333333333003333333333333333333333333333333333333300",
      "003333333333333333333333333333333333333333330033333333333300",
      "003333333333333333333333333333333333333333330033333333333300",
      "003333333333333333333333333333003333333333333333333333333300",
      "003333333333333333333333333333003333333333333333333333333300",
      "003333333333333333333333333333333333333333333333333333333300",
      "003333333333333333333333333333333333333333333333333333333300",
      "003333333300333333333333333333333333333333330033333333333300",
      "003333333300333333333333333333333333333333330033333333333300",
      "003333333333333333333333003333333333333333333333333333333300",
      "003333333333333333333333003333333333333333333333333333333300",
      "003333333333333333333333333333333333333333333333333333333300",
      "003333333333333333333333333333333333333333333333333333333300",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000"
        ],
        layout: [
"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmbb",
"bbmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmbb",
"bbmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmbb",
"bbmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmbb",
"bbmmmmbbmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmbb",
"bbmmmmbbmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmbb",
"bbbbmmbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbbbmmbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmbb",
"bbmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmbb",
"bbmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmmmbbmmmmmmmmmmbb",
"bbmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmmmbbmmmmmmmmmmbb",
"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbmmbbbbbbbbbbbbbbbb",
"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbmmbbbbbbbbbbbbbbbb",
"bbmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbbbbbbbbbbbbbbb",
"bbmmmmbbmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbbbbbbbbbbbbbbb",
"bbmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmbbbbbbbbbbbbbbbb",
"bbmmmmmmmmmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmbbbbbbbbbbbbbbbb",
"bbbbbbbbbbbbDDbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbbbbbbbbbbbDDbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"TTTTTTTTTTTTDDTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT",
"TTTTTTTTTTTTDDTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTDTTTTTTTTT",
"TTTTTT            TTTTTTffffffffffffTTffffTTTT            TT",
"TTTTTT            TTTTTTffffffffffffTTffffTTTT            TT",
"TTTTTTWWWWWW      TTTTTTffTTffTTffffffffffffTT            TT",
"TTTTTTWWWWWW      TTTTTTffTTffTTffffffffffffTT            TT",
"TTTTTTWWWWWW      TTTTTTTTTTffTTffffffTTTTTTTT            TT",
"TTTTTTWWWWWW      TTTTTTTTTTffTTffffffTTTTTTTT            TT",
"TTTTTTWWWWWW      DDffffffTTffTTffffTTffffDD              TT",
"TTTTTTWWWWWW      TTTTffffTTffTTffffTTffffDD              TT",
"TTTTTTWWWWWW      TTTTTTffTTffTTffffTTffffTTTT            TT",
"TTTTTTWWWWWW      TTTTTTffTTffTTffffTTffffTTTT            TT",
"TTTTTTWWWWWW      TTTTTTffTTffTTffffffffffffTT            TT",
"TTTTTTWWWWWW      TTTTTTffTTffTTffffffffffffTT            TT",
"TTTTTT            TTTTTTffffffTTffffffffffffTT            TT",
"TTTTTT            TTTTTTffffffTTffffffffffffTT            TT",
"TTTTTTTTTTTTDDTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT",
"TTTTTTTTTTTTDDTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT",
"bbbbbbbbbbbbDDbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbbbbbbbbbbbDDbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
"bbssssssssssssssssssssssssssssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssbbssssssssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssbbssssssssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssbbssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssbbssssssssssbb",
"bbssssssssssssssssssssssssssssssbbssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssbbssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssssssssssssssbb",
"bbssssssssbbssssssssssssssssssssssssssssssssssbbssssssssssbb",
"bbssssssssbbssssssssssssssssssssssssssssssssssbbssssssssssbb",
"bbssssssssssssssssssssssssbbssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssbbssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssssssssssssssbb",
"bbssssssssssssssssssssssssssssssssssssssssssssssssssssssssbb",
"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
      "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
        ]
      },
      'secret_shrine': {
        warps: [{ x: 4, y: 9, destMap: 'world', destX: 50, destY: 24 }],
        encounters: ["0000000000", "0000000000", "0000000000", "0000000000", "0000000000", "0000000000", "0000000000", "0000000000", "0000000000", "0000000000"],
        layout: [
          "bbbbbbbbbb",
          "b        b",
          "b  TTTT  b",
          "b  T  T  b",
          "b  T  T  b",
          "b  TTTT  b",
          "b        b",
          "b        b",
          "b        b",
          "bbbbDbbbbb"
        ]
      }
    };
    function switchMap(id, tx, ty) {
      currentMapId = id;
      initMap(id);
      player.x = tx * TILE_SIZE + TILE_SIZE / 2;
      player.y = ty * TILE_SIZE + TILE_SIZE / 2;
      player.path = [];
      player.isWalking = false;
    }
    function initMap(id) {
      const charMap = {
        'T': { type: 'tree', color: '#064e3b', traversable: false },
        ' ': { type: 'grass', color: '#2ecc71', traversable: true },
        'D': { type: 'dirt', color: '#d35400', traversable: true },
        'f': { type: 'dungeon', color: '#1b5e20', traversable: true },
        'm': { type: 'dungeon', color: '#7f8c8d', traversable: true },
        's': { type: 'dungeon', color: '#f1c40f', traversable: true },
        'W': { type: 'water', color: '#3498db', traversable: false },
        'b': { type: 'boulder', color: '#475569', traversable: false }
      };
      const data = MAP_DATA[id];
      mapHeight = data.layout.length;
      mapWidth = data.layout[0].length;
      map.length = 0;
      encounterMap.length = 0;
      for (let y = 0; y < mapHeight; y++) {
        map[y] = [];
        encounterMap[y] = [];
        const row = data.layout[y];
        const encRow = data.encounters[y];
        for (let x = 0; x < mapWidth; x++) {
          const char = row[x] || 'T';
          map[y][x] = { ...charMap[char] };
          encounterMap[y][x] = parseInt(encRow.substring(x, x+1)) || 0;
        }
      }
      NPC_LOCATIONS.filter(n => n.mapId === id).forEach(npc => {
        if (map[npc.y] && map[npc.y][npc.x]) map[npc.y][npc.x].traversable = false;
      });
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();
    initMap(currentMapId);

    function showDialog(text) {
      document.getElementById('dialogText').innerText = text;
      document.getElementById('dialog').style.display = 'block';
      dialogActive = true;
    }

    function hideDialog() {
      document.getElementById('dialog').style.display = 'none';
      document.getElementById('shop').style.display = 'none';
      dialogActive = false;
    }

    let currentShopItems = null;
    function openShop(items) {
      if (items) currentShopItems = items;
      const container = document.getElementById('shop-items');
      container.innerHTML = `<div style="padding: 5px 0 10px; font-weight: bold; color: #f1c40f; border-bottom: 1px solid #eee; margin-bottom: 10px;">Your Gold: ${playerStats.gold}G</div>`;
      currentShopItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item';
        div.innerHTML = `<span>${item.name} (${item.price}G)</span><button onclick="buyItem('${item.name}', '${item.type}', ${item.price}, ${item.value})">Buy</button>`;
        container.appendChild(div);
      });
      document.getElementById('shop').style.display = 'block';
      dialogActive = true;
    }

    function buyItem(name, type, price, val) {
      if (playerStats.gold >= price) {
        playerStats.gold -= price;
        const existing = playerStats.inventory.find(i => i.name === name);
        if (existing) {
          existing.count++;
        } else {
          playerStats.inventory.push({ name, type, val, count: 1 });
        }
        updateHud();
        openShop();
      } else {
        alert("Not enough gold!");
      }
    }

    function closeShop() {
      document.getElementById('shop').style.display = 'none';
      dialogActive = false;
    }

    function toggleMenu() {
      const m = document.getElementById('menu-modal');
      if (m.style.display === 'block') {
        m.style.display = 'none';
        dialogActive = false;
        return;
      }
      if (gameState !== 'EXPLORE' || document.getElementById('shop').style.display === 'block') return;
      m.style.display = 'block';
      showMainMenu();
      dialogActive = true;
    }

    function showMainMenu() {
      const content = document.getElementById('menu-content');
      content.innerHTML = `
        <h3 style="margin-top: 0;">Menu</h3>
        <div style="margin-bottom: 12px; font-weight: bold; font-size: 1.1em; color: #f1c40f; border-bottom: 1px solid #eee; padding-bottom: 8px;">Gold: ${playerStats.gold}G</div>
        <button class="menu-btn" onclick="showParty()">Party</button>
        <button class="menu-btn" onclick="showInventory()">Inventory</button>
        <button class="menu-btn" onclick="saveGame()">Save Game</button>
        <button class="menu-btn" onclick="toggleMenu()">Close</button>
      `;
    }

    function showParty() {
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Party</h3><div style="max-height: 260px; overflow-y: auto;">`;
      playerStats.party.forEach((p, i) => {
        html += `
          <button class="menu-btn" onclick="showMemberDetail(${i})" style="text-align: left; display: flex; align-items: center; gap: 10px;">
            <canvas id="party-icon-${i}" width="100" height="100" style="width: 40px; height: 40px; background: #333; border-radius: 4px; flex-shrink: 0;"></canvas>
            <div style="flex: 1; min-width: 0;">
              <div style="font-weight: bold;">${p.name} (Lvl ${p.lvl})</div>
              <div style="font-size: 0.8em; margin-top: 4px;">HP: ${Math.ceil(p.hp)}/${p.maxHp} | MP: ${Math.ceil(p.mp)}/${p.maxMp}</div>
            </div>
          </button>
        `;
      });
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="showMainMenu()">Back</button>`;
      content.innerHTML = html;
      playerStats.party.forEach((p, i) => {
        const c = document.getElementById(`party-icon-${i}`);
        if (c) drawMonsterIcon(c.getContext('2d'), p.name);
      });
    }

    function showMemberDetail(idx) {
      const p = playerStats.party[idx];
      const content = document.getElementById('menu-content');
      const req = getExpRequired(p.lvl, p.growth);
      const f = getMonsterFinalStats(p);
      let html = `<h3 style="margin-top: 0;">${p.name} Details</h3>
        <div style="font-size: 0.85em; line-height: 1.3; text-align: left; padding: 0 5px; max-height: 350px; overflow-y: auto;">
          <div style="margin-bottom: 4px;"><strong>Type:</strong> ${p.type} | <strong>Morphology:</strong> ${p.morphology}</div>
          <div style="margin-bottom: 4px;"><strong>Stats:</strong> HP:${Math.ceil(p.hp)} MP:${Math.ceil(p.mp)} ATK:${f.atk} DEF:${f.def} SPD:${f.spd}</div>
          <div style="margin-bottom: 4px;"><strong>Level:</strong> ${p.lvl} | <strong>XP:</strong> ${p.xp||0}/${req}</div>
          <hr style="border: 0; border-top: 1px solid #eee; margin: 8px 0;"><strong>Equipment:</strong>`;
      const slots = MORPHOLOGY_SLOTS[p.morphology] || [];
      slots.forEach(slot => {
        const equipped = p.equipment[slot];
        const type = SLOT_TO_TYPE[slot];
        html += `<div style="display:flex; justify-content:space-between; margin-top:4px; align-items:center;"><span>${slot} (${type}):</span><span style="font-weight:bold">${equipped||'Empty'}</span><div style="display:flex; gap:4px">${equipped ? `<button onclick="unequipItem(${idx}, '${slot}')" style="font-size:10px; cursor:pointer;">Rem</button>` : `<button onclick="showEquipList(${idx}, '${slot}')" style="font-size:10px; cursor:pointer;">Equip</button>`}</div></div>`;
      });
      html += `<hr style="border:0; border-top:1px solid #eee; margin:8px 0;"><strong>Skills:</strong><br> Attack (Normal)<br>${p.learnedSkills ? p.learnedSkills.map(s => ` ${s.name} (${s.type})`).join('<br>') : ''}</div><button class="menu-btn" style="margin-top:10px; color:#e74c3c; padding:8px;" onclick="releaseMonster(${idx})">Release</button><button class="menu-btn" style="padding:8px;" onclick="showParty()">Back</button>`;
      content.innerHTML = html;
    }
    function showEquipList(mIdx, slot) {
      const content = document.getElementById('menu-content');
      const targetType = SLOT_TO_TYPE[slot];
      const items = playerStats.inventory.filter(i => i.type === 'equipment' && EQUIPMENT_DB[i.name].type === targetType);
      let html = `<h3 style="margin-top: 0;">Equip ${slot}</h3><div style="max-height: 200px; overflow-y: auto;">`;
      if (items.length === 0) html += `<p>No ${targetType} in inventory.</p>`;
      else items.forEach(item => { const e = EQUIPMENT_DB[item.name]; let s = ""; if(e.stats.atk) s+=" ATK+"+e.stats.atk; if(e.stats.def) s+=" DEF+"+e.stats.def; if(e.stats.spd) s+=" SPD+"+e.stats.spd; html += `<div class="shop-item"><div style="font-size:0.8em"><strong>${item.name}</strong><br>${s}</div><button onclick="equipItem(${mIdx}, '${slot}', '${item.name}')">Use</button></div>`; });
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="showMemberDetail(${mIdx})">Back</button>`;
      content.innerHTML = html;
    }
    function equipItem(mIdx, slot, itemName) { const m = playerStats.party[mIdx]; const invIdx = playerStats.inventory.findIndex(i => i.name === itemName); if (invIdx === -1) return; if (m.equipment[slot]) unequipItem(mIdx, slot, true); m.equipment[slot] = itemName; playerStats.inventory[invIdx].count--; if (playerStats.inventory[invIdx].count <= 0) playerStats.inventory.splice(invIdx, 1); showMemberDetail(mIdx); updateHud(); }
    function unequipItem(mIdx, slot, replacing = false) { const m = playerStats.party[mIdx]; const item = m.equipment[slot]; if (!item) return; const existing = playerStats.inventory.find(i => i.name === item); if (existing) existing.count++; else playerStats.inventory.push({ name: item, type: 'equipment', count: 1 }); delete m.equipment[slot]; if (!replacing) showMemberDetail(mIdx); updateHud(); }

    function releaseMonster(idx) {
      if (playerStats.party.length <= 1) {
        alert("You cannot release your only monster!");
        return;
      }
      if (confirm(`Release ${playerStats.party[idx].name}? It will be gone forever.`)) {
        playerStats.party.splice(idx, 1);
        showParty();
        updateHud();
      }
    }

    function openBattleBag() {
      showInventory(true);
      document.getElementById('menu-modal').style.display = 'block';
      dialogActive = true;
    }
    function openSkillMenu() {
      const actor = activeActor; if (!actor || enemies.includes(actor)) return;
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Select Skill</h3><div style="max-height: 200px; overflow-y: auto;">`;
      const equipSkills = []; for (let s in actor.equipment) { const itm = EQUIPMENT_DB[actor.equipment[s]]; if (itm && itm.stats.skill) equipSkills.push(itm.stats.skill); }
      const allSkills = [...(actor.learnedSkills || []), ...equipSkills];
      if (allSkills.length === 0) html += `<p>No skills available</p>`;
      else allSkills.forEach((skill, idx) => {
        const disabled = actor.mp < skill.cost ? 'opacity: 0.5; pointer-events: none;' : '';
        html += `<button class="menu-btn" style="${disabled} text-align: left;" onclick="useSkill(${idx})"><div style="display: flex; justify-content: space-between;"><strong>${skill.name}</strong> <span>${skill.cost} MP</span></div><div style="font-size:0.75em; color: #666; margin-top: 4px;">${skill.type} | Power: x${skill.mult}</div></button>`;
      });
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="toggleMenu()">Back</button>`;
      content.innerHTML = html; document.getElementById('menu-modal').style.display = 'block'; dialogActive = true;
    }
    function useSkill(idx) {
      toggleMenu();
      battleAction('useSkill', idx);
    }

    function showInventory(isBattle = false) {
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Inventory</h3><div style="max-height: 200px; overflow-y: auto;">`;
      if (playerStats.inventory.length === 0) {
        html += `<p>Empty</p>`;
      } else {
        playerStats.inventory.forEach((item, idx) => {
          const canUse = isBattle ? ['hp', 'mp', 'capture'].includes(item.type) : ['hp', 'mp'].includes(item.type);
          html += `<div class="shop-item"><span>${item.name} (x${item.count})</span>${canUse ? `<button onclick="inventoryAction(${idx}, ${isBattle})">Use</button>` : ''}</div>`;
        });
      }
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="${isBattle ? 'toggleMenu()' : 'showMainMenu()'}">Back</button>`;
      content.innerHTML = html;
    }

    function inventoryAction(idx, isBattle) {
      if (isBattle) { battleAction('item', idx); return; }
      const item = playerStats.inventory[idx];
      if (item.type === 'hp' || item.type === 'mp') showMemberSelectForItem(idx);
    }

    function showMemberSelectForItem(itemIdx) {
      const item = playerStats.inventory[itemIdx];
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Use ${item.name}</h3><div style="max-height: 260px; overflow-y: auto;">`;
      playerStats.party.forEach((p, i) => {
        const isFainted = p.hp <= 0;
        const statLabel = item.type === 'mp' ? 'MP' : 'HP';
        const statVal = item.type === 'mp' ? Math.ceil(p.mp) : Math.ceil(p.hp);
        const statMax = item.type === 'mp' ? p.maxMp : p.maxHp;
        const style = isFainted ? 'opacity: 0.5; cursor: not-allowed;' : '';
        const click = isFainted ? '' : `applyItemToMember(${i}, ${itemIdx})`;
        html += `<button class="menu-btn" style="${style}" onclick="${click}">${p.name} (${statLabel}: ${statVal}/${statMax})${isFainted ? ' [Fainted]' : ''}</button>`;
      });
      html += `</div><button class="menu-btn" onclick="showInventory()">Back</button>`;
      content.innerHTML = html;
    }

    function applyItemToMember(mIdx, itemIdx) {
      const item = playerStats.inventory[itemIdx];
      const p = playerStats.party[mIdx];
      if (p.hp <= 0) { alert("Cannot use items on fainted monsters!"); return; }
      if (item.type === 'hp') {
        if (p.hp >= p.maxHp) { alert("HP full!"); return; }
        p.hp = Math.min(p.maxHp, p.hp + item.val);
      } else if (item.type === 'mp') {
        if (p.mp >= p.maxMp) { alert("MP full!"); return; }
        p.mp = Math.min(p.maxMp, p.mp + item.val);
      }
      item.count--;
      if (item.count <= 0) playerStats.inventory.splice(itemIdx, 1);
      showInventory();
      updateHud();
    }

    canvas.addEventListener('mousedown', (e) => {
      if (dialogActive || gameState === 'BATTLE') {
        if (dialogActive && document.getElementById('dialog').style.display === 'block') hideDialog();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const cam = getCameraOffset();
      const worldX = screenX + cam.x;
      const worldY = screenY + cam.y;
      const targetTileX = Math.floor(worldX / TILE_SIZE);
      const targetTileY = Math.floor(worldY / TILE_SIZE);
      const startTX = Math.floor(player.x / TILE_SIZE);
      const startTY = Math.floor(player.y / TILE_SIZE);
      let clickedNpc = NPC_LOCATIONS.find(n => n.mapId === currentMapId && n.x === targetTileX && n.y === targetTileY);

      if (clickedNpc) {
        const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        let bestPath = null;
        for (const [dx, dy] of neighbors) {
          const nx = clickedNpc.x + dx, ny = clickedNpc.y + dy;
          if (nx >= 0 && nx < mapWidth && ny >= 0 && ny < mapHeight && map[ny][nx].traversable) {
            const p = findPath(startTX, startTY, nx, ny);
            if (p && (!bestPath || p.length < bestPath.length)) bestPath = p;
          }
        }
        if (bestPath) {
          if (bestPath.length === 0) {
            triggerNpc(clickedNpc);
            player.path = [];
          } else {
            player.path = bestPath;
            activeInteractionTarget = clickedNpc;
          }
        }
      } else if (map[targetTileY] && map[targetTileY][targetTileX] && map[targetTileY][targetTileX].traversable) {
        const p = findPath(startTX, startTY, targetTileX, targetTileY);
        if (p) {
          player.path = p;
          activeInteractionTarget = null;
        }
      }
    });

    function getCameraOffset() {
      const pixelWidth = mapWidth * TILE_SIZE;
      const pixelHeight = mapHeight * TILE_SIZE;
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      const maxCamX = pixelWidth - canvas.width;
      const maxCamY = pixelHeight - canvas.height;
      if (pixelWidth < canvas.width) camX = (pixelWidth - canvas.width) / 2;
      else camX = Math.max(0, Math.min(camX, maxCamX));
      if (pixelHeight < canvas.height) camY = (pixelHeight - canvas.height) / 2;
      else camY = Math.max(0, Math.min(camY, maxCamY));
      return { x: camX, y: camY };
    }

    function updateHud() {
      if (playerStats.party.length === 0) return;
      const hero = playerStats.party[0];
      const hud = document.getElementById('player-hud');
      if (hud) hud.innerText = `L:${hero.lvl} HP:${Math.ceil(hero.hp)} G:${playerStats.gold} P:${playerStats.party.length}`;
    }

    function triggerNpc(npc) {
      if (npc.type === 'dialog') showDialog(npc.text);
      else if (npc.type === 'merchant') openShop(npc.items);
      else if (npc.type === 'boss') startBossBattle(npc);
      else if (npc.type === 'healer') {
        playerStats.party.forEach(p => { p.hp = p.maxHp; p.mp = p.maxMp; });
        playerStats.lastHealLocation = { x: player.x, y: player.y };
        updateHud();
        showDialog(npc.text);
      } else if (npc.type === 'item') {
        let msg = "You found: ";
        npc.items.forEach(item => {
          const existing = playerStats.inventory.find(i => i.name === item.name);
          if (existing) { existing.count += item.count; }
          else { playerStats.inventory.push({ ...item }); }
          msg += `${item.name} (x${item.count}) `;
        });
        showDialog(msg);
        if (npc.id) playerStats.defeatedNpcIds.push(npc.id);
        const idx = NPC_LOCATIONS.indexOf(npc);
        if (idx > -1) {
          if (map[npc.y] && map[npc.y][npc.x]) map[npc.y][npc.x].traversable = true;
          NPC_LOCATIONS.splice(idx, 1);
        }
        updateHud();
      }
    }

    function saveGame() {
      const saveData = {
        playerStats: playerStats,
        player: { x: player.x, y: player.y, mapId: currentMapId }
      };
      localStorage.setItem('monsterCatcherV2_Save', JSON.stringify(saveData));
      alert("Game Saved!");
      toggleMenu();
    }

    function loadGame() {
      const saved = localStorage.getItem('monsterCatcherV2_Save');
      if (!saved) return;
      const data = JSON.parse(saved);
      playerStats.party = data.playerStats.party;
      playerStats.gold = data.playerStats.gold;
      playerStats.inventory = data.playerStats.inventory;
      playerStats.lastHealLocation = data.playerStats.lastHealLocation || null;
      playerStats.defeatedNpcIds = data.playerStats.defeatedNpcIds || [];
      
      playerStats.defeatedNpcIds.forEach(id => {
        const idx = NPC_LOCATIONS.findIndex(n => n.id === id);
        if (idx !== -1) {
          const npc = NPC_LOCATIONS[idx];
          if (map[npc.y] && map[npc.y][npc.x]) map[npc.y][npc.x].traversable = true;
          NPC_LOCATIONS.splice(idx, 1);
        }
      });

      player.path = [];
      switchMap(data.player.mapId || 'world', Math.floor(data.player.x/TILE_SIZE), Math.floor(data.player.y/TILE_SIZE));
      player.x = data.player.x;
      player.y = data.player.y;
      document.getElementById('starter-screen').style.display = 'none';
      updateHud();
    }

    function update() {
      if (dialogActive || gameState === 'BATTLE') return;
      updateHud();
      if (player.path && player.path.length > 0) {
        const target = player.path[0];
        const dx = target.x - player.x;
        const dy = target.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > PLAYER_SPEED) {
          player.isWalking = true;
          player.x += (dx / dist) * PLAYER_SPEED;
          player.y += (dy / dist) * PLAYER_SPEED;
          player.animFrame += 0.15;
        } else {
          player.x = target.x;
          player.y = target.y;
          player.path.shift();
          const tx = Math.floor(player.x / TILE_SIZE);
          const ty = Math.floor(player.y / TILE_SIZE);
          const mData = MAP_DATA[currentMapId];
          const warp = mData.warps ? mData.warps.find(w => w.x === tx && w.y === ty) : null;
          if (warp) { switchMap(warp.destMap, warp.destX, warp.destY); return; }
          const zoneId = (encounterMap[ty] && encounterMap[ty][tx]) ? encounterMap[ty][tx] : 0;
          if (zoneId > 0) {
            player.stepsToEncounter--;
            if (player.stepsToEncounter <= 0) {
              player.stepsToEncounter = Math.floor(Math.random() * 16) + 15;
              player.path = [];
              startBattle(zoneId);
            }
          }
          if (player.path.length === 0) {
            player.isWalking = false;
            if (activeInteractionTarget) {
              triggerNpc(activeInteractionTarget);
              activeInteractionTarget = null;
            }
          }
        }
      } else {
        player.isWalking = false;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = getCameraOffset();

      ctx.save();
      ctx.translate(-cam.x, -cam.y);

      // Draw Tiles
      const startTileX = Math.floor(cam.x / TILE_SIZE);
      const endTileX = Math.floor((cam.x + canvas.width) / TILE_SIZE) + 1;
      const startTileY = Math.floor(cam.y / TILE_SIZE);
      const endTileY = Math.floor((cam.y + canvas.height) / TILE_SIZE) + 1;

      for (let y = Math.max(0, startTileY); y < Math.min(mapHeight, endTileY); y++) {
        for (let x = Math.max(0, startTileX); x < Math.min(mapWidth, endTileX); x++) {
          const tile = map[y][x];
          ctx.fillStyle = tile.color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          if (tile.type === 'tree') {
            const tx = x * TILE_SIZE + TILE_SIZE / 2, ty = y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillStyle = '#3f2a14'; ctx.fillRect(tx - 4, ty + 10, 8, 12);
            ctx.fillStyle = '#064e3b'; ctx.beginPath(); ctx.moveTo(tx, ty - 20); ctx.lineTo(tx - 20, ty + 10); ctx.lineTo(tx + 20, ty + 10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(tx, ty - 5); ctx.lineTo(tx - 15, ty + 15); ctx.lineTo(tx + 15, ty + 15); ctx.fill();
          } else if (tile.type === 'boulder') {
            const tx = x * TILE_SIZE + TILE_SIZE / 2, ty = y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillStyle = '#475569'; ctx.beginPath(); ctx.arc(tx, ty, 18, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#64748b'; ctx.beginPath(); ctx.arc(tx - 5, ty - 5, 5, 0, Math.PI * 2); ctx.fill();
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw NPCs
      NPC_LOCATIONS.filter(n => n.mapId === currentMapId).forEach(n => {
        const nx = n.x * TILE_SIZE + TILE_SIZE / 2;
        const ny = n.y * TILE_SIZE + TILE_SIZE / 2;
        if (n.draw) n.draw(ctx, nx, ny);
      });

      // Draw Player Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 15, 15, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Draw Player (Body)
      const bob = player.isWalking ? Math.abs(Math.sin(player.animFrame)) * 8 : 0;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.roundRect(player.x - 15, player.y - 45 - bob, 30, 45, 10);
      ctx.fill();
      
      // Draw Head
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(player.x, player.y - 50 - bob, 12, 0, Math.PI * 2);
      ctx.fill();

      // Draw Feet (Walking animation)
      if (player.isWalking) {
        const legMove = Math.sin(player.animFrame) * 10;
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5 + legMove, 8, 5);  // Left foot
        ctx.fillRect(player.x + 4, player.y - 5 - legMove, 8, 5);   // Right foot
      } else {
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5, 8, 5);
        ctx.fillRect(player.x + 4, player.y - 5, 8, 5);
      }

      ctx.restore();

      requestAnimationFrame(() => {
        update();
        draw();
      });
    }

    function startBattle(zoneId) {
      const zone = ENCOUNTER_ZONES[zoneId];
      if (!zone) return;
      player.isWalking = false; player.path = [];
      document.getElementById('flash-overlay').classList.add('flashing');
      setTimeout(() => document.getElementById('flash-overlay').classList.remove('flashing'), 500);
      gameState = 'BATTLE';
      const totalWeight = zone.encounters.reduce((s, e) => s + e.weight, 0);
      let rand = Math.random() * totalWeight;
      let encounter = zone.encounters[0];
      for (const e of zone.encounters) {
        if (rand < e.weight) { encounter = e; break; }
        rand -= e.weight;
      }
      enemies = encounter.enemies.map(inst => {
        const lvl = Array.isArray(inst.lvl) ? Math.floor(Math.random()*(inst.lvl[1]-inst.lvl[0]+1)) + inst.lvl[0] : inst.lvl;
        const m = createMonster(inst.key, lvl, true);
        if (inst.equipment) m.equipment = { ...m.equipment, ...inst.equipment };
        m.ap = 0; return m;
      });
      playerStats.party.forEach(p => p.ap = 0);
      activeActor = null; pendingAction = null; pendingSkillIdx = null;
      document.getElementById('battle-screen').style.display = 'flex';
      nextTurn(`Wild monsters appeared in the ${zone.name}!`);
    }

    function startBossBattle(npc) {
      activeBossNpc = npc;
      player.isWalking = false; player.path = [];
      document.getElementById('flash-overlay').classList.add('flashing');
      setTimeout(() => document.getElementById('flash-overlay').classList.remove('flashing'), 500);
      gameState = 'BATTLE';
      let m = createMonster(npc.monsterKey, npc.level, false);
      if (npc.equipment) m.equipment = JSON.parse(JSON.stringify(npc.equipment));
      enemies = [m];
      playerStats.party.forEach(p => p.ap = 0);
      activeActor = null; pendingAction = null; pendingSkillIdx = null;
      document.getElementById('battle-screen').style.display = 'flex';
      nextTurn(`The legendary ${npc.monsterKey} appeared!`);
    }

    function updateBattleUI(msg) {
      const partyList = document.getElementById('party-list');
      const enemyList = document.getElementById('enemy-list');
      if (!partyList || !enemyList) return;
      const updateContainer = (container, monsters, isEnemy) => {
        if (container.children.length !== monsters.length) container.innerHTML = '';
        monsters.forEach((m, i) => {
          let card = container.children[i];
          if (!card) {
            card = document.createElement('div');
            card.className = 'battle-card';
            if (isEnemy) { card.style.flexDirection = 'row-reverse'; card.style.textAlign = 'right'; }
            card.innerHTML = `<canvas class="battle-card-canvas" width="100" height="100"></canvas><div style="flex:1; min-width:0;"><div class="card-name" style="font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;"></div><div class="bar-container" style="${isEnemy?'margin-left:auto':''}"><div class="bar-fill hp-fill"></div><div class="bar-text hp-txt"></div></div><div class="bar-container" style="${isEnemy?'margin-left:auto':''}"><div class="bar-fill mp-fill"></div><div class="bar-text mp-txt"></div></div>${!isEnemy?'<div class="bar-container" style="height:1px; border:none; background:rgba(255,255,255,0.1); margin-top:2px;"><div class="bar-fill xp-fill"></div></div>':''}</div>`;
            container.appendChild(card);
          }
          const isSelectable = (isEnemy && (pendingAction === 'attack' || pendingAction === 'useSkill' || pendingAction === 'itemEnemy') && m.hp > 0) || (!isEnemy && pendingAction === 'itemParty' && m.hp > 0);
          card.onclick = isSelectable ? () => selectTarget(i) : null;
          card.style.cursor = isSelectable ? 'pointer' : 'default';
          card.style.opacity = m.hp <= 0 ? '0.4' : '1';
          if (isSelectable) card.style.boxShadow = 'inset 0 0 10px #ffeb3b';
          else card.style.boxShadow = 'none';
          card.className = 'battle-card' + (m === activeActor ? ' active-actor' : '');
          card.querySelector('.card-name').innerHTML = `${m.name} <span style="font-size:0.7em">L${m.lvl}</span>`;
          card.querySelector('.hp-fill').style.width = (m.hp/m.maxHp*100) + '%';
          card.querySelector('.hp-txt').innerText = `HP ${Math.ceil(m.hp)}/${m.maxHp}`;
          card.querySelector('.mp-fill').style.width = (m.mp/m.maxMp*100) + '%';
          card.querySelector('.mp-txt').innerText = `MP ${Math.ceil(m.mp)}/${m.maxMp}`;
          if (!isEnemy) {
            const curReq = getExpRequired(m.lvl, m.growth), prevReq = m.lvl > 1 ? getExpRequired(m.lvl - 1, m.growth) : 0;
            card.querySelector('.xp-fill').style.width = Math.max(0, Math.min(100, ((m.xp-prevReq)/(curReq-prevReq))*100)) + '%';
          }
          drawMonsterIcon(card.querySelector('canvas').getContext('2d'), m.name);
        });
      };
      updateContainer(partyList, playerStats.party, false);
      updateContainer(enemyList, enemies, true);
      document.getElementById('acting-name').innerText = activeActor ? `Turn: ${activeActor.name}` : "";
      if (msg) document.getElementById('battle-msg').innerText = msg;
    }

    function drawMonsterIcon(mCtx, name) {
      mCtx.clearRect(0, 0, 100, 100);
      const monster = MONSTER_DB[name];
      if (!monster || !monster.draw) return;
      mCtx.save();
      mCtx.translate(50, 75);
      monster.draw(mCtx);
      mCtx.restore();
    }

    function nextTurn(msg) {
      if (gameState !== 'BATTLE') return;
      pendingAction = null; pendingSkillIdx = null;
      const combatants = [...playerStats.party.filter(p => p.hp > 0), ...enemies.filter(e => e.hp > 0)];
      while (true) {
        combatants.sort((a, b) => b.ap - a.ap);
        if (combatants.length === 0) return;
        if (combatants[0].ap >= 100) {
          activeActor = combatants[0];
          updateBattleUI(msg);
          if (enemies.includes(activeActor)) setTimeout(enemyTurn, 800);
          else battleBusy = false;
          return;
        }
        for (let c of combatants) c.ap = (c.ap || 0) + c.spd;
      }
    }

    function enemyTurn() {
      if (gameState !== 'BATTLE' || activeActor.hp <= 0) return;
      const targets = playerStats.party.filter(p => p.hp > 0);
      if (targets.length === 0) return;
      const equipSkills = []; for (let s in activeActor.equipment) { const itm = EQUIPMENT_DB[activeActor.equipment[s]]; if (itm && itm.stats.skill) equipSkills.push(itm.stats.skill); }
      const allSkills = [...(activeActor.learnedSkills || []), ...equipSkills];
      const usableSkills = allSkills.filter(s => activeActor.mp >= s.cost);
      let target = targets[Math.floor(Math.random() * targets.length)];
      let skillToUse = usableSkills.length > 0 ? usableSkills[Math.floor(Math.random() * usableSkills.length)] : null;
      let dmg = 0, txt = "";
      if (skillToUse) { activeActor.mp -= skillToUse.cost; dmg = calculateSkillDamage(activeActor, target, skillToUse); txt = `${activeActor.name} uses ${skillToUse.name}! ${dmg} dmg.`; }
      else { const a = getMonsterFinalStats(activeActor), d = getMonsterFinalStats(target); dmg = Math.max(1, (a.atk + Math.floor(Math.random() * 5)) - d.def); txt = `${activeActor.name} attacks! ${dmg} dmg.`; }
      target.hp = Math.max(0, target.hp - dmg); updateBattleUI(txt);
      if (playerStats.party.every(p => p.hp <= 0)) { setTimeout(handleDefeat, 800); return; }
      activeActor.ap -= 100; setTimeout(nextTurn, 800);
    }

    function selectTarget(idx) {
      if (battleBusy || !pendingAction) return;
      executeBattleAction(pendingAction, idx, pendingSkillIdx);
    }

    function battleAction(type, data = null) {
      if (battleBusy || !activeActor || enemies.includes(activeActor)) return;
      if (type === 'skill') { openSkillMenu(); return; }
      if (type === 'flee') {
        battleBusy = true;
        if (Math.random() > 0.4) { endBattle("You escaped!"); return; }
        updateBattleUI("Flee failed! ");
        activeActor.ap -= 100; setTimeout(nextTurn, 600);
        return;
      }
      const aliveEnemies = enemies.filter(e => e.hp > 0);
      if (type === 'attack' || type === 'useSkill') {
        if (aliveEnemies.length > 1) {
          pendingAction = type; pendingSkillIdx = data;
          updateBattleUI("Select a target monster.");
          return;
        }
        executeBattleAction(type, enemies.indexOf(aliveEnemies[0]), data);
      } else if (type === 'item') {
        const item = playerStats.inventory[data];
        if (item.type === 'capture') {
          if (aliveEnemies.length > 1) {
            pendingAction = 'itemEnemy'; pendingSkillIdx = data;
            updateBattleUI("Select target to capture.");
            toggleMenu(); return;
          }
          executeBattleAction('itemEnemy', enemies.indexOf(aliveEnemies[0]), data);
        } else {
          pendingAction = 'itemParty'; pendingSkillIdx = data;
          updateBattleUI("Select monster to heal.");
          toggleMenu();
        }
      }
    }

    function executeBattleAction(type, targetIdx, data) {
      battleBusy = true; pendingAction = null; let msg = "";
      if (type === 'attack') {
        const target = enemies[targetIdx];
        const a = getMonsterFinalStats(activeActor), d = getMonsterFinalStats(target);
        const dmg = Math.max(1, (a.atk + Math.floor(Math.random() * 5)) - d.def);
        target.hp = Math.max(0, target.hp - dmg); msg = `${activeActor.name} hit for ${dmg}! `;
        if (target.hp <= 0) { gainXp(target.rewardXp); msg += `${target.name} defeated! `; }
      } else if (type === 'useSkill') {
        const target = enemies[targetIdx];
        const equipSkills = []; for (let s in activeActor.equipment) { const itm = EQUIPMENT_DB[activeActor.equipment[s]]; if (itm && itm.stats.skill) equipSkills.push(itm.stats.skill); }
        const skill = [...(activeActor.learnedSkills || []), ...equipSkills][data];
        activeActor.mp -= skill.cost; const dmg = calculateSkillDamage(activeActor, target, skill);
        target.hp = Math.max(0, target.hp - dmg); if (skill.heal) activeActor.hp = Math.min(activeActor.maxHp, activeActor.hp + skill.heal);
        msg = `${activeActor.name} used ${skill.name}! `;
        if (target.hp <= 0) { gainXp(target.rewardXp); msg += `${target.name} defeated! `; }
      } else if (type === 'itemEnemy' || type === 'itemParty') {
        const item = playerStats.inventory[data];
        const itmTarget = type === 'itemEnemy' ? enemies[targetIdx] : playerStats.party[targetIdx];
        if (item.type === 'capture') {
          if (playerStats.party.length >= 4) { alert("Party full!"); toggleMenu(); battleBusy = false; return; }
          const capRate = itmTarget.captureRate || 0.5;
          const chance = ((3 * itmTarget.maxHp - 2 * itmTarget.hp) / (3 * itmTarget.maxHp)) * capRate;
          item.count--; if (item.count <= 0) playerStats.inventory.splice(data, 1);
          toggleMenu();
          if (Math.random() < chance) {
            playerStats.party.push(JSON.parse(JSON.stringify(itmTarget))); itmTarget.hp = 0;
            msg = `Captured ${itmTarget.name}! `; gainXp(itmTarget.rewardXp);
          } else msg = "Capture failed! ";
        } else {
          if (item.type === 'hp') itmTarget.hp = Math.min(itmTarget.maxHp, itmTarget.hp + item.val);
          if (item.type === 'mp') itmTarget.mp = Math.min(itmTarget.maxMp, itmTarget.mp + item.val);
          item.count--; if (item.count <= 0) playerStats.inventory.splice(data, 1);
          toggleMenu(); msg = `${item.name} used on ${itmTarget.name}! `;
        }
      }
      updateBattleUI(msg);
      if (enemies.every(e => e.hp <= 0)) {
        let totalGold = 0; enemies.forEach(e => { totalGold += e.gold; });
        playerStats.gold += totalGold; endBattle(`Victorious! +${totalGold}G`);
      } else {
        activeActor.ap -= 100; setTimeout(nextTurn, 600);
      }
    }

    function gainXp(amt) {
      playerStats.party.forEach(member => {
        if (member.hp <= 0) return;
        member.xp = (member.xp || 0) + amt;
        let req = getExpRequired(member.lvl, member.growth);
        while (member.xp >= req) {
          member.lvl++;
          member.maxHp += 15; member.hp = member.maxHp;
          member.maxMp += 5; member.mp = member.maxMp;
          member.atk += 3; member.spd += 2;
          const t = MONSTER_DB[member.name];
          if (t && t.skills) {
            const newOnes = t.skills.filter(s => s.lvl === member.lvl);
            newOnes.forEach(ns => {
              if (!member.learnedSkills) member.learnedSkills = [];
              member.learnedSkills.push(ns);
              alert(`${member.name} learned ${ns.name}!`);
            });
            if (member.learnedSkills && member.learnedSkills.length > 0) {
              member.skill = member.learnedSkills[member.learnedSkills.length - 1];
            }
          }
          req = getExpRequired(member.lvl, member.growth);
        }
      });
    }

    function endBattle(msg) {
      updateBattleUI(msg);
      setTimeout(() => {
        if (activeBossNpc && enemies.every(e => e.hp <= 0)) {
          const idx = NPC_LOCATIONS.indexOf(activeBossNpc);
          if (idx > -1) {
            if (activeBossNpc.id) playerStats.defeatedNpcIds.push(activeBossNpc.id);
            map[activeBossNpc.y][activeBossNpc.x].traversable = true;
            NPC_LOCATIONS.splice(idx, 1);
          }
        }
        activeBossNpc = null;
        document.getElementById('battle-screen').style.display = 'none';
        gameState = 'EXPLORE';
        battleBusy = false;
        enemies = [];
      }, 1500);
    }

    function handleDefeat() {
      alert("All your monsters have fainted! You lost some gold and rushed back to safety...");
      playerStats.gold = Math.floor(playerStats.gold * 0.9);
      playerStats.party.forEach(p => { p.hp = p.maxHp; p.mp = p.maxMp; });
      activeBossNpc = null;
      const respawn = playerStats.lastHealLocation || { x: 52 * TILE_SIZE + 32, y: 30 * TILE_SIZE + 32 };
      player.x = respawn.x;
      player.y = respawn.y;
      player.path = [];
      document.getElementById('battle-screen').style.display = 'none';
      gameState = 'EXPLORE';
      battleBusy = false;
      updateHud();
    }

    function initStarterScreen() {
      const screen = document.getElementById('starter-screen');
      const container = screen.querySelector('.starter-cards');
      const savedData = localStorage.getItem('monsterCatcherV2_Save');
      if (savedData) {
        const btn = document.createElement('button');
        btn.className = 'menu-btn';
        btn.style.width = '240px';
        btn.style.marginBottom = '20px';
        btn.style.pointerEvents = 'auto';
        btn.innerText = 'Continue Last Save';
        btn.onclick = loadGame;
        screen.insertBefore(btn, container);
      }
      STARTERS.forEach((s, i) => {
        const card = document.createElement('div');
        card.className = 'starter-card';
        card.onclick = () => selectStarter(i);
        card.innerHTML = `<canvas id="starter-canvas-${i}" width="100" height="100" style="width:80px; height:80px;"></canvas><h3>${s.name}</h3><div class="stats">Type: ${s.type}<br>HP: ${s.maxHp}<br>ATK: ${s.atk}<br>SPD: ${s.spd}<br>MP: ${s.maxMp}<br>Skill: ${s.skill.name}</div><button class="menu-btn" style="pointer-events:none">Select</button>`;
        container.appendChild(card);
        drawMonsterIcon(document.getElementById(`starter-canvas-${i}`).getContext('2d'), s.name);
      });
    }
    function selectStarter(idx) {
      playerStats.party = [JSON.parse(JSON.stringify(STARTERS[idx]))];
      playerStats.lastHealLocation = null;
      document.getElementById('starter-screen').style.display = 'none';
      updateHud();
    }
    initStarterScreen();
    draw();
  </script>
</body>
</html>