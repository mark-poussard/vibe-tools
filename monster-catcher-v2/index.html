<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rpg-game</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      image-rendering: pixelated;
      border: 4px solid #444;
      cursor: pointer;
    }
    #ui {
      position: absolute; top: 0; left: 0; right: 0; color: white; font-family: monospace;
      pointer-events: none; background: rgba(0,0,0,0.6); padding: 8px 12px; font-size: 11px;
      display: flex; justify-content: space-between; align-items: center; z-index: 150;
    }
    #dialog {
      display: none; position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
      background: white; padding: 20px; border: 4px solid #444; font-family: monospace;
      width: 90%; max-width: 400px; box-sizing: border-box; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 100;
    }
    #shop, #menu-modal {
      display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border: 4px solid #444; font-family: monospace;
      width: 90%; max-width: 320px; box-sizing: border-box; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 250;
    }
    .menu-btn { width: 100%; padding: 12px; margin: 5px 0; cursor: pointer; background: #eee; border: 1px solid #ccc; font-family: monospace; font-size: 14px; }
    .menu-btn:hover { background: #ddd; }
    .shop-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #eee; }
    .shop-item button { cursor: pointer; padding: 8px 12px; background: #4caf50; color: white; border: none; }
    #battle-screen {
      display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: #111; color: white; flex-direction: column; align-items: center; justify-content: center;
      font-family: monospace; z-index: 200; padding: 15px; box-sizing: border-box;
    }
    .battle-stats { display: flex; gap: 10px; margin-bottom: 10px; font-size: 0.9em; width: 100%; flex: 1; min-height: 0; overflow-y: auto; }
    .battle-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; width: 100%; max-width: 400px; margin-top: auto; }
    .battle-actions button { padding: 12px; font-size: 1em; cursor: pointer; background: #444; color: white; border: 2px solid #888; flex: 1 1 120px; }
    .battle-actions button:hover { background: #666; }
    #battle-msg { font-size: 1.1em; color: #ffeb3b; text-align: center; margin: 10px 0; min-height: 1.5em; }
    #flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 300; }
    @keyframes flash-anim { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
    .flashing { animation: flash-anim 0.5s ease-out; }
    .dungeon-info { color: #ff66ff; font-weight: bold; }
    .bar-container { width: 100px; height: 14px; background: #333; border: 1px solid #555; margin: 4px 0; position: relative; border-radius: 2px; overflow: hidden; }
    .bar-fill { height: 100%; width: 100%; transition: width 0.3s ease; }
    .bar-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; font-size: 9px; line-height: 14px; text-align: center; color: white; text-shadow: 1px 1px 1px black; font-weight: bold; pointer-events: none; }
    .hp-fill { background: #4caf50; } .mp-fill { background: #2196f3; }
    .battle-card { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; padding: 6px; font-size: 0.75em; border: 2px solid transparent; background: rgba(255,255,255,0.05); border-radius: 4px; width: 100%; box-sizing: border-box; }
    .active-actor { border-color: #ffeb3b; background: rgba(255,235,59,0.1); }
    .battle-card-canvas { background: #222; border: 1px solid #444; border-radius: 50%; width: 50px; height: 50px; flex-shrink: 0; }
    #starter-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #222; z-index: 500;
      display: flex; flex-direction: column; align-items: center; justify-content: center; color: white;
      font-family: monospace; overflow-y: auto; padding: 20px; box-sizing: border-box;
    }
    #starter-screen h1 { font-size: 1.5em; text-align: center; margin: 10px 0; }
    .starter-cards { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; justify-content: center; width: 100%; }
    .starter-card { background: #333; border: 4px solid #555; padding: 15px; width: 140px; text-align: center; cursor: pointer; transition: transform 0.2s, border-color 0.2s; }
    .starter-card:hover { transform: scale(1.05); border-color: #ffeb3b; }
    .starter-card h3 { margin: 8px 0; color: #ffeb3b; font-size: 1em; }
    .starter-card .stats { font-size: 0.75em; text-align: left; margin: 8px 0; line-height: 1.3; }
  </style>
</head>
<body>
  <div id="starter-screen">
    <h1>Choose Your Starter Monster</h1>
    <div class="starter-cards"></div>
  </div>
  <div id="ui">
    <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; margin-right: 10px;">
      <span class="dungeon-info">Green=Forest | Blue=Lake | Gray=Mtn | Yellow=Desert</span> | <span id="player-hud"></span>
    </div>
    <button onclick="toggleMenu()" style="pointer-events: auto; padding: 4px 12px; cursor: pointer; background: #444; color: white; border: 1px solid #888; font-family: monospace;">Menu</button>
  </div>
  <div id="flash-overlay"></div>
  <div id="battle-screen">
    <div class="battle-stats">
      <div style="flex: 1; display: flex; flex-direction: column; border-right: 1px solid #333; padding-right: 8px; min-width: 0;">
        <div style="font-weight: bold; border-bottom: 1px solid #555; margin-bottom: 5px; font-size: 0.8em;">PARTY</div>
        <div id="party-list"></div>
      </div>
      <div style="flex: 1; display: flex; flex-direction: column; padding-left: 8px; align-items: flex-end; min-width: 0;">
        <div style="font-weight: bold; border-bottom: 1px solid #555; margin-bottom: 5px; width: 100%; text-align: right; font-size: 0.8em;">ENEMIES</div>
        <div id="enemy-list"></div>
      </div>
    </div>
    <div id="acting-name" style="color: #4caf50; font-weight: bold; margin: 8px 0; text-align: center; font-size: 0.9em;"></div>
    <div id="battle-msg">A wild monster appears!</div>
    <div class="battle-actions">
      <button onclick="battleAction('attack')">Attack</button>
      <button onclick="battleAction('skill')">Skill</button>
      <button onclick="openBattleBag()">Bag</button>
      <button onclick="battleAction('flee')">Flee</button>
    </div>
  </div>
  <div id="dialog">
    <div id="dialogText"></div>
    <div style="margin-top: 10px; font-size: 0.8em; color: #666; text-align: right;">Click anywhere to close</div>
  </div>
  <div id="shop">
    <h3 style="margin: 0 0 10px 0;">Village Shop</h3>
    <div id="shop-items"></div>
    <button onclick="closeShop()" style="margin-top: 15px; width: 100%; cursor: pointer;">Exit Shop</button>
  </div>
  <div id="menu-modal">
    <div id="menu-content"></div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Config
    const TILE_SIZE = 64;
    const MAP_SIZE_TILES = 30;
    const MAP_PIXEL_SIZE = MAP_SIZE_TILES * TILE_SIZE;
    const PLAYER_SPEED = 4;
    
    // State
    let gameState = 'EXPLORE'; // EXPLORE, BATTLE
    const player = {
      x: 26 * TILE_SIZE + 32,
      y: 15 * TILE_SIZE + 32,
      path: [],
      size: 40,
      isWalking: false,
      animFrame: 0
    };

    function findPath(startTX, startTY, endTX, endTY) {
      if (startTX === endTX && startTY === endTY) return [];
      const queue = [[startTX, startTY, []]];
      const visited = new Set([`${startTX},${startTY}`]);
      while (queue.length > 0) {
        const [cx, cy, path] = queue.shift();
        const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dx, dy] of neighbors) {
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && nx < MAP_SIZE_TILES && ny >= 0 && ny < MAP_SIZE_TILES && map[ny][nx].traversable && !visited.has(`${nx},${ny}`)) {
            const newPath = [...path, { x: nx * TILE_SIZE + TILE_SIZE / 2, y: ny * TILE_SIZE + TILE_SIZE / 2 }];
            if (nx === endTX && ny === endTY) return newPath;
            visited.add(`${nx},${ny}`);
            queue.push([nx, ny, newPath]);
          }
        }
      }
      return null;
    }

    const playerStats = {
      party: [],
      gold: 50, inventory: []
    };
    const TYPE_CHART = {
      'Fire': { weakTo: ['Water', 'Earth'], resist: ['Nature', 'Fire'] },
      'Water': { weakTo: ['Nature', 'Electric'], resist: ['Fire', 'Water'] },
      'Nature': { weakTo: ['Fire', 'Air'], resist: ['Water', 'Nature', 'Earth'] },
      'Dark': { weakTo: ['Holy'], resist: ['Dark', 'Psionic'] },
      'Holy': { weakTo: ['Dark'], resist: ['Holy'] },
      'Normal': { weakTo: [], resist: [] },
      'Earth': { weakTo: ['Nature', 'Water'], resist: ['Fire', 'Electric', 'Earth'] },
      'Electric': { weakTo: ['Earth'], resist: ['Air', 'Electric'] },
      'Air': { weakTo: ['Electric'], resist: ['Earth', 'Nature'] },
      'Psionic': { weakTo: ['Dark', 'Cyber'], resist: ['Normal', 'Psionic'] },
      'Cyber': { weakTo: ['Electric', 'Kaiju'], resist: ['Psionic', 'Air'] },
      'Aether': { weakTo: ['Aether'], resist: ['Fire', 'Water', 'Nature', 'Earth', 'Electric', 'Air', 'Dark', 'Holy', 'Normal', 'Psionic', 'Cyber', 'Kaiju'] },
      'Kaiju': { weakTo: ['Aether', 'Psionic'], resist: ['Fire', 'Water', 'Earth', 'Normal'] }
    };
    const MONSTER_DB = {
      'Leafy': { hp: 45, mp: 10, atk: 7, spd: 10, type: 'Nature', draw: (c) => { c.fillStyle = '#84cc16'; c.beginPath(); c.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#4d7c0f'; c.beginPath(); c.moveTo(0, -15); c.quadraticCurveTo(15, -35, 0, -45); c.quadraticCurveTo(-15, -35, 0, -15); c.fill(); }, skills: [{ name: 'Leaf Blade', lvl: 1, cost: 0, mult: 1.3, type: 'Nature' }] },
      'Sprout': { hp: 42, mp: 15, atk: 6, spd: 12, type: 'Nature', draw: (c) => { c.fillStyle = '#a3e635'; c.beginPath(); c.arc(0, 0, 15, 0, Math.PI*2); c.fill(); c.fillStyle = '#3f6212'; c.beginPath(); c.moveTo(0,-15); c.lineTo(8,-22); c.moveTo(0,-15); c.lineTo(-8,-22); c.stroke(); }, skills: [{ name: 'Vine Whip', lvl: 1, cost: 0, mult: 1.2, type: 'Nature' }] },
      'Cliff-Ram': { hp: 100, mp: 20, atk: 18, spd: 15, type: 'Earth', draw: (c) => { c.fillStyle = '#94a3b8'; c.beginPath(); c.roundRect(-25, -35, 50, 35, 8); c.fill(); c.strokeStyle = 'white'; c.lineWidth = 4; c.beginPath(); c.moveTo(-15,-35); c.quadraticCurveTo(-25,-55, -35, -35); c.moveTo(15,-35); c.quadraticCurveTo(25,-55, 35, -35); c.stroke(); }, skills: [{ name: 'Headbutt', lvl: 1, cost: 5, mult: 1.5, type: 'Earth' }] },
      'Sky-Shredder': { hp: 85, mp: 30, atk: 22, spd: 28, type: 'Air', draw: (c) => { c.fillStyle = '#38bdf8'; c.beginPath(); c.ellipse(0, -20, 25, 15, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#ef4444'; c.beginPath(); c.moveTo(-25,-20); c.lineTo(-45, -35); c.lineTo(-25, -10); c.fill(); c.beginPath(); c.moveTo(25,-20); c.lineTo(45, -35); c.lineTo(25, -10); c.fill(); }, skills: [{ name: 'Aerial Ace', lvl: 1, cost: 8, mult: 1.6, type: 'Air' }] },
      'Sand-Stinger': { hp: 140, mp: 40, atk: 30, spd: 20, type: 'Dark', draw: (c) => { c.fillStyle = '#9333ea'; c.beginPath(); c.ellipse(0, 0, 20, 12, 0, 0, Math.PI*2); c.fill(); c.strokeStyle = '#9333ea'; c.lineWidth = 5; c.beginPath(); c.moveTo(0,-10); c.quadraticCurveTo(30, -50, 10, -60); c.stroke(); }, skills: [{ name: 'Poison Jab', lvl: 1, cost: 10, mult: 1.8, type: 'Dark' }] },
      'Sun-Cactus': { hp: 160, mp: 50, atk: 26, spd: 12, type: 'Fire', draw: (c) => { c.fillStyle = '#166534'; c.beginPath(); c.roundRect(-15, -50, 30, 50, 10); c.fill(); c.fillStyle = '#fde047'; c.beginPath(); c.arc(0, -55, 8, 0, Math.PI*2); c.fill(); }, skills: [{ name: 'Needle Blast', lvl: 1, cost: 12, mult: 2.0, type: 'Fire' }] },
      'Rabbite': { hp: 35, mp: 5, atk: 5, spd: 8, type: 'Normal', draw: (c) => { c.fillStyle = 'white'; c.beginPath(); c.arc(0, -15, 20, 0, Math.PI*2); c.fill(); c.beginPath(); c.ellipse(-8, -40, 6, 15, -0.1, 0, Math.PI*2); c.fill(); c.beginPath(); c.ellipse(8, -40, 6, 15, 0.1, 0, Math.PI*2); c.fill(); }, skills: [{ name: 'Bite', lvl: 1, cost: 0, mult: 1.2, type: 'Normal' }] },
      'Birby': { hp: 30, mp: 5, atk: 4, spd: 12, type: 'Normal', draw: (c) => { c.fillStyle = '#facc15'; c.beginPath(); c.arc(0, -15, 18, 0, Math.PI*2); c.fill(); c.fillStyle = '#f97316'; c.beginPath(); c.moveTo(10, -15); c.lineTo(22, -12); c.lineTo(10, -9); c.fill(); }, skills: [{ name: 'Peck', lvl: 1, cost: 0, mult: 1.1, type: 'Normal' }] },
      'Cattus': { hp: 40, mp: 8, atk: 6, spd: 10, type: 'Normal', draw: (c) => { c.fillStyle = '#fb923c'; c.beginPath(); c.arc(0, -20, 22, 0, Math.PI*2); c.fill(); c.beginPath(); c.moveTo(-18,-35); c.lineTo(-10,-45); c.lineTo(-2,-35); c.fill(); c.beginPath(); c.moveTo(18,-35); c.lineTo(10,-45); c.lineTo(2,-35); c.fill(); }, skills: [{ name: 'Scratch', lvl: 1, cost: 0, mult: 1.3, type: 'Normal' }] },
      'Terramole': { hp: 120, mp: 20, atk: 12, spd: 6, type: 'Earth', draw: (c) => { c.fillStyle = '#78350f'; c.beginPath(); c.ellipse(0, -15, 25, 20, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#451a03'; c.beginPath(); c.moveTo(-20, 0); c.lineTo(-30, -10); c.lineTo(-20, -5); c.fill(); c.beginPath(); c.moveTo(20, 0); c.lineTo(30, -10); c.lineTo(20, -5); c.fill(); }, skills: [ { name: 'Mud Slap', lvl: 1, cost: 5, mult: 1.4, type: 'Earth' }, { name: 'Earthquake', lvl: 12, cost: 18, mult: 2.8, type: 'Earth' } ]},
      'Rockogolem': { hp: 150, mp: 15, atk: 15, spd: 4, type: 'Earth', draw: (c) => { c.fillStyle = '#475569'; c.fillRect(-25, -25, 50, 25); c.fillRect(-15, -50, 30, 25); c.fillStyle = '#06b6d4'; c.beginPath(); c.arc(-8, -38, 3, 0, Math.PI*2); c.fill(); c.arc(8, -38, 3, 0, Math.PI*2); c.fill(); }, skills: [ { name: 'Rock Throw', lvl: 1, cost: 6, mult: 1.6, type: 'Earth' }, { name: 'Stone Smash', lvl: 14, cost: 22, mult: 3.2, type: 'Earth' } ]},
      'Sparkat': { hp: 80, mp: 30, atk: 14, spd: 22, type: 'Electric', draw: (c) => { c.fillStyle = '#eab308'; c.beginPath(); c.arc(0, -20, 20, 0, Math.PI*2); c.fill(); c.strokeStyle = '#eab308'; c.lineWidth = 4; c.beginPath(); c.moveTo(0,0); c.lineTo(-10, 15); c.lineTo(5, 10); c.lineTo(0, 25); c.stroke(); }, skills: [ { name: 'Zapping Claw', lvl: 1, cost: 8, mult: 1.5, type: 'Electric' }, { name: 'Thunder Bolt', lvl: 15, cost: 25, mult: 3.5, type: 'Electric' } ]},
      'Voltix': { hp: 70, mp: 45, atk: 10, spd: 18, type: 'Electric', draw: (c) => { c.fillStyle = '#60a5fa'; c.beginPath(); c.arc(0, -30, 20, 0, Math.PI*2); c.fill(); c.strokeStyle = 'white'; c.beginPath(); for(let i=0; i<8; i++) { let a = i*Math.PI/4; c.moveTo(0,-30); c.lineTo(Math.cos(a)*35, -30+Math.sin(a)*35); } c.stroke(); }, skills: [ { name: 'Static Shock', lvl: 1, cost: 5, mult: 1.3, type: 'Electric' }, { name: 'Overload', lvl: 16, cost: 30, mult: 4.2, type: 'Electric' } ]},
      'Zephyros': { hp: 85, mp: 35, atk: 12, spd: 25, type: 'Air', draw: (c) => { c.fillStyle = 'white'; c.beginPath(); c.arc(-15, -20, 15, 0, Math.PI*2); c.arc(15, -20, 15, 0, Math.PI*2); c.arc(0, -35, 20, 0, Math.PI*2); c.fill(); }, skills: [ { name: 'Air Slash', lvl: 1, cost: 7, mult: 1.4, type: 'Air' }, { name: 'Tornado', lvl: 14, cost: 24, mult: 3.4, type: 'Air' } ]},
      'Galehawk': { hp: 95, mp: 25, atk: 18, spd: 20, type: 'Air', draw: (c) => { c.fillStyle = '#713f12'; c.beginPath(); c.moveTo(0, -10); c.lineTo(-50, -40); c.lineTo(0, -60); c.lineTo(50, -40); c.closePath(); c.fill(); c.fillStyle = '#ca8a04'; c.beginPath(); c.arc(0,-35,12,0,Math.PI*2); c.fill(); }, skills: [ { name: 'Gust', lvl: 1, cost: 6, mult: 1.6, type: 'Air' }, { name: 'Sky Dive', lvl: 15, cost: 28, mult: 3.8, type: 'Air' } ]},
      'Mindbug': { hp: 110, mp: 80, atk: 15, spd: 15, type: 'Psionic', draw: (c) => { c.fillStyle = '#d946ef'; c.beginPath(); c.ellipse(0, -30, 25, 18, 0, 0, Math.PI*2); c.fill(); c.strokeStyle = '#701a75'; c.beginPath(); c.moveTo(-10,-45); c.lineTo(-20,-60); c.moveTo(10,-45); c.lineTo(20,-60); c.stroke(); }, skills: [ { name: 'Psy-Beam', lvl: 1, cost: 12, mult: 2.0, type: 'Psionic' }, { name: 'Mind Crush', lvl: 25, cost: 45, mult: 4.5, type: 'Psionic' } ]},
      'Telecrane': { hp: 130, mp: 60, atk: 22, spd: 18, type: 'Psionic', draw: (c) => { c.fillStyle = '#fda4af'; c.beginPath(); c.ellipse(0, -40, 10, 30, 0, 0, Math.PI*2); c.fill(); c.fillStyle = '#f43f5e'; c.beginPath(); c.arc(0,-70,12,0,Math.PI*2); c.fill(); c.fillStyle = '#22d3ee'; c.beginPath(); c.arc(0,-75,4,0,Math.PI*2); c.fill(); }, skills: [ { name: 'Kinesis', lvl: 1, cost: 10, mult: 1.8, type: 'Psionic' }, { name: 'Thought Wave', lvl: 22, cost: 35, mult: 3.8, type: 'Psionic' } ]},
      'Droid-X': { hp: 140, mp: 50, atk: 25, spd: 16, type: 'Cyber', draw: (c) => { c.fillStyle = '#94a3b8'; c.fillRect(-20,-50,40,50); c.fillStyle = '#22d3ee'; c.fillRect(-15,-40,30,8); }, skills: [ { name: 'Laser Shot', lvl: 1, cost: 15, mult: 2.2, type: 'Cyber' }, { name: 'Sync Pulse', lvl: 24, cost: 40, mult: 4.0, type: 'Cyber' } ]},
      'Glitcher': { hp: 100, mp: 100, atk: 20, spd: 28, type: 'Cyber', draw: (c) => { c.fillStyle = '#22c55e'; c.fillRect(-20,-40,40,40); c.fillStyle = 'black'; c.fillRect(-10,-30,5,5); c.fillRect(5,-30,5,5); c.fillRect(-10,-15,20,3); }, skills: [ { name: 'Bug Strike', lvl: 1, cost: 12, mult: 1.9, type: 'Cyber' }, { name: 'System Crash', lvl: 26, cost: 50, mult: 5.5, type: 'Cyber' } ]},
      'Omnistar': { hp: 300, mp: 150, atk: 45, spd: 40, type: 'Aether', draw: (c) => { c.fillStyle = '#fde047'; c.beginPath(); for(let i=0;i<5;i++){ let a=(i*72-90)*Math.PI/180; c.lineTo(Math.cos(a)*40, -30+Math.sin(a)*40); a=((i*72+36)-90)*Math.PI/180; c.lineTo(Math.cos(a)*15, -30+Math.sin(a)*15); } c.closePath(); c.fill(); }, skills: [ { name: 'Aether Flash', lvl: 1, cost: 25, mult: 3.0, type: 'Aether' }, { name: 'Cosmic End', lvl: 35, cost: 80, mult: 7.0, type: 'Aether' } ]},
      'Cosmogazer': { hp: 250, mp: 200, atk: 35, spd: 45, type: 'Aether', draw: (c) => { c.fillStyle = '#6366f1'; c.beginPath(); c.arc(0,-30,30,0,Math.PI*2); c.fill(); c.fillStyle = 'white'; for(let i=0;i<10;i++) c.fillRect(Math.random()*40-20, -50+Math.random()*40, 2, 2); }, skills: [ { name: 'Star Dust', lvl: 1, cost: 20, mult: 2.5, type: 'Aether' }, { name: 'Universe Warp', lvl: 38, cost: 90, mult: 8.5, type: 'Aether' } ]},
      'Giga-Rex': { hp: 500, mp: 100, atk: 55, spd: 25, type: 'Kaiju', draw: (c) => { c.fillStyle = '#ef4444'; c.beginPath(); c.moveTo(-30,0); c.lineTo(-20,-60); c.lineTo(20,-60); c.lineTo(40,0); c.closePath(); c.fill(); c.fillStyle = 'white'; c.beginPath(); c.moveTo(0,-50); c.lineTo(10,-40); c.lineTo(20,-50); c.fill(); }, skills: [ { name: 'Primal Roar', lvl: 1, cost: 30, mult: 3.5, type: 'Kaiju' }, { name: 'Atomic Breath', lvl: 40, cost: 100, mult: 9.0, type: 'Kaiju' } ]},
      'Abyssal-Terror': { hp: 400, mp: 120, atk: 65, spd: 30, type: 'Kaiju', draw: (c) => { c.fillStyle = 'black'; c.beginPath(); c.ellipse(0,-10,40,20,0,0,Math.PI*2); c.fill(); c.fillStyle = 'red'; for(let i=0;i<5;i++) { c.beginPath(); c.arc(-30+i*15, -20+Math.random()*10, 4, 0, Math.PI*2); c.fill(); } }, skills: [ { name: 'Void Grip', lvl: 1, cost: 35, mult: 4.0, type: 'Kaiju' }, { name: 'Calamity', lvl: 42, cost: 110, mult: 10.0, type: 'Kaiju' } ]},
      'Sylvaris': { hp: 120, mp: 15, atk: 8, spd: 10, type: 'Nature', draw: (c) => { c.fillStyle = '#22c55e'; c.beginPath(); c.ellipse(0,-35,15,35,0,0,Math.PI*2); c.fill(); c.fillStyle = '#84cc16'; c.beginPath(); c.moveTo(-15,-40); c.lineTo(-40,-60); c.lineTo(-15,-50); c.fill(); c.beginPath(); c.moveTo(15,-40); c.lineTo(40,-60); c.lineTo(15,-50); c.fill(); }, skills: [ { name: 'Solar Bloom', lvl: 1, cost: 5, mult: 1.2, heal: 15, type: 'Nature' }, { name: 'Razor Leaf', lvl: 5, cost: 8, mult: 1.8, type: 'Nature' }, { name: 'Nature Embrace', lvl: 16, cost: 18, mult: 2.2, heal: 30, type: 'Nature' }, { name: 'Thorn Blast', lvl: 24, cost: 25, mult: 3.5, type: 'Nature' }, { name: 'Genesis Wave', lvl: 38, cost: 60, mult: 5.5, type: 'Nature' } ]},
      'Ignifrit': { hp: 80, mp: 10, atk: 16, spd: 15, type: 'Fire', draw: (c) => { c.fillStyle = '#f97316'; c.beginPath(); c.moveTo(-20,0); c.lineTo(0,-70); c.lineTo(20,0); c.fill(); c.fillStyle = '#fde047'; c.beginPath(); c.moveTo(-10,0); c.lineTo(0,-40); c.lineTo(10,0); c.fill(); }, skills: [ { name: 'Ember', lvl: 1, cost: 4, mult: 1.5, type: 'Fire' }, { name: 'Fireball', lvl: 7, cost: 10, mult: 2.2, type: 'Fire' }, { name: 'Lava Burst', lvl: 14, cost: 20, mult: 3.2, type: 'Fire' }, { name: 'Phoenix Strike', lvl: 26, cost: 35, mult: 4.5, type: 'Fire' }, { name: 'Supernova', lvl: 41, cost: 70, mult: 6.5, type: 'Fire' } ]},
      'Aquasaur': { hp: 100, mp: 25, atk: 11, spd: 8, type: 'Water', draw: (c) => { c.fillStyle = '#3b82f6'; c.beginPath(); c.roundRect(-25,-40,50,40,10); c.fill(); c.fillStyle = '#93c5fd'; c.beginPath(); c.moveTo(25,-30); c.lineTo(45,-50); c.lineTo(25,-10); c.fill(); }, skills: [ { name: 'Bubble', lvl: 1, cost: 4, mult: 1.4, type: 'Water' }, { name: 'Tsunami', lvl: 4, cost: 12, mult: 2.0, type: 'Water' }, { name: 'Hydro Cannon', lvl: 15, cost: 22, mult: 3.0, type: 'Water' }, { name: 'Ice Beam', lvl: 25, cost: 38, mult: 4.2, type: 'Water' }, { name: 'Oceanic Ruin', lvl: 39, cost: 65, mult: 5.8, type: 'Water' } ]},
      'Gloop': { hp: 40, mp: 10, atk: 4, spd: 5, type: 'Nature', draw: (c) => { c.fillStyle = '#4ade80'; c.beginPath(); c.arc(0, 0, 30, Math.PI, 0); c.ellipse(0, 0, 30, 15, 0, 0, Math.PI); c.fill(); }, skills: [ { name: 'Bouncy Slam', lvl: 1, cost: 4, mult: 1.4, type: 'Normal' }, { name: 'Slime Trap', lvl: 10, cost: 12, mult: 2.5, type: 'Nature' } ]},
      'Boneguard': { hp: 50, mp: 12, atk: 7, spd: 12, type: 'Dark', draw: (c) => { c.fillStyle = '#e2e8f0'; c.fillRect(-10,-40,20,40); c.beginPath(); c.arc(0,-50,15,0,Math.PI*2); c.fill(); c.fillStyle = '#475569'; c.fillRect(10,-35,5,30); }, skills: [ { name: 'Bone Shard', lvl: 1, cost: 5, mult: 1.8, type: 'Dark' }, { name: 'Grave Chill', lvl: 12, cost: 15, mult: 3.0, type: 'Dark' } ]},
      'Medusoid': { hp: 60, mp: 20, atk: 6, spd: 7, type: 'Nature', draw: (c) => { c.fillStyle = '#166534'; c.beginPath(); c.arc(0, -30, 25, 0, Math.PI*2); c.fill(); c.strokeStyle = '#22c55e'; c.lineWidth = 3; for(let i=0;i<6;i++) { c.beginPath(); c.moveTo(0,-45); c.quadraticCurveTo(Math.sin(i)*40,-70, Math.sin(i)*30,-50); c.stroke(); } }, skills: [ { name: 'Gaze', lvl: 1, cost: 6, mult: 1.6, type: 'Dark' }, { name: 'Stone Curse', lvl: 15, cost: 20, mult: 3.5, type: 'Dark' } ]},
      'Voidshade': { hp: 45, mp: 30, atk: 8, spd: 20, type: 'Dark', draw: (c) => { c.fillStyle = 'rgba(0,0,0,0.7)'; c.beginPath(); c.moveTo(-20,0); c.quadraticCurveTo(0,-80,20,0); c.fill(); c.fillStyle = 'red'; c.beginPath(); c.arc(-5,-45,2,0,Math.PI*2); c.fill(); c.beginPath(); c.arc(5,-45,2,0,Math.PI*2); c.fill(); }, skills: [ { name: 'Abyssal Pulse', lvl: 1, cost: 7, mult: 1.9, type: 'Dark' }, { name: 'Event Horizon', lvl: 20, cost: 40, mult: 4.5, type: 'Dark' } ]},
      'Aetherwing': { hp: 90, mp: 40, atk: 14, spd: 25, type: 'Fire', draw: (c) => { c.fillStyle = '#a855f7'; c.beginPath(); c.ellipse(0,-30,25,20,0,0,Math.PI*2); c.fill(); c.beginPath(); c.moveTo(-25,-35); c.lineTo(-50,-55); c.lineTo(-20,-45); c.fill(); c.beginPath(); c.moveTo(25,-35); c.lineTo(50,-55); c.lineTo(20,-45); c.fill(); }, skills: [ { name: 'Sky Dive', lvl: 1, cost: 10, mult: 2.5, type: 'Fire' }, { name: 'Star Fall', lvl: 22, cost: 50, mult: 5.0, type: 'Fire' } ]}
    };
    function calculateSkillDamage(attacker, defender, skill) {
      let dmg = attacker.atk * (skill.mult || 1.5);
      if (skill.type === attacker.type) dmg *= 1.5;
      const chart = TYPE_CHART[defender.type] || { weakTo: [], resist: [] };
      if (chart.weakTo.includes(skill.type)) dmg *= 2;
      if (chart.resist.includes(skill.type)) dmg *= 0.5;
      return Math.floor(dmg);
    }
    const ENCOUNTER_POOLS = {
      'forest': [ { key: 'Leafy', weight: 0.4 }, { key: 'Sprout', weight: 0.3 }, { key: 'Rabbite', weight: 0.2 }, { key: 'Birby', weight: 0.1 } ],
      'lake': [ { key: 'Aquasaur', weight: 0.4 }, { key: 'Gloop', weight: 0.3 }, { key: 'Medusoid', weight: 0.3 } ],
      'mountain': [ { key: 'Cliff-Ram', weight: 0.3 }, { key: 'Sky-Shredder', weight: 0.3 }, { key: 'Rockogolem', weight: 0.2 }, { key: 'Zephyros', weight: 0.2 } ],
      'desert': [ { key: 'Sand-Stinger', weight: 0.3 }, { key: 'Sun-Cactus', weight: 0.3 }, { key: 'Mindbug', weight: 0.2 }, { key: 'Droid-X', weight: 0.2 } ]
    };
    function createMonster(key, lvl) {
      const t = MONSTER_DB[key]; if (!t) return null;
      const m = JSON.parse(JSON.stringify(t));
      m.name = key; m.lvl = lvl; m.xp = 0; m.ap = 0;
      m.maxHp = t.hp + (lvl - 1) * 15; m.hp = m.maxHp;
      m.maxMp = t.mp + (lvl - 1) * 5; m.mp = m.maxMp;
      m.atk = t.atk + (lvl - 1) * 3;
      m.spd = (t.spd || 10) + (lvl - 1) * 2;
      m.learnedSkills = (t.skills || []).filter(s => s.lvl <= lvl);
      if (m.learnedSkills.length > 0) m.skill = m.learnedSkills[m.learnedSkills.length - 1];
      return m;
    }
    const STARTERS = [ createMonster('Sylvaris', 1), createMonster('Ignifrit', 1), createMonster('Aquasaur', 1) ];
    let activeActor = null;
    let currentEnemy = null;
    let battleBusy = false;

    const NPC_LOCATIONS = [
      { 
        x: 26, y: 15, type: 'dialog', color: '#4444ff', 
        text: "Hello! Follow the road west through the forest. You'll find a lake and the merchant there."
      },
      { 
        x: 6, y: 13, type: 'merchant', color: '#f1c40f', 
        items: [
          { name: 'Health Potion', price: 15, type: 'hp', value: 50 },
          { name: 'Mana Potion', price: 15, type: 'mp', value: 10 },
          { name: 'Monster Ball', price: 50, type: 'capture' }
        ]
      }
    ];
    let activeInteractionTarget = null;
    let dialogActive = false;

    const map = [];
    const MAP_LAYOUT = [
      "mmmmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmmbmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmbmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmbmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmbmmmmTTTTTTTTTTTTTTTTTTTT",
      "mmmmmmmmmmTTTTTTTTTTTTTTTTTTTT",
      "TTTTTTDTTTTTTTTTTTTTTTTTTTTTTT",
      "TTTTTTDTTTTTTTTTTTTTTTTTTTTTTT",
      "TTTwwwwwwTTTfffffffffTTT     T",
      "TTTwwwwwwTTTfffffffffTTT     T",
      "TTTwwwwwwTTTfffffffffTTT     T",
      "TTTwwwwwwDffffffffff D       T",
      "TTTwwwwwwTTTfffffffffTTT     T",
      "TTTwwwwwwTTTfffffffffTTT     T",
      "TTTwwwwwwTTTfffffffffTTT     T",
      "TTTTTTDTTTTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT",
      "ssssbsssssTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT",
      "sssssbssssTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT",
      "sssssssssbTTTTTTTTTTTTTTTTTTTT",
      "ssssssssssTTTTTTTTTTTTTTTTTTTT"
    ];
    function initMap() {
      const charMap = {
        'T': { type: 'tree', color: '#064e3b', traversable: false },
        ' ': { type: 'grass', color: '#2ecc71', traversable: true },
        'D': { type: 'dirt', color: '#d35400', traversable: true },
        'f': { type: 'dungeon', color: '#1b5e20', traversable: true, pool: 'forest', levelRange: [1, 6] },
        'm': { type: 'dungeon', color: '#7f8c8d', traversable: true, pool: 'mountain', levelRange: [15, 25] },
        's': { type: 'dungeon', color: '#f1c40f', traversable: true, pool: 'desert', levelRange: [25, 40] },
        'w': { type: 'dungeon', color: '#3498db', traversable: true, pool: 'lake', levelRange: [7, 14] },
        'b': { type: 'boulder', color: '#475569', traversable: false }
      };
      for (let y = 0; y < MAP_SIZE_TILES; y++) {
        map[y] = [];
        const row = MAP_LAYOUT[y];
        for (let x = 0; x < MAP_SIZE_TILES; x++) {
          const char = row[x] || 'T';
          map[y][x] = { ...charMap[char] };
        }
      }
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();
    initMap();

    function showDialog(text) {
      document.getElementById('dialogText').innerText = text;
      document.getElementById('dialog').style.display = 'block';
      dialogActive = true;
    }

    function hideDialog() {
      document.getElementById('dialog').style.display = 'none';
      document.getElementById('shop').style.display = 'none';
      dialogActive = false;
    }

    let currentShopItems = null;
    function openShop(items) {
      if (items) currentShopItems = items;
      const container = document.getElementById('shop-items');
      container.innerHTML = '';
      currentShopItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item';
        div.innerHTML = `<span>${item.name} (${item.price}G)</span><button onclick="buyItem('${item.name}', '${item.type}', ${item.price}, ${item.value})">Buy</button>`;
        container.appendChild(div);
      });
      document.getElementById('shop').style.display = 'block';
      dialogActive = true;
    }

    function buyItem(name, type, price, val) {
      if (playerStats.gold >= price) {
        playerStats.gold -= price;
        const existing = playerStats.inventory.find(i => i.name === name);
        if (existing) {
          existing.count++;
        } else {
          playerStats.inventory.push({ name, type, val, count: 1 });
        }
        updateHud();
        openShop();
      } else {
        alert("Not enough gold!");
      }
    }

    function closeShop() {
      document.getElementById('shop').style.display = 'none';
      dialogActive = false;
    }

    function toggleMenu() {
      const m = document.getElementById('menu-modal');
      if (m.style.display === 'block') {
        m.style.display = 'none';
        dialogActive = false;
        return;
      }
      if (gameState !== 'EXPLORE' || document.getElementById('shop').style.display === 'block') return;
      m.style.display = 'block';
      showMainMenu();
      dialogActive = true;
    }

    function showMainMenu() {
      const content = document.getElementById('menu-content');
      content.innerHTML = `
        <h3 style="margin-top: 0;">Menu</h3>
        <button class="menu-btn" onclick="showParty()">Party</button>
        <button class="menu-btn" onclick="showInventory()">Inventory</button>
        <button class="menu-btn" onclick="saveGame()">Save Game</button>
        <button class="menu-btn" onclick="toggleMenu()">Close</button>
      `;
    }

    function showParty() {
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Party</h3><div style="max-height: 260px; overflow-y: auto;">`;
      playerStats.party.forEach((p, i) => {
        html += `
          <button class="menu-btn" onclick="showMemberDetail(${i})" style="text-align: left;">
            <div style="font-weight: bold;">${p.name} (Lvl ${p.lvl})</div>
            <div style="font-size: 0.8em; margin-top: 4px;">HP: ${Math.ceil(p.hp)}/${p.maxHp} | MP: ${Math.ceil(p.mp)}/${p.maxMp}</div>
          </button>
        `;
      });
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="showMainMenu()">Back</button>`;
      content.innerHTML = html;
    }

    function showMemberDetail(idx) {
      const p = playerStats.party[idx];
      const content = document.getElementById('menu-content');
      const req = p.lvl * 50;
      content.innerHTML = `
        <h3 style="margin-top: 0;">${p.name} Details</h3>
        <div style="font-size: 0.9em; line-height: 1.4; text-align: left; padding: 0 5px;">
          <div style="margin-bottom: 5px;"><strong>Type:</strong> ${p.type}</div>
          <div style="margin-bottom: 5px;"><strong>Level:</strong> ${p.lvl}</div>
          <div style="margin-bottom: 5px;"><strong>HP:</strong> ${Math.ceil(p.hp)} / ${p.maxHp}</div>
          <div style="margin-bottom: 5px;"><strong>MP:</strong> ${Math.ceil(p.mp)} / ${p.maxMp}</div>
          <div style="margin-bottom: 5px;"><strong>Attack:</strong> ${p.atk}</div>
          <div style="margin-bottom: 5px;"><strong>Speed:</strong> ${p.spd}</div>
          <div style="margin-bottom: 5px;"><strong>XP:</strong> ${p.xp || 0} / ${req}</div>
          <hr style="border: 0; border-top: 1px solid #eee; margin: 10px 0;">
          <strong>Skills:</strong><br>
          • Basic Attack (Normal)<br>
          ${p.learnedSkills ? p.learnedSkills.map(s => `• ${s.name} (${s.type}, ${s.cost} MP)`).join('<br>') : 'No skills learned'}
        </div>
        <button class="menu-btn" style="margin-top: 15px; color: #e74c3c;" onclick="releaseMonster(${idx})">Release Monster</button>
        <button class="menu-btn" onclick="showParty()">Back</button>
      `;
    }

    function releaseMonster(idx) {
      if (playerStats.party.length <= 1) {
        alert("You cannot release your only monster!");
        return;
      }
      if (confirm(`Release ${playerStats.party[idx].name}? It will be gone forever.`)) {
        playerStats.party.splice(idx, 1);
        showParty();
        updateHud();
      }
    }

    function openBattleBag() {
      showInventory(true);
      document.getElementById('menu-modal').style.display = 'block';
      dialogActive = true;
    }
    function openSkillMenu() {
      const actor = activeActor;
      if (!actor || actor === currentEnemy) return;
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Select Skill</h3><div style="max-height: 200px; overflow-y: auto;">`;
      if (!actor.learnedSkills || actor.learnedSkills.length === 0) {
        html += `<p>No skills learned</p>`;
      } else {
        actor.learnedSkills.forEach((skill, idx) => {
          const disabled = actor.mp < skill.cost ? 'opacity: 0.5; pointer-events: none;' : '';
          html += `<button class="menu-btn" style="${disabled} text-align: left;" onclick="useSkill(${idx})">
            <div style="display: flex; justify-content: space-between;"><strong>${skill.name}</strong> <span>${skill.cost} MP</span></div>
            <div style="font-size:0.75em; color: #666; margin-top: 4px;">${skill.type} | Power: x${skill.mult}${skill.heal ? ' | Heal: ' + skill.heal : ''}</div>
          </button>`;
        });
      }
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="toggleMenu()">Back</button>`;
      content.innerHTML = html;
      document.getElementById('menu-modal').style.display = 'block';
      dialogActive = true;
    }
    function useSkill(idx) {
      toggleMenu();
      battleAction('useSkill', idx);
    }

    function showInventory(isBattle = false) {
      const content = document.getElementById('menu-content');
      let html = `<h3 style="margin-top: 0;">Inventory</h3><div style="max-height: 200px; overflow-y: auto;">`;
      if (playerStats.inventory.length === 0) {
        html += `<p>Empty</p>`;
      } else {
        playerStats.inventory.forEach((item, idx) => {
          html += `<div class="shop-item"><span>${item.name} (x${item.count})</span><button onclick="useItem(${idx}, ${isBattle})">Use</button></div>`;
        });
      }
      html += `</div><button class="menu-btn" style="margin-top: 10px;" onclick="${isBattle ? 'toggleMenu()' : 'showMainMenu()'}">Back</button>`;
      content.innerHTML = html;
    }

    function useItem(idx, isBattle = false) {
      if (isBattle) { battleAction('item', idx); return; }
      const item = playerStats.inventory[idx];
      const hero = playerStats.party[0];
      if (item.type === 'hp') {
        if (hero.hp >= hero.maxHp) { alert("HP already full!"); return; }
        hero.hp = Math.min(hero.maxHp, hero.hp + item.val);
      } else if (item.type === 'mp') {
        if (hero.mp >= hero.maxMp) { alert("MP already full!"); return; }
        hero.mp = Math.min(hero.maxMp, hero.mp + item.val);
      } else { alert("Cannot use this now!"); return; }
      item.count--;
      if (item.count <= 0) playerStats.inventory.splice(idx, 1);
      showInventory(false);
      updateHud();
    }

    canvas.addEventListener('mousedown', (e) => {
      if (dialogActive || gameState === 'BATTLE') {
        if (dialogActive && document.getElementById('dialog').style.display === 'block') hideDialog();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const cam = getCameraOffset();
      const worldX = screenX + cam.x;
      const worldY = screenY + cam.y;
      const targetTileX = Math.floor(worldX / TILE_SIZE);
      const targetTileY = Math.floor(worldY / TILE_SIZE);
      const startTX = Math.floor(player.x / TILE_SIZE);
      const startTY = Math.floor(player.y / TILE_SIZE);
      let clickedNpc = NPC_LOCATIONS.find(n => n.x === targetTileX && n.y === targetTileY);

      if (clickedNpc) {
        const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        let bestPath = null;
        for (const [dx, dy] of neighbors) {
          const nx = clickedNpc.x + dx, ny = clickedNpc.y + dy;
          if (nx >= 0 && nx < MAP_SIZE_TILES && ny >= 0 && ny < MAP_SIZE_TILES && map[ny][nx].traversable) {
            const p = findPath(startTX, startTY, nx, ny);
            if (p && (!bestPath || p.length < bestPath.length)) bestPath = p;
          }
        }
        if (bestPath) {
          if (bestPath.length === 0) {
            if (clickedNpc.type === 'dialog') showDialog(clickedNpc.text);
            else if (clickedNpc.type === 'merchant') openShop(clickedNpc.items);
            player.path = [];
          } else {
            player.path = bestPath;
            activeInteractionTarget = clickedNpc;
          }
        }
      } else if (map[targetTileY] && map[targetTileY][targetTileX] && map[targetTileY][targetTileX].traversable) {
        const p = findPath(startTX, startTY, targetTileX, targetTileY);
        if (p) {
          player.path = p;
          activeInteractionTarget = null;
        }
      }
    });

    function getCameraOffset() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      
      // Clamping to map borders
      const maxCamX = MAP_PIXEL_SIZE - canvas.width;
      const maxCamY = MAP_PIXEL_SIZE - canvas.height;
      
      // If map is smaller than screen, center it
      if (MAP_PIXEL_SIZE < canvas.width) camX = (MAP_PIXEL_SIZE - canvas.width) / 2;
      else camX = Math.max(0, Math.min(camX, maxCamX));

      if (MAP_PIXEL_SIZE < canvas.height) camY = (MAP_PIXEL_SIZE - canvas.height) / 2;
      else camY = Math.max(0, Math.min(camY, maxCamY));

      return { x: camX, y: camY };
    }

    function updateHud() {
      if (playerStats.party.length === 0) return;
      const hero = playerStats.party[0];
      document.getElementById('player-hud').innerText = `L:${hero.lvl} HP:${Math.ceil(hero.hp)} G:${playerStats.gold} P:${playerStats.party.length}`;
    }

    function saveGame() {
      const saveData = {
        playerStats: playerStats,
        player: { x: player.x, y: player.y }
      };
      localStorage.setItem('monsterCatcherV2_Save', JSON.stringify(saveData));
      alert("Game Saved!");
      toggleMenu();
    }

    function loadGame() {
      const saved = localStorage.getItem('monsterCatcherV2_Save');
      if (!saved) return;
      const data = JSON.parse(saved);
      playerStats.party = data.playerStats.party;
      playerStats.gold = data.playerStats.gold;
      playerStats.inventory = data.playerStats.inventory;
      player.x = data.player.x;
      player.y = data.player.y;
      player.path = [];
      document.getElementById('starter-screen').style.display = 'none';
      updateHud();
    }

    function update() {
      if (dialogActive || gameState === 'BATTLE') return;
      updateHud();
      if (player.path && player.path.length > 0) {
        const target = player.path[0];
        const dx = target.x - player.x;
        const dy = target.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > PLAYER_SPEED) {
          player.isWalking = true;
          player.x += (dx / dist) * PLAYER_SPEED;
          player.y += (dy / dist) * PLAYER_SPEED;
          player.animFrame += 0.15;
          const tx = Math.floor(player.x / TILE_SIZE);
          const ty = Math.floor(player.y / TILE_SIZE);
          if (map[ty] && map[ty][tx] && map[ty][tx].type === 'dungeon' && Math.random() < 0.012) {
            player.path = [];
            startBattle(map[ty][tx]);
          }
        } else {
          player.x = target.x;
          player.y = target.y;
          player.path.shift();
          if (player.path.length === 0) {
            player.isWalking = false;
            if (activeInteractionTarget) {
              if (activeInteractionTarget.type === 'dialog') showDialog(activeInteractionTarget.text);
              else if (activeInteractionTarget.type === 'merchant') openShop(activeInteractionTarget.items);
              activeInteractionTarget = null;
            }
          }
        }
      } else {
        player.isWalking = false;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = getCameraOffset();

      ctx.save();
      ctx.translate(-cam.x, -cam.y);

      // Draw Tiles
      const startTileX = Math.floor(cam.x / TILE_SIZE);
      const endTileX = Math.floor((cam.x + canvas.width) / TILE_SIZE) + 1;
      const startTileY = Math.floor(cam.y / TILE_SIZE);
      const endTileY = Math.floor((cam.y + canvas.height) / TILE_SIZE) + 1;

      for (let y = Math.max(0, startTileY); y < Math.min(MAP_SIZE_TILES, endTileY); y++) {
        for (let x = Math.max(0, startTileX); x < Math.min(MAP_SIZE_TILES, endTileX); x++) {
          const tile = map[y][x];
          ctx.fillStyle = tile.color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          if (tile.type === 'tree') {
            const tx = x * TILE_SIZE + TILE_SIZE / 2, ty = y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillStyle = '#3f2a14'; ctx.fillRect(tx - 4, ty + 10, 8, 12);
            ctx.fillStyle = '#064e3b'; ctx.beginPath(); ctx.moveTo(tx, ty - 20); ctx.lineTo(tx - 20, ty + 10); ctx.lineTo(tx + 20, ty + 10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(tx, ty - 5); ctx.lineTo(tx - 15, ty + 15); ctx.lineTo(tx + 15, ty + 15); ctx.fill();
          } else if (tile.type === 'boulder') {
            const tx = x * TILE_SIZE + TILE_SIZE / 2, ty = y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillStyle = '#475569'; ctx.beginPath(); ctx.arc(tx, ty, 18, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#64748b'; ctx.beginPath(); ctx.arc(tx - 5, ty - 5, 5, 0, Math.PI * 2); ctx.fill();
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw NPCs
      const drawNpc = (tx, ty, color) => {
        const nx = tx * TILE_SIZE + TILE_SIZE / 2;
        const ny = ty * TILE_SIZE + TILE_SIZE / 2;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(nx, ny + 15, 15, 8, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.roundRect(nx - 15, ny - 45, 30, 45, 10); ctx.fill();
        ctx.fillStyle = '#ffdbac';
        ctx.beginPath(); ctx.arc(nx, ny - 50, 12, 0, Math.PI * 2); ctx.fill();
      };
      NPC_LOCATIONS.forEach(n => drawNpc(n.x, n.y, n.color));

      // Draw Player Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 15, 15, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Draw Player (Body)
      const bob = player.isWalking ? Math.abs(Math.sin(player.animFrame)) * 8 : 0;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.roundRect(player.x - 15, player.y - 45 - bob, 30, 45, 10);
      ctx.fill();
      
      // Draw Head
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(player.x, player.y - 50 - bob, 12, 0, Math.PI * 2);
      ctx.fill();

      // Draw Feet (Walking animation)
      if (player.isWalking) {
        const legMove = Math.sin(player.animFrame) * 10;
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5 + legMove, 8, 5);  // Left foot
        ctx.fillRect(player.x + 4, player.y - 5 - legMove, 8, 5);   // Right foot
      } else {
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - 12, player.y - 5, 8, 5);
        ctx.fillRect(player.x + 4, player.y - 5, 8, 5);
      }

      ctx.restore();

      requestAnimationFrame(() => {
        update();
        draw();
      });
    }

    function startBattle(zone) {
      player.isWalking = false; player.path = [];
      document.getElementById('flash-overlay').classList.add('flashing');
      setTimeout(() => document.getElementById('flash-overlay').classList.remove('flashing'), 500);
      gameState = 'BATTLE';
      const pool = ENCOUNTER_POOLS[zone.pool] || ENCOUNTER_POOLS['forest'];
      const range = zone.levelRange || [1, 5];
      const level = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
      let totalWeight = pool.reduce((sum, item) => sum + item.weight, 0);
      let rand = Math.random() * totalWeight;
      let selectedKey = pool[0].key;
      for (const item of pool) { if (rand < item.weight) { selectedKey = item.key; break; } rand -= item.weight; }
      currentEnemy = createMonster(selectedKey, level);
      currentEnemy.gold = 10 + level * 8; currentEnemy.xp = 15 + level * 10;
      playerStats.party.forEach(p => p.ap = 0);
      currentEnemy.ap = 0;
      activeActor = null;
      document.getElementById('battle-screen').style.display = 'flex';
      nextTurn(`A wild Lvl ${currentEnemy.lvl} ${currentEnemy.name} appeared!`);
    }

    function updateBattleUI(msg) {
      const partyList = document.getElementById('party-list');
      const enemyList = document.getElementById('enemy-list');
      if (!partyList || !enemyList) return;
      partyList.innerHTML = ''; enemyList.innerHTML = '';
      playerStats.party.forEach((p, i) => {
        const div = document.createElement('div');
        div.className = 'battle-card' + (p === activeActor ? ' active-actor' : '');
        div.innerHTML = `<canvas id="p-canv-${i}" class="battle-card-canvas" width="100" height="100"></canvas><div style="flex:1; min-width:0;"><div style="font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${p.name} <span style="font-size:0.7em">L${p.lvl}</span></div><div class="bar-container"><div class="bar-fill hp-fill" style="width:${(p.hp/p.maxHp*100)}%"></div><div class="bar-text">HP ${Math.ceil(p.hp)}/${p.maxHp}</div></div><div class="bar-container"><div class="bar-fill mp-fill" style="width:${(p.mp/p.maxMp*100)}%"></div><div class="bar-text">MP ${Math.ceil(p.mp)}/${p.maxMp}</div></div></div>`;
        partyList.appendChild(div);
        drawMonsterIcon(document.getElementById(`p-canv-${i}`).getContext('2d'), p.name);
      });
      if (currentEnemy) {
        const div = document.createElement('div');
        div.className = 'battle-card' + (currentEnemy === activeActor ? ' active-actor' : '');
        div.style.flexDirection = 'row-reverse'; div.style.textAlign = 'right';
        div.innerHTML = `<canvas id="e-canv" class="battle-card-canvas" width="100" height="100"></canvas><div style="flex:1; min-width:0;"><div style="font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${currentEnemy.name} <span style="font-size:0.7em">L${currentEnemy.lvl}</span></div><div class="bar-container" style="margin-left:auto"><div class="bar-fill hp-fill" style="width:${(currentEnemy.hp/currentEnemy.maxHp*100)}%"></div><div class="bar-text">HP ${Math.ceil(currentEnemy.hp)}/${currentEnemy.maxHp}</div></div><div class="bar-container" style="margin-left:auto"><div class="bar-fill mp-fill" style="width:${(currentEnemy.mp/currentEnemy.maxMp*100)}%"></div><div class="bar-text">MP ${Math.ceil(currentEnemy.mp)}/${currentEnemy.maxMp}</div></div></div>`;
        enemyList.appendChild(div);
        drawMonsterIcon(document.getElementById('e-canv').getContext('2d'), currentEnemy.name);
      }
      document.getElementById('acting-name').innerText = activeActor ? `Turn: ${activeActor.name}` : "";
      if (msg) document.getElementById('battle-msg').innerText = msg;
    }

    function drawMonsterIcon(mCtx, name) {
      mCtx.clearRect(0, 0, 100, 100);
      const monster = MONSTER_DB[name];
      if (!monster || !monster.draw) return;
      mCtx.save();
      mCtx.translate(50, 75);
      monster.draw(mCtx);
      mCtx.restore();
    }

    function nextTurn(msg) {
      if (gameState !== 'BATTLE') return;
      const combatants = [...playerStats.party.filter(p => p.hp > 0), currentEnemy];
      while (true) {
        combatants.sort((a, b) => b.ap - a.ap);
        if (combatants[0].ap >= 100) {
          activeActor = combatants[0];
          updateBattleUI(msg);
          if (activeActor === currentEnemy) setTimeout(enemyTurn, 800);
          else battleBusy = false;
          return;
        }
        for (let c of combatants) c.ap = (c.ap || 0) + c.spd;
      }
    }

    function enemyTurn() {
      if (gameState !== 'BATTLE' || currentEnemy.hp <= 0) return;
      const targets = playerStats.party.filter(p => p.hp > 0);
      if (targets.length === 0) return;
      const usableSkills = (currentEnemy.learnedSkills || []).filter(s => currentEnemy.mp >= s.cost);
      let target = null, skillToUse = null;
      for (const s of usableSkills) {
        const weakTarget = targets.find(t => (TYPE_CHART[t.type] || { weakTo: [] }).weakTo.includes(s.type));
        if (weakTarget) { target = weakTarget; skillToUse = s; break; }
      }
      if (!target) {
        target = targets[Math.floor(Math.random() * targets.length)];
        if (usableSkills.length > 0) skillToUse = usableSkills[usableSkills.length - 1];
      }
      let dmg = 0, txt = "";
      if (skillToUse) {
        currentEnemy.mp -= skillToUse.cost;
        dmg = calculateSkillDamage(currentEnemy, target, skillToUse);
        txt = `${currentEnemy.name} uses ${skillToUse.name} on ${target.name} for ${dmg}!`;
      } else {
        dmg = currentEnemy.atk + Math.floor(Math.random() * 5);
        txt = `${currentEnemy.name} attacks ${target.name} for ${dmg}!`;
      }
      target.hp = Math.max(0, target.hp - dmg);
      updateBattleUI(txt);
      if (playerStats.party.every(p => p.hp <= 0)) { alert("Defeat..."); location.reload(); return; }
      activeActor.ap -= 100;
      setTimeout(nextTurn, 800);
    }

    function battleAction(type, data = null) {
      if (battleBusy || !activeActor || activeActor === currentEnemy) return;
      if (type === 'skill') { openSkillMenu(); return; }
      battleBusy = true;
      let msg = "";
      if (type === 'attack') {
        const dmg = activeActor.atk + Math.floor(Math.random() * 5);
        currentEnemy.hp = Math.max(0, currentEnemy.hp - dmg);
        msg = `${activeActor.name} hit for ${dmg}! `;
      } else if (type === 'useSkill') {
        const skill = activeActor.learnedSkills[data];
        activeActor.mp -= skill.cost;
        const dmg = calculateSkillDamage(activeActor, currentEnemy, skill);
        currentEnemy.hp = Math.max(0, currentEnemy.hp - dmg);
        if (skill.heal) activeActor.hp = Math.min(activeActor.maxHp, activeActor.hp + skill.heal);
        msg = `${activeActor.name} used ${skill.name} for ${dmg}! `;
      } else if (type === 'flee') {
        if (Math.random() > 0.4) { endBattle("You escaped!"); return; }
        msg = "Flee failed! ";
      } else if (type === 'item') {
        const item = playerStats.inventory[data];
        if (item.type === 'capture') {
          if (playerStats.party.length >= 4) { alert("Party full!"); toggleMenu(); battleBusy = false; return; }
          const chance = 0.2 + (0.5 * (1 - (currentEnemy.hp / currentEnemy.maxHp)));
          item.count--; if (item.count <= 0) playerStats.inventory.splice(data, 1);
          toggleMenu();
          if (Math.random() < chance) { playerStats.party.push(JSON.parse(JSON.stringify(currentEnemy))); endBattle("Captured!"); return; }
          else msg = "Capture failed! ";
        } else {
          if (item.type === 'hp') activeActor.hp = Math.min(activeActor.maxHp, activeActor.hp + item.val);
          if (item.type === 'mp') activeActor.mp = Math.min(activeActor.maxMp, activeActor.mp + item.val);
          item.count--; if (item.count <= 0) playerStats.inventory.splice(data, 1);
          toggleMenu(); msg = "Item used! ";
        }
      }
      updateBattleUI(msg);
      if (currentEnemy.hp <= 0) {
        playerStats.gold += currentEnemy.gold; gainXp(currentEnemy.xp);
        endBattle(`Victorious! +${currentEnemy.xp}XP`);
      } else {
        activeActor.ap -= 100;
        setTimeout(nextTurn, 600);
      }
    }

    function gainXp(amt) {
      playerStats.party.forEach(member => {
        if (member.hp <= 0) return;
        member.xp = (member.xp || 0) + amt;
        let req = member.lvl * 50;
        while (member.xp >= req) {
          member.lvl++;
          member.maxHp += 15; member.hp = member.maxHp;
          member.maxMp += 5; member.mp = member.maxMp;
          member.atk += 3; member.spd += 2;
          const t = MONSTER_DB[member.name];
          if (t && t.skills) {
            const newOnes = t.skills.filter(s => s.lvl === member.lvl);
            newOnes.forEach(ns => {
              if (!member.learnedSkills) member.learnedSkills = [];
              member.learnedSkills.push(ns);
              alert(`${member.name} learned ${ns.name}!`);
            });
            if (member.learnedSkills && member.learnedSkills.length > 0) {
              member.skill = member.learnedSkills[member.learnedSkills.length - 1];
            }
          }
          req = member.lvl * 50;
        }
      });
    }

    function endBattle(msg) {
      updateBattleUI(msg);
      setTimeout(() => {
        document.getElementById('battle-screen').style.display = 'none';
        gameState = 'EXPLORE';
        battleBusy = false;
      }, 1500);
    }

    function initStarterScreen() {
      const screen = document.getElementById('starter-screen');
      const container = screen.querySelector('.starter-cards');
      const savedData = localStorage.getItem('monsterCatcherV2_Save');
      if (savedData) {
        const btn = document.createElement('button');
        btn.className = 'menu-btn';
        btn.style.width = '240px';
        btn.style.marginBottom = '20px';
        btn.style.pointerEvents = 'auto';
        btn.innerText = 'Continue Last Save';
        btn.onclick = loadGame;
        screen.insertBefore(btn, container);
      }
      STARTERS.forEach((s, i) => {
        const card = document.createElement('div');
        card.className = 'starter-card';
        card.onclick = () => selectStarter(i);
        card.innerHTML = `<canvas id="starter-canvas-${i}" width="100" height="100" style="width:80px; height:80px;"></canvas><h3>${s.name}</h3><div class="stats">Type: ${s.type}<br>HP: ${s.maxHp}<br>ATK: ${s.atk}<br>SPD: ${s.spd}<br>MP: ${s.maxMp}<br>Skill: ${s.skill.name}</div><button class="menu-btn" style="pointer-events:none">Select</button>`;
        container.appendChild(card);
        drawMonsterIcon(document.getElementById(`starter-canvas-${i}`).getContext('2d'), s.name);
      });
    }
    function selectStarter(idx) {
      playerStats.party = [JSON.parse(JSON.stringify(STARTERS[idx]))];
      document.getElementById('starter-screen').style.display = 'none';
      updateHud();
    }
    initStarterScreen();
    draw();
  </script>
</body>
</html>