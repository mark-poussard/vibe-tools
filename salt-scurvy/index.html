<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Salt & Scurvy</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0e171d;
            font-family: 'Courier New', Courier, monospace;
            color: #e0d8c3;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            text-shadow: 2px 2px 0px #000;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border: 1px solid #5d5d5d;
            border-radius: 4px;
        }

        .debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: #777;
            pointer-events: none;
        }

        #game-over, #port-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 30, 0.98);
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        #game-over { border: 2px solid #ff5252; }
        #port-menu { border: 2px solid #4fc3f7; min-width: 250px; }
        #port-menu h2 { color: #4fc3f7; margin-top: 0; }
        .port-btn-group { display: flex; flex-direction: column; gap: 8px; }

        .btn {
            background: #233a4a;
            color: #e0d8c3;
            border: 1px solid #e0d8c3;
            padding: 10px 20px;
            margin-top: 15px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="stat-box">
            Gold: <span id="gold-val">0</span>
        </div>
        <div class="stat-box">
            Food: <span id="food-val">0</span>
        </div>
        <div class="stat-box">
            Hull: <span id="hull-val">0/100</span>
        </div>
    </div>
    <div id="game-over">
        <h1 style="color: #ff5252; margin-top: 0;">SUNK!</h1>
        <p>Your crew starved at sea...</p>
        <button class="btn" onclick="location.reload()">RETRY</button>
    </div>
    <div id="port-menu">
        <h2>Trading Port</h2>
        <div class="port-btn-group">
            <button class="btn" onclick="gameInstance.buyFood()">Restock Food (1G/unit)</button>
            <button class="btn" onclick="gameInstance.repairHull()">Repair Hull (25G)</button>
            <button class="btn" onclick="gameInstance.upgradeSails()">Better Sails (100G)</button>
            <button class="btn" onclick="gameInstance.upgradeHull()">Reinforce Hull (150G)</button>
        </div>
        <button class="btn" style="background: #333; margin-top: 15px;" onclick="gameInstance.closePort()">LEAVE</button>
    </div>
    <div class="debug-info" id="debug">FPS: 60</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * STATE MANAGEMENT
         */
        /**
         * MAP GENERATOR
         */
        class MapGenerator {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cellSize = 160;
            }

            generate() {
                const nodes = [];
                const cols = Math.floor(this.width / this.cellSize);
                const rows = Math.floor(this.height / this.cellSize);
                const types = [
                    { name: 'Foraging', icon: 'üåø', color: '#81c784', weight: 0.3, props: { foodRange: [10, 30] } },
                    { name: 'Port', icon: '‚öì', color: '#4fc3f7', weight: 0.2, props: { repairCost: 5, foodPrice: 2 } },
                    { name: 'Ruins', icon: 'üóø', color: '#ba68c8', weight: 0.25, props: { lootRange: [20, 100], risk: 0.4 } },
                    { name: 'Wreck', icon: 'üèöÔ∏è', color: '#ff8a65', weight: 0.25, props: { salvageRange: [5, 50] } }
                ];

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (Math.random() > 0.6) continue;
                        const x = (c * this.cellSize) + 40 + Math.random() * (this.cellSize - 80);
                        const y = (r * this.cellSize) + 40 + Math.random() * (this.cellSize - 80);
                        const dist = Math.hypot(x, y);
                        const maxDist = Math.hypot(this.width, this.height);
                        const danger = parseFloat((dist / maxDist).toFixed(2));
                        const reward = parseFloat((1 + (dist / maxDist) * 2).toFixed(2));
                        const typeRoll = Math.random();
                        let type = types[0];
                        let cum = 0;
                        for (const t of types) {
                            cum += t.weight;
                            if (typeRoll < cum) { type = t; break; }
                        }
                        nodes.push({
                            id: `n_${r}_${c}`, x, y,
                            type: type.name, icon: type.icon, color: type.color,
                            danger, reward, properties: { ...type.props },
                            connections: []
                        });
                    }
                }
                nodes.forEach(n1 => {
                    const near = nodes.filter(n2 => n2.id !== n1.id)
                        .sort((a, b) => Math.hypot(a.x - n1.x, a.y - n1.y) - Math.hypot(b.x - n1.x, b.y - n1.y))
                        .slice(0, 2);
                    near.forEach(n2 => {
                        if (!n1.connections.includes(n2.id)) n1.connections.push(n2.id);
                        if (!n2.connections.includes(n1.id)) n2.connections.push(n1.id);
                    });
                });
                return nodes;
            }
        }

        const State = {
            _data: {
                gold: 150,
                food: 100,
                maxFood: 100,
                ship: { hull: 100, maxHull: 100, speed: 0.15, x: 0, y: 0, angle: 0, target: null },
                world: { nodes: [] },
                hazards: [],
                shake: 0,
                status: 'idle',
                lastUpdate: Date.now()
            },
            observers: [],
            init() {
                const saved = localStorage.getItem('salt_scurvy_v1');
                if (saved) {
                    try {
                        const d = JSON.parse(saved);
                        if (d.ship && d.world) {
                            this._data = d;
                            if (!this._data.maxFood) this._data.maxFood = 100;
                        }
                    } catch (e) { console.error(e); }
                }
                if (!this._data.world || !this._data.world.nodes || !this._data.world.nodes.length) {
                    const gen = new MapGenerator(window.innerWidth, window.innerHeight);
                    this._data.world = { nodes: gen.generate() };
                    if (this._data.world.nodes.length > 0) {
                        this._data.ship.x = this._data.world.nodes[0].x;
                        this._data.ship.y = this._data.world.nodes[0].y;
                    }
                }
                this.notify();
            },
            save() { localStorage.setItem('salt_scurvy_v1', JSON.stringify(this._data)); },
            subscribe(callback) { this.observers.push(callback); callback(this._data); },
            notify() { this.observers.forEach(cb => cb(this._data)); },
            updateStat(key, value) {
                if (this._data.hasOwnProperty(key)) this._data[key] = value;
                else if (this._data.ship.hasOwnProperty(key)) this._data.ship[key] = value;
                this.notify();
                this.save();
            }
        };

        /**
         * CORE ENGINE
         */
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.lastTime = 0;
                this.fps = 0;
                
                // Bind UI elements
                this.uiGold = document.getElementById('gold-val');
                this.uiFood = document.getElementById('food-val');
                this.uiHull = document.getElementById('hull-val');
                this.uiDebug = document.getElementById('debug');

                this.init();
            }

            init() {
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('pointerdown', (e) => this.handleInput(e));
                this.resize();
                
                State.init();
                State.subscribe((data) => this.syncUI(data));

                requestAnimationFrame((t) => this.loop(t));
            }

            handleInput(e) {
                if (State._data.status === 'gameover') return;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                State._data.ship.target = { x, y };
                State._data.status = 'sailing';
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                // Re-draw immediately on resize to prevent flicker
                this.render();
            }

            syncUI(data) {
                this.uiGold.innerText = Math.floor(data.gold);
                this.uiFood.innerText = Math.floor(data.food) + '/' + (data.maxFood || 100);
                this.uiHull.innerText = Math.floor(data.ship.hull) + '/' + data.ship.maxHull;
            }

            update(dt) {
                if (State._data.status === 'gameover') return;
                const s = State._data;
                const ship = s.ship;
                if (s.shake > 0) s.shake -= dt * 0.05;
                if (s.status === 'sailing' && ship.target) {
                    const dx = ship.target.x - ship.x;
                    const dy = ship.target.y - ship.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 5) {
                        const moveDist = ship.speed * dt;
                        ship.x += (dx / dist) * moveDist;
                        ship.y += (dy / dist) * moveDist;
                        s.food -= (moveDist * 0.02);
                        const targetAngle = Math.atan2(dy, dx);
                        let diff = targetAngle - ship.angle;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        ship.angle += diff * 0.1;
                        if (Math.random() < 0.03) {
                            const angle = ship.angle + (Math.random() - 0.5) * 2.5;
                            s.hazards.push({ x: ship.x + Math.cos(angle) * 350, y: ship.y + Math.sin(angle) * 350, type: Math.random() > 0.4 ? 'whirlpool' : 'shark', radius: 20 });
                        }
                        if (s.food <= 0) {
                            s.food = 0; s.status = 'gameover';
                            document.getElementById('game-over').style.display = 'block';
                            document.querySelector('#game-over p').innerText = "Your crew starved at sea...";
                        }
                    } else {
                        const tx = ship.target.x, ty = ship.target.y;
                        ship.x = tx; ship.y = ty; s.status = 'idle'; s.hazards = [];
                        this.checkArrival(tx, ty);
                    }
                    for (let i = s.hazards.length - 1; i >= 0; i--) {
                        const h = s.hazards[i];
                        if (h.type === 'shark') {
                            const hdx = ship.x - h.x, hdy = ship.y - h.y, hdist = Math.hypot(hdx, hdy);
                            h.x += (hdx / hdist) * 0.07 * dt; h.y += (hdy / hdist) * 0.07 * dt;
                        }
                        const distToShip = Math.hypot(ship.x - h.x, ship.y - h.y);
                        if (distToShip < h.radius + 12) {
                            s.ship.hull -= 15; s.shake = 15; s.hazards.splice(i, 1);
                            if (s.ship.hull <= 0) {
                                s.ship.hull = 0; s.status = 'gameover';
                                document.getElementById('game-over').style.display = 'block';
                                document.getElementById('game-over').querySelector('h1').innerText = "SUNK!";
                                document.querySelector('#game-over p').innerText = "Your ship was claimed by the depths!";
                            }
                        } else if (distToShip > 800) s.hazards.splice(i, 1);
                    }
                    State.notify();
                }
            }

            checkArrival(x, y) {
                const s = State._data;
                const node = s.world.nodes.find(n => Math.hypot(n.x - x, n.y - y) < 30);
                if (node && node.type === 'Port') {
                    document.getElementById('port-menu').style.display = 'block';
                }
            }

            buyFood() {
                const s = State._data;
                const maxF = s.maxFood || 100;
                const cost = Math.ceil(maxF - s.food);
                if (s.gold >= cost && cost > 0) {
                    s.gold -= cost;
                    s.food = maxF;
                    State.save(); State.notify();
                }
            }

            repairHull() {
                const s = State._data;
                if (s.gold >= 25 && s.ship.hull < s.ship.maxHull) {
                    s.gold -= 25;
                    s.ship.hull = Math.min(s.ship.maxHull, s.ship.hull + 25);
                    State.save(); State.notify();
                }
            }

            upgradeSails() {
                const s = State._data;
                if (s.gold >= 100) {
                    s.gold -= 100;
                    s.ship.speed += 0.03;
                    State.save(); State.notify();
                }
            }

            upgradeHull() {
                const s = State._data;
                if (s.gold >= 150) {
                    s.gold -= 150;
                    s.ship.maxHull += 25;
                    s.ship.hull += 25;
                    State.save(); State.notify();
                }
            }

            closePort() {
                document.getElementById('port-menu').style.display = 'none';
            }

            render() {
                const ctx = this.ctx, w = this.canvas.width, h = this.canvas.height, s = State._data;
                ctx.fillStyle = '#1a2a35'; ctx.fillRect(0, 0, w, h);
                ctx.save();
                if (s.shake > 0) ctx.translate((Math.random() - 0.5) * s.shake, (Math.random() - 0.5) * s.shake);
                ctx.strokeStyle = '#233a4a'; ctx.lineWidth = 1;
                for (let i = 0; i < w; i += 100) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, h); ctx.stroke(); }
                for (let i = 0; i < h; i += 100) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(w, i); ctx.stroke(); }
                if (!s.world || !s.world.nodes) { ctx.restore(); return; }
                ctx.strokeStyle = 'rgba(224, 216, 195, 0.15)'; ctx.setLineDash([5, 10]);
                s.world.nodes.forEach(n => {
                    n.connections.forEach(cid => {
                        const target = s.world.nodes.find(tn => tn.id === cid);
                        if (target) { ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.lineTo(target.x, target.y); ctx.stroke(); }
                    });
                });
                ctx.setLineDash([]);
                s.world.nodes.forEach(n => {
                    ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.arc(n.x + 3, n.y + 3, 16, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = n.color; ctx.beginPath(); ctx.arc(n.x, n.y, 16, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#e0d8c3'; ctx.lineWidth = 1.5; ctx.stroke();
                    ctx.fillStyle = '#1a2a35'; ctx.font = '18px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(n.icon, n.x, n.y);
                    ctx.fillStyle = '#e0d8c3'; ctx.font = '10px "Courier New"'; ctx.fillText(n.type, n.x, n.y + 28);
                    ctx.fillStyle = '#ff5252'; ctx.font = '9px "Courier New"'; ctx.fillText(`üíÄ D:${n.danger} R:${n.reward}`, n.x, n.y + 38);
                });
                s.hazards.forEach(haz => {
                    ctx.save(); ctx.translate(haz.x, haz.y);
                    if (haz.type === 'whirlpool') {
                        ctx.rotate(Date.now() * 0.005); ctx.strokeStyle = 'rgba(0, 150, 255, 0.4)';
                        for(let r=5; r<haz.radius; r+=5) { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 1.5); ctx.stroke(); }
                        ctx.font = '14px serif'; ctx.fillText('üåÄ', 0, 0);
                    } else { ctx.font = '20px serif'; ctx.fillText('ü¶à', 0, 0); }
                    ctx.restore();
                });
                const ship = s.ship;
                ctx.save(); ctx.translate(ship.x, ship.y); ctx.rotate(ship.angle); ctx.fillStyle = '#e0d8c3';
                ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, -10); ctx.lineTo(-10, 10); ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'white'; ctx.fillRect(-2, -8, 2, 16); ctx.restore();
                ctx.restore();
            }

            loop(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;
                
                if (dt < 100) { // Prevent massive jumps after tab focus
                    this.update(dt);
                    this.render();
                }

                // FPS Counter
                if (Math.round(timestamp) % 10 === 0) {
                    this.fps = Math.round(1000 / dt);
                    this.uiDebug.innerText = `FPS: ${this.fps} | RES: ${this.canvas.width}x${this.canvas.height}`;
                }

                requestAnimationFrame((t) => this.loop(t));
            }
        }

        // Start application
        window.onload = () => {
            window.gameInstance = new Game();
        };
    </script>
</body>
</html>