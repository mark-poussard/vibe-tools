<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanguard of the Void</title>
    <style>
        :root {
            --bg-color: #202c39;
            --card-bg: #ecf0f1;
            --text-color: #2c3e50;
            --highlight: #f1c40f;
            --monster-color: #e74c3c;
            --skill-color: #3498db;
            --loot-color: #2ecc71;
            --hero-color: #9b59b6;
            --event-color: #e67e22;
            --curse-color: #7f8c8d;
            --ui-panel: rgba(0,0,0,0.4);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            padding: 0;
            height: 100dvh; /* Dynamic Viewport Height for mobile */
            overflow: hidden;
            font-size: 14px;
        }

        /* --- Common Layouts --- */
        .screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }

        h1 { margin: 10px 0; font-size: 24px; text-align: center; }
        button {
            padding: 12px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        button:active { transform: scale(0.98); }

        /* --- Game Screen Grid --- */
        #game-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 5px;
            display: none; /* Controlled by JS */
        }

        /* Stats Bar (Compact) */
        #stats-bar {
            background: var(--ui-panel);
            padding: 8px;
            border-radius: 8px;
            font-size: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        .stat-row { display: flex; justify-content: space-between; }

        /* Scrollable Card Rows (The key to mobile layout) */
        .scroll-row {
            display: flex;
            gap: 8px;
            padding: 5px 2px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch; /* Smooth scroll iOS */
            min-height: 135px; /* Fits card height */
            align-items: center;
        }
        /* Hide scrollbar but keep functionality */
        .scroll-row::-webkit-scrollbar { display: none; }

        #adventure-row {
            background: rgba(231, 76, 60, 0.05);
            border-top: 2px solid var(--monster-color);
            border-bottom: 2px solid var(--monster-color);
        }

        #hand-row {
            background: rgba(52, 152, 219, 0.05);
            border-top: 2px solid var(--skill-color);
            margin-top: auto; /* Push to bottom */
            margin-bottom: 5px;
        }

        .area-label {
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.7;
            margin-left: 5px;
            margin-bottom: -5px;
            z-index: 1;
        }

        /* Hero Area (Middle) */
        #hero-area {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            flex-grow: 1;
            min-height: 100px;
        }
        #hero-card-container { transform: scale(0.9); transform-origin: left center; }
        #equipment-slots { display: flex; gap: 4px; overflow-x: auto; }
        
        #end-turn-container {
            margin-left: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #end-turn-btn {
            background: var(--monster-color);
            color: white;
            width: 80px;
            height: 60px;
            font-size: 12px;
            line-height: 1.2;
            white-space: pre-wrap;
        }

        /* --- Cards (Mobile Optimized) --- */
        .card {
            flex: 0 0 85px; /* Fixed width, no shrinking/growing */
            width: 85px;
            height: 120px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            position: relative;
            font-size: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            user-select: none;
        }

        .card-header {
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 10px;
            margin-bottom: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid #bdc3c7;
        }

        .card-desc {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 9px;
            line-height: 1.1;
            overflow: hidden;
        }
        
        .card-stats {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 11px;
            margin-top: 2px;
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
            padding: 2px;
        }

        /* Card Types Borders */
        .type-monster { border-bottom: 4px solid var(--monster-color); }
        .type-skill { border-bottom: 4px solid var(--skill-color); }
        .type-loot { border-bottom: 4px solid var(--loot-color); }
        .type-event { border-bottom: 4px solid var(--event-color); }
        .type-curse { border-bottom: 4px solid var(--curse-color); background: #bdc3c7; }
        .type-hero { border: 2px solid var(--hero-color); width: 90px; height: 120px; }

        .card.selected { border: 2px solid var(--highlight); transform: translateY(-10px); }
        .card.equipped { transform: scale(0.9);}

        /* Buttons on cards */
        .choice-btn { font-size: 8px; padding: 4px; width: 100%; margin-top: 2px; }
        .destroy-btn { width: 20px; height: 20px; font-size: 12px; }

        /* --- Map & Menus --- */
        #map-screen, #hero-selection, #hero-screen, #deck-screen {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
        }

        /* Draggable Map Styles */
        #map-screen { padding: 0; overflow: hidden; position: relative; background: #1a1a1a; }
        
        #map-viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            position: relative;
        }
        
        #map-viewport:active { cursor: grabbing; }

        #map-world {
            width: 1200px; /* Large virtual canvas */
            height: 800px;
            position: absolute;
            top: 0; left: 0;
            transform-origin: 0 0;
            background-image: radial-gradient(#34495e 1px, transparent 1px);
            background-size: 20px 20px; /* Grid pattern */
        }

        .map-node-visual {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #7f8c8d;
            background: #2c3e50;
            color: white;
            font-weight: bold;
            font-size: 18px;
            z-index: 5;
            transition: transform 0.2s, border-color 0.2s;
            /* Center the circle on the coord */
            transform: translate(-50%, -50%);
        }

        .map-node-visual.locked { opacity: 0.6; filter: grayscale(1); }
        .map-node-visual.unlocked { border-color: var(--highlight); background: #27ae60; cursor: pointer; box-shadow: 0 0 15px var(--highlight); animation: pulse 2s infinite; }
        .map-node-visual.completed { border-color: gold; background: #e67e22; cursor: pointer; }

        .map-node-visual:hover.unlocked { transform: translate(-50%, -50%) scale(1.1); }

        .node-label {
            position: absolute;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }

        /* SVG Connections Layer */
        #map-lines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        .map-connection {
            stroke: #7f8c8d;
            stroke-width: 4;
            opacity: 0.5;
        }

        /* UI Overlay Layer */
        .map-ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to map */
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .map-ui-overlay button { pointer-events: auto; } /* Re-enable buttons */

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }

        .deck-manager-container {
            display: flex;
            flex-direction: column; /* Vertical stack */
            gap: 10px;
            flex: 1; /* Fill remaining screen height */
            overflow: hidden; /* Prevent container scroll */
            margin-top: 10px;
            min-height: 0; /* Flexbox nesting fix */
        }
        .deck-column {
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.2);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            padding: 5px;
            min-height: 0; /* Allow shrinking */
        }
        .deck-column h2 { 
            text-align: center; margin: 5px 0; font-size: 14px; color: var(--highlight); 
            flex-shrink: 0; 
        }
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            overflow-y: auto; /* Individual area scroll */
            flex: 1; /* Fill column space */
            padding: 5px;
        }

        /* Grids for managers */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            padding-bottom: 20px;
        }

        /* Log (Mini Overlay) */
        #log-console {
            height: 40px;
            font-size: 10px;
            background: rgba(0,0,0,0.6);
            position: absolute;
            bottom: 150px; /* Above hand */
            left: 10px;
            right: 10px;
            pointer-events: none;
            padding: 5px;
            border-radius: 4px;
            z-index: 10;
            display: flex;
            flex-direction: column-reverse; /* Newest at bottom */
        }

        /* Overlay */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body>

<!-- Hero Selection Screen -->
<div id="hero-selection">
    <h1>Choose Your Hero</h1>
    <div class="hero-select-container" id="hero-select-container">
        <!-- Hero cards injected here -->
    </div>
</div>
    
<!-- Map Screen -->
<div id="map-screen">
    <!-- 1. The Moving World -->
    <div id="map-viewport">
        <div id="map-world">
            <svg id="map-lines"></svg>
            <div id="map-nodes-layer"></div>
        </div>
    </div>

    <!-- 2. Fixed UI Overlay -->
    <div class="map-ui-overlay">
        <!-- Top Bar -->
        <div style="display:flex; justify-content: space-between; align-items: start;">
            <div style="background:rgba(0,0,0,0.6); padding:5px; border-radius:4px;">
                <h1 style="font-size:16px; margin:0;">World Map</h1>
            </div>
            <div style="display:flex; flex-direction: column; gap:5px;">
                <button onclick="showHeroScreen()" style="background-color: var(--hero-color);">Hero</button>
                <button onclick="showDeckScreen()" style="background-color: var(--skill-color);">Deck</button>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div style="display:flex; justify-content: flex-end;">
            <button onclick="resetProgress()" style="background-color: #c0392b; font-size: 10px; padding: 5px;">Reset Save</button>
        </div>
    </div>
</div>

<!-- Hero / Inventory Screen -->
<div id="hero-screen">
    <div style="display:flex; justify-content:space-between; align-items:center; width:100%; max-width:600px;">
        <h1>Hero Details</h1>
        <button onclick="closeHeroScreen()">Back to Map</button>
    </div>

    <div class="hero-panel">
        <!-- Stats -->
        <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #fff; padding-bottom:10px;">
            <strong style="color:var(--hero-color); font-size:1.5em;"><span id="hero-screen-name">Hero</span></strong>
            <div style="text-align:right;">
                <strong style="color:#f1c40f; font-size:1.2em; margin-right:15px;">Gold: <span id="hero-screen-gold">0</span></strong>
                <strong style="color:var(--monster-color); font-size:1.2em;">HP: <span id="hero-screen-hp">0</span>/<span id="hero-screen-max-hp">0</span></strong>
            </div>
        </div>

        <!-- Equipped -->
        <div>
            <div style="font-size:1em; margin-bottom:10px; color:var(--loot-color);">Equipped Items (Click to Unequip):</div>
            <div id="hero-screen-equipped" style="display:flex; gap:10px; min-height:100px; align-items:center; background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;"></div>
        </div>

        <!-- Inventory -->
        <div style="flex-grow: 1; overflow-y: auto;">
            <div style="font-size:1em; margin-bottom:10px; color:var(--highlight); position: sticky; top:0; background: var(--bg-color); padding: 5px;">Inventory</div>
            <div id="hero-screen-inventory" class="card-grid" style="background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;"></div>
        </div>
    </div>
</div>

<!-- Deck Management Screen -->
<div id="deck-screen">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1>Deck Manager</h1>
        <button onclick="closeDeckScreen()">Back to Map</button>
    </div>
    <div class="deck-manager-container">
        <!-- Active Deck (Fixed max height to 40% of screen) -->
        <div class="deck-column" style="flex: 0 0 40%;">
            <h2>Deck (<span id="manager-deck-count">0</span>)</h2>
            <div id="manager-deck-grid" class="card-grid"></div>
        </div>
        <!-- Collection (Takes remaining space) -->
        <div class="deck-column" style="flex: 1;">
            <h2>Collection (<span id="manager-col-count">0</span>)</h2>
            <div id="manager-col-grid" class="card-grid"></div>
        </div>
    </div>
</div>

<!-- Game Overlay (Win/Loss) -->
<div id="overlay">
    <h1 id="overlay-title">Game Over</h1>
    <button onclick="location.reload()">Play Again</button>
</div>

<!-- Main Game Interface -->
<div id="game-container">
    
    <!-- Top: Compact Stats -->
    <div id="stats-bar">
        <div class="stat-row">
            <strong style="color:var(--hero-color)"><span id="hero-name">Hero</span></strong>
            <strong style="color:var(--monster-color)">HP: <span id="hero-hp">0</span>/<span id="hero-max-hp">0</span></strong>
        </div>
        <div class="stat-row">
            <strong style="color:var(--highlight)">AP: <span id="hero-ap">0</span>/<span id="hero-max-ap">0</span></strong>
            <strong style="color:var(--skill-color)">Blk: <span id="hero-block">0</span></strong>
            <span>Deck:<span id="deck-count">0</span></span>
        </div>
    </div>

    <!-- Row 2: Adventure (Scrollable) -->
    <div class="area-label">
        Adventure 
        <button id="explore-btn" style="font-size:9px; padding:2px 6px;" onclick="exploreDungeon()">+ Explore</button>
    </div>
    <div id="adventure-row" class="scroll-row">
        <!-- Monsters injected here -->
    </div>

    <!-- Row 3: Hero & Equip -->
    <div id="hero-area">
        <div id="hero-card-container">
            <!-- Hero Card -->
        </div>
        <div style="flex-grow:1; overflow:hidden;">
            <div class="area-label" style="margin-bottom:2px;">Equipped</div>
            <div id="equipment-slots">
                <!-- Equipped Items -->
            </div>
        </div>
        <div id="end-turn-container">
            <button id="end-turn-btn" onclick="endTurn()">END<br>TURN</button>
        </div>
    </div>

    <!-- Log Overlay -->
    <div id="log-console"></div>

    <!-- Row 4: Hand (Scrollable, fixed bottom) -->
    <div class="area-label">Hand</div>
    <div id="hand-row" class="scroll-row">
        <!-- Hand cards -->
    </div>

</div>

<script>
/* --- GAME DATA --- */

const CARD_TYPES = {
    HERO: 'hero',
    MONSTER: 'monster',
    SKILL: 'skill',
    LOOT: 'loot',
    EVENT: 'event',
    CURSE: 'curse'
};

const HEROES = [
    { 
        id: 'h_ironclad', 
        name: 'Ironclad', 
        type: CARD_TYPES.HERO, 
        hp: 30, maxHp: 30, 
        ap: 2, maxAp: 2, 
        block: 0, 
        desc: 'Tanky. Starts with Shield.',
        startItem: 'i_shield'
    },
    { 
        id: 'h_shadow', 
        name: 'Shadow', 
        type: CARD_TYPES.HERO, 
        hp: 25, maxHp: 25, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Agile. Acts fast.',
        startItem: 'i_cloak'
    },
    { 
        id: 'h_weaver', 
        name: 'Weaver', 
        type: CARD_TYPES.HERO, 
        hp: 20, maxHp: 20, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Fragile. Powerful spells.',
        startItem: 'i_wand'
    }
];

/* --- DATABASE (ITEMS & SKILLS) --- */
const ITEM_DB = {
    // --- TIER 1 COMMON ---
    'l_dagger': { id: 'l_dagger', name: 'Rusty Dagger', type: CARD_TYPES.LOOT, rarity: 'common', value: 10, atkBuff: 1, desc: '+1 DMG' },
    'l_shield': { id: 'l_shield', name: 'Buckler', type: CARD_TYPES.LOOT, rarity: 'common', value: 10, block: 1, desc: '+1 Block on Play' },
    's_bite':   { id: 's_bite',   name: 'Rabid Bite', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, dmg: 2, desc: 'Deal 2 DMG' },
    's_claw':   { id: 's_claw',   name: 'Feral Claw', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, dmg: 3, desc: 'Deal 3 DMG' },
    's_mend':   { id: 's_mend',   name: 'Mend',       type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, heal: 4, desc: 'Heal 4 HP' },

    // --- TIER 1 RARE ---
    'l_goo':    { id: 'l_goo',    name: 'Slime Shield', type: CARD_TYPES.LOOT, rarity: 'rare', value: 25, block: 2, desc: '+2 Block on Play' },
    'l_spear':  { id: 'l_spear',  name: 'Short Spear',  type: CARD_TYPES.LOOT, rarity: 'rare', value: 25, atkBuff: 2, desc: '+2 DMG' },
    's_web':    { id: 's_web',    name: 'Web Shot',     type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, dmg: 5, desc: 'Deal 5 DMG' },

    // --- TIER 2 COMMON ---
    's_smash':  { id: 's_smash',  name: 'Big Smash',    type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, dmg: 8, desc: 'Deal 8 DMG' },
    'l_amulet': { id: 'l_amulet', name: 'Ghost Amulet', type: CARD_TYPES.LOOT, rarity: 'common', value: 20, atkBuff: 2, desc: '+2 DMG' },
    
    // --- TIER 2 RARE ---
    's_bolt':   { id: 's_bolt',   name: 'Dark Bolt',    type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, dmg: 12, desc: 'Deal 12 DMG' },
    'l_cloak':  { id: 'l_cloak',  name: 'Shadow Cloak', type: CARD_TYPES.LOOT, rarity: 'rare', value: 40, block: 1, apBonus: 1, desc: '+1 Block, +1 Max AP' },

    // --- TIER 3 LEGENDARY ---
    's_stone':  { id: 's_stone',  name: 'Stone Form',   type: CARD_TYPES.SKILL, rarity: 'legendary', cost: 2, block: 15, desc: 'Gain 15 Block' },
    'l_bark':   { id: 'l_bark',   name: 'Bark Skin',    type: CARD_TYPES.LOOT, rarity: 'legendary', value: 80, hpBonus: 5, desc: '+5 Max HP' },
    'l_scale':  { id: 'l_scale',  name: 'Dragon Scale', type: CARD_TYPES.LOOT, rarity: 'legendary', value: 80, block: 3, desc: '+3 Block on Play' },
    
    // --- STARTING ITEMS ---
    'i_shield': { id: 'i_shield', name: 'Buckler', type: CARD_TYPES.LOOT, rarity: 'common', value: 5, block: 1, desc: '+1 Block on Play' },
    'i_cloak':  { id: 'i_cloak',  name: 'Cloak',   type: CARD_TYPES.LOOT, rarity: 'common', value: 5, apBonus: 1, desc: '+1 Max AP' },
    'i_wand':   { id: 'i_wand',   name: 'Ember',   type: CARD_TYPES.LOOT, rarity: 'common', value: 5, atkBuff: 1, desc: '+1 DMG' },

    // --- SKILLS (Converted to Effect System) ---
    
    // Tier 1 Common
    's_bite':   { id: 's_bite',   name: 'Rabid Bite', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DAMAGE', val: 2, target: 'ENEMY' }], desc: 'Deal 2 DMG' },
    
    's_claw':   { id: 's_claw',   name: 'Feral Claw', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DAMAGE', val: 3, target: 'ENEMY' }], desc: 'Deal 3 DMG' },
    
    's_mend':   { id: 's_mend',   name: 'Mend',       type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [{ type: 'HEAL', val: 4, target: 'SELF' }], desc: 'Heal 4 HP' },

    // Tier 1 Rare
    's_web':    { id: 's_web',    name: 'Web Shot',     type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, 
                  effects: [{ type: 'DAMAGE', val: 5, target: 'ENEMY' }], desc: 'Deal 5 DMG' },

    // Tier 2 Common
    's_smash':  { id: 's_smash',  name: 'Big Smash',    type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, 
                  effects: [{ type: 'DAMAGE', val: 8, target: 'ENEMY' }], desc: 'Deal 8 DMG' },

    // Tier 2 Rare
    's_drain':  { id: 's_drain',  name: 'Void Spike',   type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, 
                  effects: [
                      { type: 'DAMAGE', val: 6, target: 'ENEMY' },
                      { type: 'HEAL', val: 2, target: 'SELF' } // Added logic for drain
                  ], desc: 'Deal 6 DMG & Heal 2' },

    // Tier 3 Legendary
    's_stone':  { id: 's_stone',  name: 'Stone Form',   type: CARD_TYPES.SKILL, rarity: 'legendary', cost: 2, 
                  effects: [{ type: 'BLOCK', val: 15, target: 'SELF' }], desc: 'Gain 15 Block' },

    // --- LIBRARY SKILLS (From Chests/Trainer) ---
    's_rush':   { id: 's_rush', name: 'Adrenaline', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'GAIN_AP', val: 2, target: 'SELF' }], desc: 'Gain 2 AP' },

    's_exec':   { id: 's_exec', name: 'Execution', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 3, 
                  effects: [{ type: 'DAMAGE', val: 15, target: 'ENEMY' }], desc: 'Deal 15 DMG' },

    's_step':   { id: 's_step', name: 'Quick Step', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'BLOCK', val: 2, target: 'SELF' }], desc: 'Gain 2 Block' },

    's_wall':   { id: 's_wall', name: 'Heavy Plate', type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, 
                  effects: [{ type: 'BLOCK', val: 10, target: 'SELF' }], desc: 'Gain 10 Block' },

    's_shiv':   { id: 's_shiv', name: 'Shiv', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DAMAGE', val: 3, target: 'ENEMY' }], desc: 'Deal 3 DMG' },

    's_wild':   { id: 's_wild', name: 'Reckless Swing', type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [{ type: 'DAMAGE', val: 8, target: 'ENEMY' }], desc: 'Deal 8 DMG' },

    's_holy':   { id: 's_holy', name: 'Holy Light', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, 
                  effects: [{ type: 'HEAL', val: 8, target: 'SELF' }], desc: 'Heal 8 HP' },

    's_perf':   { id: 's_perf', name: 'Perfect Guard', type: CARD_TYPES.SKILL, rarity: 'legendary', cost: 3, 
                  effects: [{ type: 'BLOCK', val: 20, target: 'SELF' }], desc: 'Gain 20 Block' },

    's_plan':   { id: 's_plan', name: 'Planning', type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [{ type: 'DRAW', val: 2, target: 'SELF' }], desc: 'Draw 2 Cards' },

    // Trainer Exclusive Skills
    's_heavy':  { id: 's_heavy', name: 'Heavy Strike', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, 
                  effects: [{ type: 'DAMAGE', val: 10, target: 'ENEMY' }], desc: 'Deal 10 DMG' },

    's_iron':   { id: 's_iron', name: 'Iron Skin', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, 
                  effects: [{ type: 'BLOCK', val: 8, target: 'SELF' }], desc: 'Gain 8 Block' },
    
    // Hero Starting Skills (Explicit Copies for reference in Decks)
    's_fast':   { id: 's_fast', name: 'Fast Hands', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DRAW', val: 2, target: 'SELF' }], desc: 'Draw 2 Cards' },

    's_bash':   { id: 's_bash', name: 'Shield Bash', type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, 
                  effects: [
                      { type: 'DAMAGE', val: 5, target: 'ENEMY' },
                      { type: 'BLOCK', val: 5, target: 'SELF' }
                  ], desc: '5 DMG & 5 Block' },

    's_bolt':   { id: 's_bolt',   name: 'Dark Bolt',    type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, 
                  effects: [{ type: 'DAMAGE', val: 12, target: 'ENEMY' }], desc: 'Deal 12 DMG' },

    's_strike': { id: 's_strike', name: 'Strike', type: CARD_TYPES.SKILL, cost: 1, effects: [{type:'DAMAGE', val:3, target:'ENEMY'}], desc: 'Deal 3 DMG' },

    's_defend': { id: 's_defend', name: 'Defend', type: CARD_TYPES.SKILL, cost: 1, effects: [{type:'BLOCK', val:3, target:'SELF'}], desc: 'Gain 3 Block' }
};

const HERO_DECKS = {
    'h_ironclad': [
        ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'],
        ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'],
        ITEM_DB['s_bash']
    ],
    'h_shadow': [
        ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'],
        ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'],
        ITEM_DB['s_fast']
    ],
    'h_weaver': [
        ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'],
        ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'],
        ITEM_DB['s_bolt']
    ]
};

/* --- LOOT TABLES --- */
const LOOT_TABLES = {
    'tier1_standard': [
        { id: 'l_dagger', weight: 20 },
        { id: 'l_shield', weight: 20 },
        { id: 's_bite',   weight: 20 },
        { id: 's_claw',   weight: 20 },
        { id: 's_mend',   weight: 10 },
        { id: 'l_goo',    weight: 5 }, // Rare chance
        { id: 'l_spear',  weight: 5 }  // Rare chance
    ],
    'tier1_elite': [
        { id: 'l_goo',    weight: 30 },
        { id: 'l_spear',  weight: 30 },
        { id: 's_web',    weight: 30 },
        { id: 'l_shield', weight: 10 }
    ],
    'tier2_standard': [
        { id: 's_smash',  weight: 30 },
        { id: 'l_amulet', weight: 30 },
        { id: 's_bolt',   weight: 10 },
        { id: 'l_dagger', weight: 30 } // Fallback
    ],
    'tier3_void': [
        { id: 's_stone',  weight: 30 },
        { id: 'l_bark',   weight: 30 },
        { id: 'l_scale',  weight: 30 },
        { id: 'l_cloak',  weight: 10 }
    ],
    'chest_random': [
        { id: 'l_cloak',  weight: 10 },
        { id: 'l_spear',  weight: 20 },
        { id: 's_mend',   weight: 40 },
        { id: 'l_goo',    weight: 30 }
    ]
};

function rollLoot(tableId) {
    const table = LOOT_TABLES[tableId];
    if (!table) return null;

    // Calculate total weight
    const totalWeight = table.reduce((sum, entry) => sum + entry.weight, 0);
    let random = Math.floor(Math.random() * totalWeight);

    // Select item
    for (let entry of table) {
        random -= entry.weight;
        if (random < 0) {
            // Return a Copy of the item from DB
            return JSON.parse(JSON.stringify(ITEM_DB[entry.id]));
        }
    }
    return null;
}

const CURSE_CARD = { id: 'c_fatigue', name: 'Fatigue', type: CARD_TYPES.CURSE, cost: 1, desc: 'Unplayable trash.' };

const EVENT_MONSTERS = {
    'm_ghost': { id: 'm_ghost', name: 'Vengeful Spirit', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 4, rewardId: 'm_ghost', desc: 'Hit by Physical' },
    'm_mimic': { id: 'm_mimic', name: 'Mimic', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 5, rewardId: 'm_goblin', desc: 'It has teeth!' }
};

// --- TIERED DATA ---

const COMMON_EVENTS = [
    { 
        id: 'e_shrine', name: 'Cursed Shrine', type: CARD_TYPES.EVENT, minTier: 1, desc: 'A dark aura hums.',
        choices: [
            { label: 'Pray (Heal 10, Get Curse)', effect: 'pray' },
            { label: 'Desecrate (Fight Spirit)', effect: 'fight' },
            { label: 'Ignore (Leave)', effect: 'leave' }
        ]
    },
    {
        id: 'e_trap', name: 'Trap Door', type: CARD_TYPES.EVENT, minTier: 1, desc: 'The floor crumbles!',
        choices: [
            { label: 'Jump (Unequip Random Item)', effect: 'trap_unequip' },
            { label: 'Brace (Take 5 DMG)', effect: 'trap_dmg' }
        ]
    },
    {
        id: 'e_chest', name: 'Wooden Chest', type: CARD_TYPES.EVENT, minTier: 1, desc: 'Is it breathing?',
        choices: [
            { label: 'Open (Loot or Mimic)', effect: 'chest_open' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_tribute', name: 'Dark Altar', type: CARD_TYPES.EVENT, minTier: 2, desc: 'Requires a sacrifice.',
        choices: [
            { label: 'Sacrifice (Lose 5 Max HP, Get Relic)', effect: 'tribute_pay' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_trainer', name: 'Old Master', type: CARD_TYPES.EVENT, minTier: 2, desc: 'He offers training.',
        choices: [
            { label: 'Train Attack (Get Heavy Strike)', effect: 'train_str' },
            { label: 'Train Defense (Get Iron Skin)', effect: 'train_def' },
            { label: 'Ignore', effect: 'leave' }
        ]
    },
    {
        id: 'e_spring', name: 'Magic Spring', type: CARD_TYPES.EVENT, minTier: 1, desc: 'Glowing blue water.',
        choices: [
            { label: 'Drink (Heal 5 HP)', effect: 'spring_heal' },
            { label: 'Bottle (Get +1 Max HP)', effect: 'spring_max' }
        ]
    }
];

const MAP_GRAPH = {
    'node_caverns': { id: 'node_caverns', name: 'The Caverns', type: 'CAVERNS', tier: 1, parents: [], x: 150, y: 300 },
    
    'node_dark':    { id: 'node_dark',    name: 'The Deep Dark', type: 'DEEP_DARK', tier: 2, parents: ['node_caverns'], x: 400, y: 150 },
    
    'node_spider':  { id: 'node_spider',  name: 'Spider Nest',   type: 'SPIDER_NEST', tier: 2, parents: ['node_caverns'], x: 400, y: 450 },

    'node_void':    { id: 'node_void',    name: 'The Void',      type: 'VOID',      tier: 3, parents: ['node_dark', 'node_spider'], x: 650, y: 300 }
};

/* --- DUNGEON NODE CONFIGURATIONS --- */
const NODE_CONFIGS = {
    'CAVERNS': {
        icon: 'ðŸ¦‡', // Bat/Cave
        minCards: 5, maxCards: 6,
        monsters: ['m_goblin', 'm_rat', 'm_slime'], 
        events: ['e_trap', 'e_chest', 'e_spring'],
        bossPool: ['mb_troll', 'mb_brood']
    },
    'DEEP_DARK': {
        icon: 'ðŸŒ‘', // New Moon/Darkness
        minCards: 6, maxCards: 8,
        monsters: ['m_orc', 'm_spider', 'm_wolf', 'm_kobold'],
        events: ['e_shrine', 'e_tribute'],
        bossPool: ['mb_lich', 'mb_knight']
    },
    'VOID': {
        icon: 'ðŸ”®', // Crystal/Void
        minCards: 8, maxCards: 10,
        monsters: ['m_golem', 'm_assassin', 'm_ent', 'm_drake'],
        events: ['e_tribute', 'e_trainer'],
        bossPool: ['m_malakor']
    },
    'SPIDER_NEST': {
        icon: 'ðŸ•¸ï¸', // Web
        minCards: 5, maxCards: 7,
        monsters: ['m_spider'], 
        events: ['e_trap'],
        bossPool: ['mb_brood']
    }
};

const MONSTER_DB = {
    // Tier 1
    'm_goblin': { id: 'm_goblin', name: 'Goblin', type: CARD_TYPES.MONSTER, hp: 4, maxHp: 4, atk: 2, lootTable: 'tier1_standard', desc: 'Common Enemy' },
    'm_rat':    { id: 'm_rat',    name: 'Giant Rat', type: CARD_TYPES.MONSTER, hp: 3, maxHp: 3, atk: 3, lootTable: 'tier1_standard', desc: 'Fast Enemy' },
    'm_slime':  { id: 'm_slime',  name: 'Acid Slime', type: CARD_TYPES.MONSTER, hp: 5, maxHp: 5, atk: 1, lootTable: 'tier1_standard', desc: 'Sticky' },
    'm_kobold': { id: 'm_kobold', name: 'Kobold', type: CARD_TYPES.MONSTER, hp: 6, maxHp: 6, atk: 3, lootTable: 'tier1_elite', desc: 'Elite Scout' },
    
    // Tier 2
    'm_orc':    { id: 'm_orc',    name: 'Orc', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 4, lootTable: 'tier2_standard', desc: 'Heavy Hitter' },
    'm_spider': { id: 'm_spider', name: 'Cave Spider', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 2, lootTable: 'tier2_standard', desc: 'Poisonous' },
    'm_wolf':   { id: 'm_wolf',   name: 'Dire Wolf', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 3, lootTable: 'tier2_standard', desc: 'Fast Biter' },
    'm_cultist':{ id: 'm_cultist',name: 'Dark Cultist', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 5, lootTable: 'tier2_standard', desc: 'Glass Cannon' },

    // Tier 3
    'm_golem':  { id: 'm_golem',  name: 'Stone Golem', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 2, lootTable: 'tier3_void', desc: 'Tank' },
    'm_assassin':{ id: 'm_assassin', name: 'Void Assassin', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 6, lootTable: 'tier3_void', desc: 'High Damage!' },
    'm_ent':    { id: 'm_ent',    name: 'Rotting Ent', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 3, lootTable: 'tier3_void', desc: 'Ancient Wood' },
    'm_drake':  { id: 'm_drake',  name: 'Baby Drake', type: CARD_TYPES.MONSTER, hp: 18, maxHp: 18, atk: 5, lootTable: 'tier3_void', desc: 'Fierce!' },

    // Bosses
    'mb_troll': { id: 'mb_troll', name: 'Cave Troll', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 4, isBoss: true, desc: 'BOSS: Gatekeeper' },
    'mb_brood': { id: 'mb_brood', name: 'Broodmother', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 5, isBoss: true, desc: 'BOSS: Gatekeeper' },
    'mb_lich':  { id: 'mb_lich',  name: 'Elder Lich', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 5, isBoss: true, desc: 'BOSS: Gatekeeper' },
    'mb_knight':{ id: 'mb_knight', name: 'Void Knight', type: CARD_TYPES.MONSTER, hp: 30, maxHp: 30, atk: 4, isBoss: true, desc: 'BOSS: Gatekeeper' },
    'mb_malakor':{ id: 'mb_malakor', name: 'MALAKOR', type: CARD_TYPES.MONSTER, hp: 60, maxHp: 60, atk: 7, isBoss: true, desc: 'FINAL BOSS' }
};

const EVENT_DB = {}; 
COMMON_EVENTS.forEach(e => EVENT_DB[e.id] = e); // Quick mapping helper

/* --- STATE --- */

let state = {
    hero: null,
    deck: [],
    hand: [],
    discard: [],
    dungeonDeck: [],
    adventureRow: [], 
    equipped: [],
    selectedCardIndex: -1,
    turn: 1,
    completedNodes: [], // Array of node IDs (e.g. ['node_caverns'])
    currentNodeId: null, // The node currently being played
    collection: [], // Cards removed from deck
    inventory: [],
    gold: 0
};

/* --- EVENT MANAGER (STORE PATTERN) --- */
const EVENTS = {
    GAME_UPDATED: 'game_updated',       // Hand, Row, Deck, Discard changed
    HERO_UPDATED: 'hero_updated',       // HP, AP, Gold, Block, Stats changed
    INVENTORY_UPDATED: 'inv_updated',   // Equipment/Inventory changed
    MAP_UPDATED: 'map_updated'          // Nodes unlocked/completed
};

const EventManager = {
    listeners: {},
    on(event, callback) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(callback);
    },
    emit(event, data) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(cb => cb(data));
        }
    }
};

// Setup UI Subscribers
function initUIListeners() {
    // When Game State changes (Turn loop), redraw the Game Screen
    EventManager.on(EVENTS.GAME_UPDATED, () => {
        if (document.getElementById('game-container').style.display === 'flex') {
            render();
        }
    });

    // When Hero Stats change, update Game Bar AND Hero Screen
    EventManager.on(EVENTS.HERO_UPDATED, () => {
        // Update Game Top Bar (if visible)
        if (document.getElementById('game-container').style.display === 'flex') {
            render(); // This updates stats bar
        }
        // Update Hero Screen (if visible)
        if (document.getElementById('hero-screen').style.display === 'flex') {
            renderHeroScreen();
        }
    });

    // When Inventory changes, redraw Hero Screen
    EventManager.on(EVENTS.INVENTORY_UPDATED, () => {
        renderHeroScreen();
    });

    // When Map changes, redraw Nodes
    EventManager.on(EVENTS.MAP_UPDATED, () => {
        renderWorldMap();
    });
}

/* --- SCREEN MANAGER --- */
const Screens = {
    HERO_SELECT: {
        id: 'hero-selection',
        onEnter: () => {
            // If we need to re-render the selection cards dynamically, do it here
            // (Currently static in HTML, but could be moved here)
        }
    },
    MAP: {
        id: 'map-screen',
        onEnter: () => {
            document.getElementById('overlay').style.display = 'none';
            EventManager.emit(EVENTS.MAP_UPDATED); // Render Graph
            saveGame();
            
            // Init Drag Logic
            if (!mapState.initialized) {
                initMapDrag();
                mapState.initialized = true;
                document.getElementById('map-viewport').scrollLeft = 0;
            }
        }
    },
    GAME: {
        id: 'game-container',
        onEnter: () => {
            // Force update UI when entering combat
            EventManager.emit(EVENTS.GAME_UPDATED);
            EventManager.emit(EVENTS.HERO_UPDATED);
        }
    },
    HERO_DETAIL: {
        id: 'hero-screen',
        onEnter: () => {
            EventManager.emit(EVENTS.HERO_UPDATED);
            EventManager.emit(EVENTS.INVENTORY_UPDATED);
        }
    },
    DECK_MANAGER: {
        id: 'deck-screen',
        onEnter: () => {
            // Consolidate Deck logic moved here
            state.deck = state.deck.concat(state.discard);
            state.discard = [];
            state.hand = [];
            renderDeckManager();
        }
    }
};

const ScreenManager = {
    activeScreen: null,
    
    show(screenName) {
        const target = Screens[screenName];
        if (!target) return;

        this.activeScreen = screenName;

        // 1. Hide All Screens
        Object.values(Screens).forEach(scr => {
            const el = document.getElementById(scr.id);
            if (el) el.style.display = 'none';
        });

        // 2. Show Target
        const el = document.getElementById(target.id);
        if (el) {
            el.style.display = 'flex';
            // 3. Run Setup Logic
            if (target.onEnter) target.onEnter();
        }
    }
};

/* --- STARTUP LOGIC --- */

function initSelectionScreen() {
    ScreenManager.show('HERO_SELECT');
    const container = document.getElementById('hero-select-container');
    HEROES.forEach((hero, index) => {
        // Create a card for the hero
        let div = createCardElement(hero);
        div.onclick = () => startGame(index);
        // Add a "Select" label
        let label = document.createElement('div');
        label.innerHTML = "<br><strong>CLICK TO SELECT</strong>";
        label.style.textAlign = "center";
        label.style.fontSize = "10px";
        div.appendChild(label);
        container.appendChild(div);
    });
}

function startGame(heroIndex) {
    // Switch UI
    document.getElementById('hero-selection').style.display = 'none';
    document.getElementById('game-container').style.display = 'flex';

    // Initialize State
    state.hero = JSON.parse(JSON.stringify(HEROES[heroIndex]));
    // Load unique hero deck
    state.deck = JSON.parse(JSON.stringify(HERO_DECKS[state.hero.id]));
    
    // Hand/Discard reset
    state.hand = [];
    state.discard = [];
    state.equipped = [];
    
    // Start Item Logic
    state.equipped = [];
    if(state.hero.startItem) {
        let item = ITEM_DB[state.hero.startItem];
        // If item gives HP bonus immediately
        if(item.hpBonus) {
            state.hero.maxHp += item.hpBonus;
            state.hero.hp += item.hpBonus;
        }
        // If item gives AP bonus immediately
        if(item.apBonus) {
            state.hero.maxAp += item.apBonus;
            state.hero.ap += item.apBonus;
        }
        // We push deep copy to equipped
        state.equipped.push(JSON.parse(JSON.stringify(item)));
    }

    // Setup Deck
    shuffle(state.deck);
    
    // Go to Map
    ScreenManager.show('MAP');
    saveGame();

    log(`You selected ${state.hero.name}. The void awaits.`);
    if(state.hero.startItem) log(`Equipped starting item: ${ITEM_DB[state.hero.startItem].name}`);
}

function showMap() {
    ScreenManager.show('MAP');
}

function showHeroScreen() {
    ScreenManager.show('HERO_DETAIL');
}

function closeHeroScreen() {
    ScreenManager.show('MAP');
    saveGame();
}

function sellItem(index) {
    const item = state.inventory[index];
    const val = item.value || 0;
    
    state.gold += val;
    state.inventory.splice(index, 1);
    
    log(`Sold ${item.name} for ${val} Gold.`);
    EventManager.emit(EVENTS.HERO_UPDATED);
    EventManager.emit(EVENTS.INVENTORY_UPDATED);
}

function showDeckScreen() {
    ScreenManager.show('DECK_MANAGER');
}

function closeDeckScreen() {
    ScreenManager.show('MAP');
    saveGame();
}

function moveToCollection(index) {
    if (state.deck.length <= 10) {
        alert("Deck must have at least 10 cards!");
        return;
    }
    const card = state.deck.splice(index, 1)[0];
    state.collection.push(card);
    renderDeckManager();
}

function moveToDeck(index) {
    const card = state.collection.splice(index, 1)[0];
    state.deck.push(card);
    renderDeckManager();
}

function renderDeckManager() {
    const deckGrid = document.getElementById('manager-deck-grid');
    const colGrid = document.getElementById('manager-col-grid');
    
    document.getElementById('manager-deck-count').innerText = state.deck.length;
    document.getElementById('manager-col-count').innerText = state.collection.length;

    deckGrid.innerHTML = '';
    colGrid.innerHTML = '';

    // Render Active Deck
    state.deck.forEach((card, idx) => {
        let div = createCardElement(card);
        // Add click to remove
        div.onclick = () => moveToCollection(idx);
        // Add visual cue
        let hint = document.createElement('div');
        hint.innerText = "Click to Remove";
        hint.style = "position:absolute; bottom:2px; width:100%; text-align:center; font-size:8px; color:red; opacity:0.7;";
        div.appendChild(hint);
        deckGrid.appendChild(div);
    });

    // Render Collection
    state.collection.forEach((card, idx) => {
        let div = createCardElement(card);
        // Add click to add
        div.onclick = () => moveToDeck(idx);
        // Add visual cue
        let hint = document.createElement('div');
        hint.innerText = "Click to Add";
        hint.style = "position:absolute; bottom:2px; width:100%; text-align:center; font-size:8px; color:green; opacity:0.7;";
        div.appendChild(hint);
        colGrid.appendChild(div);
    });
}

function mapEquipItem(invIndex) {
    if (state.equipped.length >= 3) {
        alert("Slots full! Unequip something first.");
        return;
    }
    const item = state.inventory.splice(invIndex, 1)[0];
    state.equipped.push(item);
    
    // Apply HP Bonus immediately if exists
    if (item.hpBonus) {
        state.hero.maxHp += item.hpBonus;
        state.hero.hp += item.hpBonus;
    }

    if (item.apBonus) {
        state.hero.maxAp += item.apBonus;
    }
    
    EventManager.emit(EVENTS.HERO_UPDATED); // Stats might change (HP/AP bonus)
    EventManager.emit(EVENTS.INVENTORY_UPDATED);
}

function mapUnequipItem(equipIndex) {
    const item = state.equipped[equipIndex];

    // Revert HP Bonus
    if (item.hpBonus) {
        state.hero.maxHp -= item.hpBonus;
        state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
    }

    if (item.apBonus) {
        state.hero.maxAp -= item.apBonus;
    }

    state.equipped.splice(equipIndex, 1);
    state.inventory.push(item);
    EventManager.emit(EVENTS.HERO_UPDATED); // Stats might change (HP/AP bonus)
    EventManager.emit(EVENTS.INVENTORY_UPDATED);
}

function renderHeroScreen() {
    if(state.hero) {
        document.getElementById('hero-screen-name').innerText = state.hero.name;
        document.getElementById('hero-screen-hp').innerText = state.hero.hp;
        document.getElementById('hero-screen-max-hp').innerText = state.hero.maxHp;
        document.getElementById('hero-screen-gold').innerText = state.gold;
    }

    // 1. Render Equipped
    const equipContainer = document.getElementById('hero-screen-equipped');
    equipContainer.innerHTML = '';
    state.equipped.forEach((item, idx) => {
        let div = createCardElement(item);
        div.classList.add('equipped');
        
        // Click card to Unequip
        div.onclick = () => mapUnequipItem(idx);
        div.style.cursor = "pointer";
        div.title = "Click to Unequip";
        
        equipContainer.appendChild(div);
    });

    // 2. Render Inventory
    const invContainer = document.getElementById('hero-screen-inventory');
    invContainer.innerHTML = '';
    state.inventory.forEach((item, idx) => {
        // Create Wrapper for stacking
        let wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.flexDirection = 'column';
        wrapper.style.alignItems = 'center';
        wrapper.style.gap = '4px';

        // Render Card
        let div = createCardElement(item);
        div.style.borderTop = "5px solid #f1c40f"; 
        div.style.flex = "0 0 auto"; 
        div.onclick = () => mapEquipItem(idx);
        div.title = "Click to Equip";
        
        // Create Block Button below card
        let btn = document.createElement('button');
        btn.innerText = `Sell`;
        btn.style.fontSize = "10px";
        btn.style.padding = "4px";
        btn.style.background = "#27ae60";
        btn.style.color = "white";
        btn.style.border = "none";
        btn.style.borderRadius = "4px";
        btn.style.cursor = "pointer";
        btn.onclick = (e) => { 
            e.stopPropagation(); 
            sellItem(idx); 
        };

        wrapper.appendChild(div);
        wrapper.appendChild(btn);
        
        invContainer.appendChild(wrapper);
    });
    
    if (state.inventory.length === 0) invContainer.innerHTML = '<span style="font-style:italic; opacity:0.5;">Empty.</span>';
}

function isNodeAccessible(nodeId) {
    const node = MAP_GRAPH[nodeId];
    // Accessible if it has no parents OR if all parents are in completedNodes
    if (node.parents.length === 0) return true;
    return node.parents.every(parentId => state.completedNodes.includes(parentId));
}

// Map Dragging State
let mapState = {
    isDown: false,
    startX: 0,
    startY: 0,
    scrollLeft: 0,
    scrollTop: 0,
    isDragging: false // Distinguish click from drag
};

function initMapDrag() {
    const slider = document.getElementById('map-viewport');
    const content = document.getElementById('map-world');

    // Mouse Events
    slider.addEventListener('mousedown', (e) => {
        mapState.isDown = true;
        mapState.isDragging = false;
        mapState.startX = e.pageX - slider.offsetLeft;
        mapState.startY = e.pageY - slider.offsetTop;
        mapState.scrollLeft = slider.scrollLeft;
        mapState.scrollTop = slider.scrollTop;
    });

    slider.addEventListener('mouseleave', () => { mapState.isDown = false; });
    slider.addEventListener('mouseup', () => { 
        mapState.isDown = false; 
        setTimeout(() => mapState.isDragging = false, 50); 
    });

    slider.addEventListener('mousemove', (e) => {
        if (!mapState.isDown) return;
        e.preventDefault();
        mapState.isDragging = true;
        const x = e.pageX - slider.offsetLeft;
        const y = e.pageY - slider.offsetTop;
        const walkX = (x - mapState.startX);
        const walkY = (y - mapState.startY);
        slider.scrollLeft = mapState.scrollLeft - walkX;
        slider.scrollTop = mapState.scrollTop - walkY;
    });

    // Touch Events (Mobile)
    slider.addEventListener('touchstart', (e) => {
        mapState.isDown = true;
        mapState.isDragging = false;
        mapState.startX = e.touches[0].pageX - slider.offsetLeft;
        mapState.startY = e.touches[0].pageY - slider.offsetTop;
        mapState.scrollLeft = slider.scrollLeft;
        mapState.scrollTop = slider.scrollTop;
    });

    slider.addEventListener('touchend', () => { mapState.isDown = false; });

    slider.addEventListener('touchmove', (e) => {
        if (!mapState.isDown) return;
        mapState.isDragging = true;
        const x = e.touches[0].pageX - slider.offsetLeft;
        const y = e.touches[0].pageY - slider.offsetTop;
        const walkX = (x - mapState.startX);
        const walkY = (y - mapState.startY);
        slider.scrollLeft = mapState.scrollLeft - walkX;
        slider.scrollTop = mapState.scrollTop - walkY;
    });
}

function renderWorldMap() {
    const layer = document.getElementById('map-nodes-layer');
    const svgLayer = document.getElementById('map-lines');
    layer.innerHTML = '';
    svgLayer.innerHTML = '';

    // 1. Draw Lines (Parents -> Children)
    Object.values(MAP_GRAPH).forEach(node => {
        node.parents.forEach(parentId => {
            const parent = MAP_GRAPH[parentId];
            // Create SVG Line
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", parent.x);
            line.setAttribute("y1", parent.y);
            line.setAttribute("x2", node.x);
            line.setAttribute("y2", node.y);
            line.classList.add("map-connection");
            svgLayer.appendChild(line);
        });
    });

    // 2. Draw Nodes
    Object.values(MAP_GRAPH).forEach(node => {
        const isUnlocked = isNodeAccessible(node.id);
        const isCompleted = state.completedNodes.includes(node.id);
        
        const el = document.createElement('div');
        el.className = `map-node-visual`;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;

        const config = NODE_CONFIGS[node.type];
        // Logic for appearance/interaction
        if (isCompleted) {
            el.classList.add('completed');
            el.innerHTML = config.icon;
        } else if (isUnlocked) {
            el.classList.add('unlocked');
            el.innerHTML = config.icon;
        } else {
            el.classList.add('locked');
            el.innerHTML = "ðŸ”’";
        }

        // Allow entry if Unlocked OR Completed
        if (isUnlocked || isCompleted) {
             el.onclick = (e) => { 
                // Prevent drag from triggering click
                if(!mapState.isDragging) enterDungeonNode(node.id); 
            };
        }

        // Label
        const label = document.createElement('div');
        label.className = 'node-label';
        label.innerText = node.name;
        el.appendChild(label);

        layer.appendChild(el);
    });
}

function enterDungeonNode(nodeId) {
    const node = MAP_GRAPH[nodeId];
    
    state.currentNodeId = nodeId;
    state.tier = node.tier; // Still needed for buildDungeonTier logic
    
    state.dungeonDeck = buildDungeonFromConfig(node.type);
    state.adventureRow = [];
    state.turn = 1;

    // Reset Combat Stats (AP/Block)
    state.hero.ap = state.hero.maxAp;
    state.hero.block = 0;

    ScreenManager.show('GAME');

    drawCards(5);
    
    // Ensure at least one monster to start
    if (state.dungeonDeck.length > 0) {
        // Ensure first is not event
        if (state.dungeonDeck[0].type === CARD_TYPES.EVENT) {
             const safeIdx = state.dungeonDeck.findIndex(c => c.type === CARD_TYPES.MONSTER);
             if(safeIdx > -1) [state.dungeonDeck[0], state.dungeonDeck[safeIdx]] = [state.dungeonDeck[safeIdx], state.dungeonDeck[0]];
        }
        state.adventureRow.push(state.dungeonDeck.shift());
    }

    log(`Entered: ${node.name}`);
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function buildDungeonFromConfig(configKey) {
    let segment = [];
    const config = NODE_CONFIGS[configKey];
    if (!config) { console.error("Missing config:", configKey); return []; }

    // 1. Determine Length
    const cardCount = Math.floor(Math.random() * (config.maxCards - config.minCards + 1)) + config.minCards;

    // 2. Fill with Monsters & Events
    // Simple Logic: 70% Monster, 30% Event
    for(let i=0; i<cardCount; i++) {
        if (Math.random() > 0.3 || config.events.length === 0) {
            // Add Monster
            const mId = config.monsters[Math.floor(Math.random() * config.monsters.length)];
            segment.push({...MONSTER_DB[mId]});
        } else {
            // Add Event
            const eId = config.events[Math.floor(Math.random() * config.events.length)];
            segment.push({...EVENT_DB[eId]});
        }
    }

    shuffle(segment);

    // 3. Safety Check (No Event at start)
    if (segment.length > 0 && segment[0].type === CARD_TYPES.EVENT) {
        const safeIndex = segment.findIndex(c => c.type === CARD_TYPES.MONSTER);
        if (safeIndex !== -1) {
            [segment[0], segment[safeIndex]] = [segment[safeIndex], segment[0]];
        }
    }

    // 4. Add Boss
    if (config.bossPool && config.bossPool.length > 0) {
        const bId = config.bossPool[Math.floor(Math.random() * config.bossPool.length)];
        segment.push({...MONSTER_DB[bId]});
    }

    return segment;
}

/* --- ENGINE HELPERS --- */

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function drawCards(count) {
    for(let i=0; i<count; i++) {
        if(state.deck.length === 0) {
            if(state.discard.length === 0) break;
            state.deck = [...state.discard];
            state.discard = [];
            shuffle(state.deck);
            log("Deck reshuffled.");
        }
        state.hand.push(state.deck.pop());
    }
}

function spawnMonsters() {
    // Only add 1 card automatically at the start of the turn/refresh
    // Max size is now 5
    if(state.adventureRow.length < 5 && state.dungeonDeck.length > 0) {
        let card = state.dungeonDeck.shift(); 
        state.adventureRow.push(card);
    }
}

/* --- ACTIONS --- */

function exploreDungeon() {
    // Check Capacity (Max 5)
    if (state.adventureRow.length >= 5) {
        log("The path is too crowded.", "red");
        return;
    }
    
    // Check Empty Deck
    if (state.dungeonDeck.length === 0) {
        log("The dungeon is silent.", "red");
        return;
    }

    // Check for Events (Block exploration)
    const hasEvent = state.adventureRow.some(c => c.type === CARD_TYPES.EVENT);
    if (hasEvent) {
        log("You must resolve the Event before exploring further!", "red");
        return;
    }

    // Draw 1 card
    let card = state.dungeonDeck.shift();
    state.adventureRow.push(card);
    log("You explore deeper...");
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function selectCard(index) {
    // 1. Handle Deselection
    if (state.selectedCardIndex === index) {
        state.selectedCardIndex = -1;
        render();
        return;
    }

    // 2. Select the card
    state.selectedCardIndex = index;
    const card = state.hand[index];

    // Analyze Card Intent
    const hasEnemyEffect = card.type === CARD_TYPES.SKILL && card.effects && card.effects.some(e => e.target === 'ENEMY');

    // 3. Auto-Play: Self-Target (Loot or Pure Buffs)
    if (card.type === CARD_TYPES.LOOT || (card.type === CARD_TYPES.SKILL && !hasEnemyEffect)) {
        playCard('hero');
        return;
    }

    // 4. Auto-Play: Attack (If exactly 1 Monster is present)
    if (hasEnemyEffect) {
        const monsterIndices = state.adventureRow
            .map((c, i) => c.type === CARD_TYPES.MONSTER ? i : -1)
            .filter(i => i !== -1);

        if (monsterIndices.length === 1) {
            playCard(monsterIndices[0]);
            return;
        }
    }

    // 5. Manual Target Required (Highlight card)
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function playCard(target) {
    if (state.selectedCardIndex === -1) return;

    const card = state.hand[state.selectedCardIndex];
    
    if (card.type === CARD_TYPES.CURSE) {
        log("Cannot play Curses!", "red");
        return;
    }

    if (state.hero.ap < card.cost) {
        log("Not enough AP!", "red");
        return;
    }

    let success = false;

    if (card.effects) {
        // Validate Target for Hybrid Cards (e.g. if card has ANY enemy target effect, we need a valid target)
        const requiresEnemy = card.effects.some(e => e.target === 'ENEMY');
        
        if (requiresEnemy) {
            if (target === 'hero' || state.adventureRow[target].type !== CARD_TYPES.MONSTER) {
                log("Must target an enemy!", "red");
                return;
            }
        }

        // Execute Logic
        success = processEffects(card.effects, target);
    }

    if (success) {
        // 1. Pay Costs & Remove Card (Do this FIRST)
        state.hero.ap -= card.cost;
        const playedCard = state.hand.splice(state.selectedCardIndex, 1)[0];
        
        if (playedCard.type !== CARD_TYPES.LOOT) {
            state.discard.push(playedCard);
        }
        
        state.selectedCardIndex = -1;
        
        // 2. Trigger Item Passives
        state.equipped.forEach(item => {
            if(item.block) addBlock(item.block);
        });

        // 3. State Updated
        EventManager.emit(EVENTS.GAME_UPDATED);
        EventManager.emit(EVENTS.HERO_UPDATED); // In case block/stats changed

        // 4. Check for Auto-End Turn OR Dungeon Clear
        // We do this last so the card completely resolves before the state resets
        if (state.adventureRow.length === 0) {
            if (state.dungeonDeck.length === 0) {
                // ALL threats removed
                dungeonComplete();
            } else {
                // Just the current batch
                log("Zone cleared. Ending turn...", "#95a5a6");
                endTurn();
            }
            return;
        }

        // Check for No Options (0 AP and no 0-cost cards)
        const hasZeroCostCard = state.hand.some(c => c.cost === 0);
        if (state.hero.ap === 0 && !hasZeroCostCard) {
            log("Out of moves. Ending turn...", "#95a5a6");
            endTurn();
        }
    }
}

function processEffects(effects, targetIndex) {
    let success = false;

    effects.forEach(eff => {
        // TARGET VALIDATION
        if (eff.target === 'ENEMY') {
            // Check if target is valid enemy
            if (targetIndex === 'hero' || state.adventureRow[targetIndex].type !== CARD_TYPES.MONSTER) return;
            
            if (eff.type === 'DAMAGE') {
                dealDamage(targetIndex, eff.val);
                success = true;
            }
        }
        
        if (eff.target === 'SELF') {
            if (eff.type === 'BLOCK') addBlock(eff.val);
            if (eff.type === 'HEAL') healHero(eff.val);
            if (eff.type === 'GAIN_AP') { state.hero.ap += eff.val; log(`Gained ${eff.val} AP.`); }
            if (eff.type === 'DRAW') { drawCards(eff.val); log(`Drew ${eff.val} cards.`); }
            success = true; // Self effects always succeed if played
        }
    });

    return success;
}

// --- EVENT RESOLUTION ---
function resolveEventChoice(cardIndex, choiceIndex) {
    const eventCard = state.adventureRow[cardIndex];
    const choice = eventCard.choices[choiceIndex];

    log(`<span class="log-event">Event: ${choice.label}</span>`);

    // --- Original Events ---
    if (choice.effect === 'pray') {
        healHero(10);
        state.discard.push({...CURSE_CARD});
        log("You were healed, but cursed.");
        removeEvent();
    } 
    else if (choice.effect === 'fight') {
        spawnEventMonster('m_ghost');
    } 
    else if (choice.effect === 'leave') {
        log("You ignore it.");
        removeEvent();
    }
    
    // --- New Events ---
    
    // 1. Trap Door
    else if (choice.effect === 'trap_dmg') {
        state.hero.hp -= 5;
        log("You hit the ground hard. Took 5 DMG.", "red");
        removeEvent();
    }
    else if (choice.effect === 'trap_unequip') {
        if(state.equipped.length > 0) {
            const rIdx = Math.floor(Math.random() * state.equipped.length);
            const item = state.equipped[rIdx];
            
            // Revert Passive Stats
            if (item.hpBonus) {
                state.hero.maxHp -= item.hpBonus;
                state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
            }
            if (item.apBonus) {
                state.hero.maxAp -= item.apBonus;
            }

            // Move to inventory
            state.equipped.splice(rIdx, 1);
            state.inventory.push(item);
            
            log(`The fall knocked off your ${item.name}!`, "red");
            // Update UI to show item is gone
            EventManager.emit(EVENTS.GAME_UPDATED); 
            EventManager.emit(EVENTS.INVENTORY_UPDATED);
        } else {
            log("You stumbled, but had nothing equipped to lose.");
        }
        removeEvent();
    }

    // 2. Tribute
    else if (choice.effect === 'tribute_pay') {
        state.hero.maxHp -= 5;
        state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
        // Give a strong item
        let relic = { id: 'l_blood', name: 'Blood Gem', type: CARD_TYPES.LOOT, value: 5, atkBuff: 3, desc: '+3 DMG' };
        state.inventory.push(relic);
        log("You sacrificed vitality for power.");
        removeEvent();
    }

    // 3. Suspicious Chest
    else if (choice.effect === 'chest_open') {
        if(Math.random() > 0.5) {
            log("It's a trap! MIMIC!", "red");
            spawnEventMonster('m_mimic');
        } else {
            // Pick random skill from library
            const reward = rollLoot('chest_random');
            if(reward) {
                if(reward.type === CARD_TYPES.LOOT){
                    state.inventory.push(reward);
                } else {
                    state.collection.push(reward); // Or inventory if Loot
                }
                log(`You found: ${reward.name}!`);
            }
            removeEvent();
        }
    }

    // 4. Weapon Master
    else if (choice.effect === 'train_str') {
        let card = { id: 's_heavy', name: 'Heavy Strike', type: CARD_TYPES.SKILL, cost: 2, dmg: 10, desc: 'Deal 10 DMG' };
        state.collection.push(card);
        log("Learned Heavy Strike.");
        removeEvent();
    }
    else if (choice.effect === 'train_def') {
        let card = { id: 's_iron', name: 'Iron Skin', type: CARD_TYPES.SKILL, cost: 1, block: 8, desc: 'Gain 8 Block' };
        state.collection.push(card);
        log("Learned Iron Skin.");
        removeEvent();
    }

    // 5. Spring
    else if (choice.effect === 'spring_heal') {
        healHero(5);
        removeEvent();
    }
    else if (choice.effect === 'spring_max') {
        state.hero.maxHp += 1;
        log("You feel permanently stronger (+1 Max HP).", "green");
        removeEvent();
    }

    render();

    // Check for Auto-End Turn after event resolves
    if (state.adventureRow.length === 0) {
        log("Zone cleared. Ending turn...", "#95a5a6");
        endTurn();
    }

    // Helper to clear the event from the row
    function removeEvent() {
        state.adventureRow.splice(cardIndex, 1);
    }

    // Helper to swap event with monster
    function spawnEventMonster(id) {
        const monster = JSON.parse(JSON.stringify(MONSTER_DB[id] || EVENT_MONSTERS[id]));
        state.adventureRow[cardIndex] = monster;
        EventManager.emit(EVENTS.GAME_UPDATED);
    }
}

function equipItem(card) {
    state.equipped.push(card);
    log(`Equipped ${card.name}.`);
    if(card.hpBonus) {
        state.hero.maxHp += card.hpBonus;
        state.hero.hp += card.hpBonus;
        log(`Max HP increased by ${card.hpBonus}.`);
    }
}

function dealDamage(monsterIndex, amount) {
    let monster = state.adventureRow[monsterIndex];
    let bonus = 0;
    state.equipped.forEach(item => { if(item.atkBuff) bonus += item.atkBuff; });
    
    let totalDmg = amount + bonus;
    monster.hp -= totalDmg;
    
    log(`Hit ${monster.name} for <span class="log-dmg">${totalDmg}</span> dmg.`);

    if (monster.hp <= 0) {
        killMonster(monsterIndex);
    }
}

function killMonster(index) {
    let m = state.adventureRow[index];
    log(`${m.name} defeated!`);

    // Tier Transition
    if (m.isBoss) {
        log(`Boss Defeated!`, "gold");

        // Reward: Boss Relic & Heal
        if(Math.random() < 0.1){
            let reward = { id: 'l_boss_relic', name: 'Boss Relic', type: CARD_TYPES.LOOT, value: 10, atkBuff: 2, hpBonus: 5, desc: '+2 DMG & +5 Max HP' };
            state.inventory.push(reward);
            log(`Looted: ${reward.name}`, "#2ecc71");
        }
    } else {
        // Loot Chance scales with danger (number of OTHER monsters in the row)
        // Base: 10% + 10% per other monster. 
        // 0 others = 10%, 4 others = 50%
        const otherMonsters = state.adventureRow.filter((c, i) => i !== index && c.type === CARD_TYPES.MONSTER).length;
        const dropChance = 0.10 + (otherMonsters * 0.10);

        log(`Drop Chance: ${Math.floor(dropChance * 100)}%`, "#7f8c8d");

        if (Math.random() < dropChance) {
            if (m.lootTable) {
                const lootCard = rollLoot(m.lootTable);
                
                if (lootCard) {
                    if(lootCard.type === CARD_TYPES.LOOT){
                        state.inventory.push(lootCard);
                    } else {
                        state.collection.push(lootCard);
                    }
                    // Log with Rarity Color
                    const colors = { common: '#bdc3c7', rare: '#3498db', legendary: '#f1c40f' };
                    log(`Looted: <span style="color:${colors[lootCard.rarity]}">${lootCard.name}</span>`);
                    
                    // Emit updates (Pub/Sub pattern)
                    EventManager.emit(EVENTS.INVENTORY_UPDATED);
                }
            }
        } else {
            log("No loot found.");
        }
    }
    
    state.adventureRow.splice(index, 1);
}

function dungeonComplete() {
    // Standard Node Completion
    log("Dungeon Cleared!", "gold");
    
    // Mark Node as Complete
        if (state.currentNodeId && !state.completedNodes.includes(state.currentNodeId)) {
            state.completedNodes.push(state.currentNodeId);
            EventManager.emit(EVENTS.MAP_UPDATED);
        }

    // Delay slightly then go to map
    setTimeout(() => {
        log("Returning to Map...");
        continueGame(); // Reuses the logic to consolidate deck and show map
    }, 1500);
}

function continueGame() {
    document.getElementById('overlay').style.display = 'none';
    
    // Consolidate Deck (Hand/Discard -> Deck)
    while(state.hand.length > 0) state.deck.push(state.hand.pop());
    while(state.discard.length > 0) state.deck.push(state.discard.pop());
    
    state.adventureRow = [];
    
    ScreenManager.show('MAP');
}

function addBlock(amount) {
    state.hero.block += amount;
    log(`Gained ${amount} Block.`);
    EventManager.emit(EVENTS.HERO_UPDATED);
}

function healHero(amount) {
    state.hero.hp = Math.min(state.hero.maxHp, state.hero.hp + amount);
    log(`Healed for <span class="log-gain">${amount}</span> HP.`);
    EventManager.emit(EVENTS.HERO_UPDATED);
}

function endTurn() {
    log("--- Enemy Turn ---");
    
    state.adventureRow.forEach(m => {
        if(m.type === CARD_TYPES.EVENT) return;

        let dmg = m.atk;
        
        if (state.hero.block > 0) {
            if (state.hero.block >= dmg) {
                state.hero.block -= dmg;
                dmg = 0;
                log(`${m.name} attack blocked.`);
            } else {
                dmg -= state.hero.block;
                state.hero.block = 0;
                log(`${m.name} broke your shield!`);
            }
        }

        if (dmg > 0) {
            state.hero.hp -= dmg;
            log(`${m.name} deals <span class="log-dmg">${dmg}</span> damage!`);
        }
    });

    if (state.hero.hp <= 0) {
        gameOver();
        return;
    }

    state.hero.ap = state.hero.maxAp;
    state.hero.block = 0; 
    
    while(state.hand.length > 0) {
        state.discard.push(state.hand.pop());
    }

    drawCards(5);

    // If the row is completely empty (no monsters/events), the dungeon sends a new threat
    if (state.adventureRow.length === 0) {
        spawnMonsters();
    }

    state.turn++;
    state.selectedCardIndex = -1;
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function checkWinCondition() {}

function gameOver() {
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('overlay-title').innerText = "YOU DIED";
    document.getElementById('overlay-title').style.color = "red";
}

function log(msg, color) {
    const el = document.getElementById('log-console');
    let style = color ? `style="color:${color}"` : '';
    // Append to end, CSS flex-direction: column-reverse handles order
    el.innerHTML += `<div class="log-entry" ${style}>${msg}</div>`; 
    // Keep only last 4 messages to save space
    if (el.children.length > 4) {
        el.removeChild(el.children[0]);
    }
}

/* --- RENDERING --- */

function render() {
    // Hero Name
    document.getElementById('hero-name').innerText = state.hero.name;

    document.getElementById('hero-hp').innerText = state.hero.hp;
    document.getElementById('hero-max-hp').innerText = state.hero.maxHp;
    document.getElementById('hero-ap').innerText = state.hero.ap;
    document.getElementById('hero-max-ap').innerText = state.hero.maxAp;
    document.getElementById('hero-block').innerText = state.hero.block;
    
    document.getElementById('deck-count').innerText = state.deck.length;

    const advContainer = document.getElementById('adventure-row');
    
    // Check logic for button state
    const hasEvent = state.adventureRow.some(c => c.type === CARD_TYPES.EVENT);
    const isFull = state.adventureRow.length >= 5;
    const disabledAttr = (hasEvent || isFull || state.dungeonDeck.length === 0) ? 'disabled' : '';
    const btnColor = hasEvent ? '#e67e22' : '#7f8c8d'; // Visual cue

    advContainer.innerHTML = `
        <div class="area-label">
            Adventure Row
        </div>`;
    
    state.adventureRow.forEach((m, idx) => {
        let cardDiv = createCardElement(m, idx); 
        if(m.type === CARD_TYPES.MONSTER) {
            cardDiv.onclick = () => playCard(idx);
        }
        advContainer.appendChild(cardDiv);
    });

    // Hero
    const heroContainer = document.getElementById('hero-card-container');
    heroContainer.innerHTML = '';
    let heroCard = createCardElement(state.hero);
    heroCard.onclick = () => playCard('hero'); 
    heroContainer.appendChild(heroCard);

    const equipContainer = document.getElementById('equipment-slots');
    equipContainer.innerHTML = '';
    state.equipped.forEach((item) => {
        let div = createCardElement(item);
        div.classList.add('equipped');
        // No buttons here anymore
        equipContainer.appendChild(div);
    });

    // Hand
    const handContainer = document.getElementById('hand-row');
    handContainer.innerHTML = '<div class="area-label">Your Hand</div>';
    state.hand.forEach((card, idx) => {
        let div = createCardElement(card);
        div.onclick = (e) => {
            e.stopPropagation();
            selectCard(idx);
        };
        if (idx === state.selectedCardIndex) div.classList.add('selected');
        handContainer.appendChild(div);
    });
}

function createCardElement(data, index) {
    const div = document.createElement('div');
    div.classList.add('card');
    div.classList.add(`type-${data.type}`);
    
    let bodyHtml = '';
    let statsHtml = '';

    if (data.type === CARD_TYPES.MONSTER) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>âš”ï¸${data.atk}</span><span>â¤ï¸${data.hp}</span></div>`;
    } else if (data.type === CARD_TYPES.HERO) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>âš¡${data.ap}</span><span>â¤ï¸${data.hp}</span></div>`;
    } else if (data.type === CARD_TYPES.SKILL || data.type === CARD_TYPES.CURSE) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        
        // Generate mini-icons based on effects
        let icons = `<span>âš¡${data.cost}</span>`;
        if (data.effects) {
             data.effects.forEach(e => {
                 if(e.type === 'DAMAGE') icons += ` <span>âš”ï¸${e.val}</span>`;
                 if(e.type === 'BLOCK') icons += ` <span>ðŸ›¡ï¸${e.val}</span>`;
                 if(e.type === 'HEAL') icons += ` <span>ðŸ’š${e.val}</span>`;
             });
        }
        statsHtml = `<div class="card-stats">${icons}</div>`;
    } else if (data.type === CARD_TYPES.LOOT) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        // Display Gold Value
        let valDisplay = data.value ? `<span style="color:#f1c40f;">ðŸ’°${data.value}</span>` : '';
        statsHtml = `<div class="card-stats">${valDisplay}</div>`;
    } else if (data.type === CARD_TYPES.EVENT) {
        let buttons = '';
        if(data.choices) {
            data.choices.forEach((choice, choiceIdx) => {
                buttons += `<button class="choice-btn" onclick="event.stopPropagation(); resolveEventChoice(${index}, ${choiceIdx})">${choice.label}</button>`;
            });
        }
        bodyHtml = `<div class="card-desc">${data.desc}${buttons}</div>`;
    } else {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
    }

    div.innerHTML = `
        <div class="card-header">${data.name}</div>
        ${bodyHtml}
        ${statsHtml}
    `;
    return div;
}

function saveGame() {
    // Save the entire state object
    localStorage.setItem('vanguardSave', JSON.stringify(state));
}

function loadGame() {
    const save = localStorage.getItem('vanguardSave');
    if (save) {
        try {
            state = JSON.parse(save);
            
            // If loaded, skip selection and go to Map
            // We reset the "run" state (hand/row) to ensure a clean load on the map
            state.hand = [];
            state.discard = [];
            state.adventureRow = []; 
            // Ensure deck is consolidated if we crashed mid-run
            if (state.deck.length < 10) { 
                // If deck is empty (cards in hand/discard), we might need to rebuild logic or just reset deck
                // For safety in this prototype, we assume saving happens mostly on Map
            }
            
            ScreenManager.show('MAP');
            log("Game Loaded.");
            return true;
        } catch (e) {
            console.error("Save file corrupted", e);
            return false;
        }
    }
    return false;
}

function resetProgress() {
    if(confirm("Are you sure? This will wipe all progress.")) {
        localStorage.removeItem('vanguardSave');
        location.reload();
    }
}

// Init Event System
initUIListeners();

// Start Game
if (!loadGame()) {
    initSelectionScreen();
}

</script>
</body>
</html>