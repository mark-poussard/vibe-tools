<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanguard of the Void</title>
    <style>
        :root {
            --bg-color: #202c39;
            --card-bg: #ecf0f1;
            --text-color: #2c3e50;
            --highlight: #f1c40f;
            --monster-color: #e74c3c;
            --skill-color: #3498db;
            --loot-color: #2ecc71;
            --hero-color: #9b59b6;
            --event-color: #e67e22;
            --curse-color: #7f8c8d;
            --ui-panel: rgba(0,0,0,0.4);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            padding: 0;
            height: 100dvh; /* Dynamic Viewport Height for mobile */
            overflow: hidden;
            font-size: 14px;
        }

        /* --- Common Layouts --- */
        .screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }

        h1 { margin: 10px 0; font-size: 24px; text-align: center; }
        button {
            padding: 12px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        button:active { transform: scale(0.98); }

        /* --- Game Screen Grid --- */
        #game-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 5px;
            display: none; /* Controlled by JS */
        }

        /* Stats Bar (Compact) */
        #stats-bar {
            background: var(--ui-panel);
            padding: 8px;
            border-radius: 8px;
            font-size: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        .stat-row { display: flex; justify-content: space-between; }

        /* Scrollable Card Rows (The key to mobile layout) */
        .scroll-row {
            display: flex;
            gap: 8px;
            padding: 5px 2px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch; /* Smooth scroll iOS */
            min-height: 135px; /* Fits card height */
            align-items: center;
        }
        /* Hide scrollbar but keep functionality */
        .scroll-row::-webkit-scrollbar { display: none; }

        #adventure-row {
            background: rgba(231, 76, 60, 0.05);
            border-top: 2px solid var(--monster-color);
            border-bottom: 2px solid var(--monster-color);
        }

        #hand-row {
            background: rgba(52, 152, 219, 0.05);
            border-top: 2px solid var(--skill-color);
            margin-top: auto; /* Push to bottom */
            margin-bottom: 5px;
        }

        .area-label {
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.7;
            margin-left: 5px;
            margin-bottom: -5px;
            z-index: 1;
        }

        /* Hero Area (Middle) */
        #hero-area {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            flex-grow: 1;
            min-height: 100px;
        }
        #hero-card-container { transform: scale(0.9); transform-origin: left center; }
        #equipment-slots { display: flex; gap: 4px; overflow-x: auto; }
        
        #end-turn-container {
            margin-left: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #end-turn-btn {
            background: var(--monster-color);
            color: white;
            width: 80px;
            height: 60px;
            font-size: 12px;
            line-height: 1.2;
            white-space: pre-wrap;
        }

        /* --- Cards (Mobile Optimized) --- */
        .card {
            flex: 0 0 85px; /* Fixed width, no shrinking/growing */
            width: 85px;
            height: 120px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            position: relative;
            font-size: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            user-select: none;
        }

        .card-header {
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 10px;
            margin-bottom: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid #bdc3c7;
        }

        .card-desc {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 9px;
            line-height: 1.1;
            overflow: hidden;
        }
        
        .card-stats {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 11px;
            margin-top: 2px;
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
            padding: 2px;
        }

        /* Card Types Borders */
        .type-monster { border-bottom: 4px solid var(--monster-color); }
        .type-skill { border-bottom: 4px solid var(--skill-color); }
        .type-loot { border-bottom: 4px solid var(--loot-color); }
        .type-event { border-bottom: 4px solid var(--event-color); }
        .type-curse { border-bottom: 4px solid var(--curse-color); background: #bdc3c7; }
        .type-hero { border: 2px solid var(--hero-color); width: 90px; height: 120px; }

        .card.selected { border: 2px solid var(--highlight); transform: translateY(-10px); }
        .card.equipped { width: 50px; height: 70px; font-size: 8px; flex: 0 0 50px; }

        /* Buttons on cards */
        .choice-btn { font-size: 8px; padding: 4px; width: 100%; margin-top: 2px; }
        .destroy-btn { width: 20px; height: 20px; font-size: 12px; }

        /* --- Map & Menus --- */
        #map-screen, #hero-selection, #hero-screen, #deck-screen {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
        }

        /* Draggable Map Styles */
        #map-screen { padding: 0; overflow: hidden; position: relative; background: #1a1a1a; }
        
        #map-viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            position: relative;
        }
        
        #map-viewport:active { cursor: grabbing; }

        #map-world {
            width: 1200px; /* Large virtual canvas */
            height: 800px;
            position: absolute;
            top: 0; left: 0;
            transform-origin: 0 0;
            background-image: radial-gradient(#34495e 1px, transparent 1px);
            background-size: 20px 20px; /* Grid pattern */
        }

        .map-node-visual {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #7f8c8d;
            background: #2c3e50;
            color: white;
            font-weight: bold;
            font-size: 18px;
            z-index: 5;
            transition: transform 0.2s, border-color 0.2s;
            /* Center the circle on the coord */
            transform: translate(-50%, -50%);
        }

        .map-node-visual.locked { opacity: 0.6; filter: grayscale(1); }
        .map-node-visual.unlocked { border-color: var(--highlight); background: #27ae60; cursor: pointer; box-shadow: 0 0 15px var(--highlight); animation: pulse 2s infinite; }
        .map-node-visual.completed { border-color: gold; background: #e67e22; cursor: default; }

        .map-node-visual:hover.unlocked { transform: translate(-50%, -50%) scale(1.1); }

        .node-label {
            position: absolute;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }

        /* SVG Connections Layer */
        #map-lines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        .map-connection {
            stroke: #7f8c8d;
            stroke-width: 4;
            opacity: 0.5;
        }

        /* UI Overlay Layer */
        .map-ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to map */
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .map-ui-overlay button { pointer-events: auto; } /* Re-enable buttons */

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }

        .deck-manager-container {
            display: flex;
            flex-direction: column; /* Vertical stack */
            gap: 10px;
            flex: 1; /* Fill remaining screen height */
            overflow: hidden; /* Prevent container scroll */
            margin-top: 10px;
            min-height: 0; /* Flexbox nesting fix */
        }
        .deck-column {
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.2);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            padding: 5px;
            min-height: 0; /* Allow shrinking */
        }
        .deck-column h2 { 
            text-align: center; margin: 5px 0; font-size: 14px; color: var(--highlight); 
            flex-shrink: 0; 
        }
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            overflow-y: auto; /* Individual area scroll */
            flex: 1; /* Fill column space */
            padding: 5px;
        }

        /* Grids for managers */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            padding-bottom: 20px;
        }

        /* Log (Mini Overlay) */
        #log-console {
            height: 40px;
            font-size: 10px;
            background: rgba(0,0,0,0.6);
            position: absolute;
            bottom: 150px; /* Above hand */
            left: 10px;
            right: 10px;
            pointer-events: none;
            padding: 5px;
            border-radius: 4px;
            z-index: 10;
            display: flex;
            flex-direction: column-reverse; /* Newest at bottom */
        }

        /* Overlay */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body>

<!-- Hero Selection Screen -->
<div id="hero-selection">
    <h1>Choose Your Hero</h1>
    <div class="hero-select-container" id="hero-select-container">
        <!-- Hero cards injected here -->
    </div>
</div>
    
<!-- Map Screen -->
<div id="map-screen">
    <!-- 1. The Moving World -->
    <div id="map-viewport">
        <div id="map-world">
            <svg id="map-lines"></svg>
            <div id="map-nodes-layer"></div>
        </div>
    </div>

    <!-- 2. Fixed UI Overlay -->
    <div class="map-ui-overlay">
        <!-- Top Bar -->
        <div style="display:flex; justify-content: space-between; align-items: start;">
            <div style="background:rgba(0,0,0,0.6); padding:5px; border-radius:4px;">
                <h1 style="font-size:16px; margin:0;">World Map</h1>
            </div>
            <div style="display:flex; flex-direction: column; gap:5px;">
                <button onclick="showHeroScreen()" style="background-color: var(--hero-color);">Hero</button>
                <button onclick="showDeckScreen()" style="background-color: var(--skill-color);">Deck</button>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div style="display:flex; justify-content: flex-end;">
            <button onclick="resetProgress()" style="background-color: #c0392b; font-size: 10px; padding: 5px;">Reset Save</button>
        </div>
    </div>
</div>

<!-- Hero / Inventory Screen -->
<div id="hero-screen">
    <div style="display:flex; justify-content:space-between; align-items:center; width:100%; max-width:600px;">
        <h1>Hero Details</h1>
        <button onclick="closeHeroScreen()">Back to Map</button>
    </div>

    <div class="hero-panel">
        <!-- Stats -->
        <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #fff; padding-bottom:10px;">
            <strong style="color:var(--hero-color); font-size:1.5em;"><span id="hero-screen-name">Hero</span></strong>
            <div style="text-align:right;">
                <strong style="color:#f1c40f; font-size:1.2em; margin-right:15px;">Gold: <span id="hero-screen-gold">0</span></strong>
                <strong style="color:var(--monster-color); font-size:1.2em;">HP: <span id="hero-screen-hp">0</span>/<span id="hero-screen-max-hp">0</span></strong>
            </div>
        </div>

        <!-- Equipped -->
        <div>
            <div style="font-size:1em; margin-bottom:10px; color:var(--loot-color);">Equipped Items (Click to Unequip):</div>
            <div id="hero-screen-equipped" style="display:flex; gap:10px; min-height:100px; align-items:center; background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;"></div>
        </div>

        <!-- Inventory -->
        <div style="flex-grow: 1; overflow-y: auto;">
            <div style="font-size:1em; margin-bottom:10px; color:var(--highlight); position: sticky; top:0; background: var(--bg-color); padding: 5px;">Inventory</div>
            <div id="hero-screen-inventory" class="card-grid" style="background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;"></div>
        </div>
    </div>
</div>

<!-- Deck Management Screen -->
<div id="deck-screen">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1>Deck Manager</h1>
        <button onclick="closeDeckScreen()">Back to Map</button>
    </div>
    <div class="deck-manager-container">
        <!-- Active Deck (Fixed max height to 40% of screen) -->
        <div class="deck-column" style="flex: 0 0 40%;">
            <h2>Deck (<span id="manager-deck-count">0</span>)</h2>
            <div id="manager-deck-grid" class="card-grid"></div>
        </div>
        <!-- Collection (Takes remaining space) -->
        <div class="deck-column" style="flex: 1;">
            <h2>Collection (<span id="manager-col-count">0</span>)</h2>
            <div id="manager-col-grid" class="card-grid"></div>
        </div>
    </div>
</div>

<!-- Game Overlay (Win/Loss) -->
<div id="overlay">
    <h1 id="overlay-title">Game Over</h1>
    <button onclick="location.reload()">Play Again</button>
</div>

<!-- Main Game Interface -->
<div id="game-container">
    
    <!-- Top: Compact Stats -->
    <div id="stats-bar">
        <div class="stat-row">
            <strong style="color:var(--hero-color)"><span id="hero-name">Hero</span></strong>
            <strong style="color:var(--monster-color)">HP: <span id="hero-hp">0</span>/<span id="hero-max-hp">0</span></strong>
        </div>
        <div class="stat-row">
            <strong style="color:var(--highlight)">AP: <span id="hero-ap">0</span>/<span id="hero-max-ap">0</span></strong>
            <strong style="color:var(--skill-color)">Blk: <span id="hero-block">0</span></strong>
            <span>Deck:<span id="deck-count">0</span></span>
        </div>
    </div>

    <!-- Row 2: Adventure (Scrollable) -->
    <div class="area-label">
        Adventure 
        <button id="explore-btn" style="font-size:9px; padding:2px 6px;" onclick="exploreDungeon()">+ Explore</button>
    </div>
    <div id="adventure-row" class="scroll-row">
        <!-- Monsters injected here -->
    </div>

    <!-- Row 3: Hero & Equip -->
    <div id="hero-area">
        <div id="hero-card-container">
            <!-- Hero Card -->
        </div>
        <div style="flex-grow:1; overflow:hidden;">
            <div class="area-label" style="margin-bottom:2px;">Equipped</div>
            <div id="equipment-slots">
                <!-- Equipped Items -->
            </div>
        </div>
        <div id="end-turn-container">
            <button id="end-turn-btn" onclick="endTurn()">END<br>TURN</button>
        </div>
    </div>

    <!-- Log Overlay -->
    <div id="log-console"></div>

    <!-- Row 4: Hand (Scrollable, fixed bottom) -->
    <div class="area-label">Hand</div>
    <div id="hand-row" class="scroll-row">
        <!-- Hand cards -->
    </div>

</div>

<script>
/* --- GAME DATA --- */

const CARD_TYPES = {
    HERO: 'hero',
    MONSTER: 'monster',
    SKILL: 'skill',
    LOOT: 'loot',
    EVENT: 'event',
    CURSE: 'curse'
};

// Define starting items for heroes
const STARTING_ITEMS = {
    'i_shield': { id: 'i_shield', name: 'Buckler', type: CARD_TYPES.LOOT, block: 1, value: 5, desc: '+1 Block on Play' }, // Logic simulation
    'i_cloak': { id: 'i_cloak', name: 'Cloak', type: CARD_TYPES.LOOT, apBonus: 1, value: 5, desc: '+1 AP' },
    'i_wand': { id: 'i_wand', name: 'Ember', type: CARD_TYPES.LOOT, atkBuff: 1, value: 5, desc: '+1 DMG' }
};

const HEROES = [
    { 
        id: 'h_ironclad', 
        name: 'Ironclad', 
        type: CARD_TYPES.HERO, 
        hp: 30, maxHp: 30, 
        ap: 2, maxAp: 2, 
        block: 0, 
        desc: 'Tanky. Starts with Shield.',
        startItem: 'i_shield'
    },
    { 
        id: 'h_shadow', 
        name: 'Shadow', 
        type: CARD_TYPES.HERO, 
        hp: 25, maxHp: 25, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Agile. Acts fast.',
        startItem: 'i_cloak'
    },
    { 
        id: 'h_weaver', 
        name: 'Weaver', 
        type: CARD_TYPES.HERO, 
        hp: 20, maxHp: 20, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Fragile. Powerful spells.',
        startItem: 'i_wand'
    }
];

const BASE_STRIKE = { id: 's1', name: 'Strike', type: CARD_TYPES.SKILL, cost: 1, dmg: 3, desc: 'Deal 3 DMG' };
const BASE_DEFEND = { id: 's2', name: 'Defend', type: CARD_TYPES.SKILL, cost: 1, block: 3, desc: 'Gain 3 Block' };

const HERO_DECKS = {
    'h_ironclad': [
        BASE_STRIKE, BASE_STRIKE, BASE_STRIKE, BASE_STRIKE, BASE_STRIKE,
        BASE_DEFEND, BASE_DEFEND, BASE_DEFEND, BASE_DEFEND,
        { id: 's_bash', name: 'Shield Bash', type: CARD_TYPES.SKILL, cost: 2, dmg: 5, block: 5, desc: '5 DMG & 5 Block' }
    ],
    'h_shadow': [
        BASE_STRIKE, BASE_STRIKE, BASE_STRIKE, BASE_STRIKE, BASE_STRIKE,
        BASE_DEFEND, BASE_DEFEND, BASE_DEFEND, BASE_DEFEND,
        { id: 's_fast', name: 'Fast Hands', type: CARD_TYPES.SKILL, cost: 0, draw: 2, desc: 'Draw 2 cards' }
    ],
    'h_weaver': [
        BASE_STRIKE, BASE_STRIKE, BASE_STRIKE, BASE_STRIKE, BASE_STRIKE,
        BASE_DEFEND, BASE_DEFEND, BASE_DEFEND, BASE_DEFEND,
        { id: 's_bolt', name: 'Dark Bolt', type: CARD_TYPES.SKILL, cost: 2, dmg: 12, desc: 'Massive DMG' }
    ]
};

const SKILL_LIBRARY = [
    { id: 's_mend', name: 'Mend', type: CARD_TYPES.SKILL, cost: 1, heal: 4, desc: 'Heal 4 HP' },
    { id: 's_rush', name: 'Adrenaline', type: CARD_TYPES.SKILL, cost: 0, gainAp: 2, desc: 'Gain 2 AP' },
    { id: 's_bash', name: 'Shield Bash', type: CARD_TYPES.SKILL, cost: 2, dmg: 5, block: 5, desc: '5 DMG & 5 Block' },
    { id: 's_exec', name: 'Execution', type: CARD_TYPES.SKILL, cost: 3, dmg: 15, desc: 'Deal 15 DMG' },
    { id: 's_step', name: 'Quick Step', type: CARD_TYPES.SKILL, cost: 0, block: 2, desc: 'Gain 2 Block' },
    { id: 's_wall', name: 'Heavy Plate', type: CARD_TYPES.SKILL, cost: 2, block: 10, desc: 'Gain 10 Block' },
    { id: 's_shiv', name: 'Shiv', type: CARD_TYPES.SKILL, cost: 0, dmg: 3, desc: '0 Cost Attack' },
    { id: 's_wild', name: 'Reckless Swing', type: CARD_TYPES.SKILL, cost: 1, dmg: 8, desc: 'Deal 8 DMG' },
    { id: 's_holy', name: 'Holy Light', type: CARD_TYPES.SKILL, cost: 2, heal: 8, desc: 'Heal 8 HP' },
    { id: 's_perf', name: 'Perfect Guard', type: CARD_TYPES.SKILL, cost: 3, block: 20, desc: 'Gain 20 Block' }
];

const CURSE_CARD = { id: 'c_fatigue', name: 'Fatigue', type: CARD_TYPES.CURSE, cost: 1, desc: 'Unplayable trash.' };

const REWARDS = {
    'm_goblin': { id: 'l_dagger', name: 'Dagger', type: CARD_TYPES.LOOT, value: 1, atkBuff: 1, desc: '+1 DMG' },
    'm_rat': { id: 's_bite', name: 'Rabid Bite', type: CARD_TYPES.SKILL, cost: 0, dmg: 2, desc: '0 Cost Attack' },
    'm_orc': { id: 's_smash', name: 'Big Smash', type: CARD_TYPES.SKILL, cost: 2, dmg: 8, desc: 'Heavy DMG' },
    'm_ghost': { id: 'l_amulet', name: 'Ghost Amulet', type: CARD_TYPES.LOOT, value: 2, atkBuff: 2, desc: '+2 DMG' }, 
    'm_slime': { id: 'l_goo', name: 'Slime Shield', type: CARD_TYPES.LOOT, value: 2, block: 2, desc: '+2 Block on Play' },
    'm_kobold': { id: 'l_spear', name: 'Short Spear', type: CARD_TYPES.LOOT, value: 2, atkBuff: 2, desc: '+2 DMG' },
    'm_spider': { id: 's_web', name: 'Web Shot', type: CARD_TYPES.SKILL, cost: 1, dmg: 5, desc: 'Sticky Shot' },
    'm_wolf': { id: 's_claw', name: 'Feral Claw', type: CARD_TYPES.SKILL, cost: 0, dmg: 3, desc: 'Fast Attack' },
    'm_cultist': { id: 's_bolt', name: 'Dark Bolt', type: CARD_TYPES.SKILL, cost: 2, dmg: 12, desc: 'Massive DMG' },
    'm_golem': { id: 's_stone', name: 'Stone Form', type: CARD_TYPES.SKILL, cost: 2, block: 15, desc: 'Huge Block' },
    'm_assassin': { id: 'l_cloak', name: 'Shadow Cloak', type: CARD_TYPES.LOOT, value: 1, block: 1, desc: '+1 Block on Play' },
    'm_ent': { id: 'l_bark', name: 'Bark Skin', type: CARD_TYPES.LOOT, value: 5, hpBonus: 5, desc: '+5 Max HP' },
    'm_leech': { id: 's_drain', name: 'Void Spike', type: CARD_TYPES.SKILL, cost: 1, dmg: 6, desc: 'Piercing Strike' },
    'm_drake': { id: 'l_scale', name: 'Dragon Scale', type: CARD_TYPES.LOOT, value: 5, block: 3, desc: '+3 Block on Play' },

    'm_boss': { id: 'w_win', name: 'Victory', type: CARD_TYPES.EVENT, desc: 'You Won!' }
};

const EVENT_MONSTERS = {
    'm_ghost': { id: 'm_ghost', name: 'Vengeful Spirit', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 4, rewardId: 'm_ghost', desc: 'Hit by Physical' },
    'm_mimic': { id: 'm_mimic', name: 'Mimic', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 5, rewardId: 'm_goblin', desc: 'It has teeth!' }
};

// --- TIERED DATA ---

const COMMON_EVENTS = [
    { 
        id: 'e_shrine', name: 'Cursed Shrine', type: CARD_TYPES.EVENT, desc: 'A dark aura hums.',
        choices: [
            { label: 'Pray (Heal 10, Get Curse)', effect: 'pray' },
            { label: 'Desecrate (Fight Spirit)', effect: 'fight' },
            { label: 'Ignore (Leave)', effect: 'leave' }
        ]
    },
    {
        id: 'e_trap', name: 'Trap Door', type: CARD_TYPES.EVENT, desc: 'The floor crumbles!',
        choices: [
            { label: 'Jump (Unequip Random Item)', effect: 'trap_unequip' },
            { label: 'Brace (Take 5 DMG)', effect: 'trap_dmg' }
        ]
    },
    {
        id: 'e_chest', name: 'Wooden Chest', type: CARD_TYPES.EVENT, desc: 'Is it breathing?',
        choices: [
            { label: 'Open (Loot or Mimic)', effect: 'chest_open' },
            { label: 'Leave', effect: 'leave' }
        ]
    }
];

const MAP_GRAPH = {
    // x/y are pixels relative to the map-world container
    'node_caverns': { id: 'node_caverns', name: 'The Caverns', tier: 1, parents: [], x: 150, y: 300 },
    'node_dark':    { id: 'node_dark',    name: 'The Deep Dark', tier: 2, parents: ['node_caverns'], x: 400, y: 150 },
    'node_void':    { id: 'node_void',    name: 'The Void',      tier: 3, parents: ['node_dark'], x: 650, y: 300 }
};

const TIER_POOLS = {
    1: [ // The Caverns
        { id: 'm_goblin', name: 'Goblin', type: CARD_TYPES.MONSTER, hp: 4, maxHp: 4, atk: 2, rewardId: 'm_goblin', desc: 'Reward: Dagger' },
        { id: 'm_rat', name: 'Giant Rat', type: CARD_TYPES.MONSTER, hp: 3, maxHp: 3, atk: 3, rewardId: 'm_rat', desc: 'Reward: Bite' },
        { id: 'm_slime', name: 'Acid Slime', type: CARD_TYPES.MONSTER, hp: 5, maxHp: 5, atk: 1, rewardId: 'm_slime', desc: 'Weak & Sticky' },
        { id: 'm_kobold', name: 'Kobold Scout', type: CARD_TYPES.MONSTER, hp: 6, maxHp: 6, atk: 3, rewardId: 'm_kobold', desc: 'Pointy Spear' }
    ],
    2: [ // The Deep Dark
        { id: 'm_orc', name: 'Orc', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 4, rewardId: 'm_orc', desc: 'Reward: Smash' },
        { id: 'm_spider', name: 'Cave Spider', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 2, rewardId: 'm_spider', desc: 'Reward: Web' },
        { id: 'm_wolf', name: 'Dire Wolf', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 3, rewardId: 'm_wolf', desc: 'Fast Biter' },
        { id: 'm_cultist', name: 'Dark Cultist', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 5, rewardId: 'm_cultist', desc: 'Glass Cannon' }
    ],
    3: [ // The Void
        { id: 'm_golem', name: 'Stone Golem', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 2, rewardId: 'm_golem', desc: 'High HP Tank' },
        { id: 'm_assassin', name: 'Void Assassin', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 6, rewardId: 'm_assassin', desc: 'High Damage!' },
        { id: 'm_ent', name: 'Rotting Ent', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 3, rewardId: 'm_ent', desc: 'Ancient Wood' },
        { id: 'm_drake', name: 'Baby Drake', type: CARD_TYPES.MONSTER, hp: 18, maxHp: 18, atk: 5, rewardId: 'm_drake', desc: 'Fierce!' }
    ]
};

const MINI_BOSSES = {
    1: [ // Gatekeepers to Tier 2
        { id: 'mb_troll', name: 'Cave Troll', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 4, isMiniBoss: true, desc: 'BOSS: Gatekeeper' },
        { id: 'mb_brood', name: 'Broodmother', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 5, isMiniBoss: true, desc: 'BOSS: Gatekeeper' }
    ],
    2: [ // Gatekeepers to Tier 3
        { id: 'mb_lich', name: 'Elder Lich', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 5, isMiniBoss: true, desc: 'BOSS: Gatekeeper' },
        { id: 'mb_knight', name: 'Void Knight', type: CARD_TYPES.MONSTER, hp: 30, maxHp: 30, atk: 4, isMiniBoss: true, desc: 'BOSS: Gatekeeper' }
    ]
};

const FINAL_BOSS = { id: 'm_boss', name: 'MALAKOR', type: CARD_TYPES.MONSTER, hp: 60, maxHp: 60, atk: 7, rewardId: 'm_boss', desc: 'FINAL BOSS' };

/* --- STATE --- */

let state = {
    hero: null,
    deck: [],
    hand: [],
    discard: [],
    dungeonDeck: [],
    adventureRow: [], 
    equipped: [],
    selectedCardIndex: -1,
    turn: 1,
    completedNodes: [], // Array of node IDs (e.g. ['node_caverns'])
    currentNodeId: null, // The node currently being played
    collection: [], // Cards removed from deck
    inventory: [],
    gold: 0
};

/* --- STARTUP LOGIC --- */

function initSelectionScreen() {
    switchScreen('hero-selection');
    const container = document.getElementById('hero-select-container');
    HEROES.forEach((hero, index) => {
        // Create a card for the hero
        let div = createCardElement(hero);
        div.onclick = () => startGame(index);
        // Add a "Select" label
        let label = document.createElement('div');
        label.innerHTML = "<br><strong>CLICK TO SELECT</strong>";
        label.style.textAlign = "center";
        label.style.fontSize = "10px";
        div.appendChild(label);
        container.appendChild(div);
    });
}

function startGame(heroIndex) {
    // Switch UI
    document.getElementById('hero-selection').style.display = 'none';
    document.getElementById('game-container').style.display = 'flex';

    // Initialize State
    state.hero = JSON.parse(JSON.stringify(HEROES[heroIndex]));
    // Load unique hero deck
    state.deck = JSON.parse(JSON.stringify(HERO_DECKS[state.hero.id]));
    
    // Hand/Discard reset
    state.hand = [];
    state.discard = [];
    state.equipped = [];
    
    // Start Item Logic
    state.equipped = [];
    if(state.hero.startItem) {
        let item = STARTING_ITEMS[state.hero.startItem];
        // If item gives HP bonus immediately
        if(item.hpBonus) {
            state.hero.maxHp += item.hpBonus;
            state.hero.hp += item.hpBonus;
        }
        // We push deep copy to equipped
        state.equipped.push(JSON.parse(JSON.stringify(item)));
    }

    // Setup Deck
    shuffle(state.deck);
    
    // Go to Map
    switchScreen('map-screen');
    showMap(); 
    saveGame();

    log(`You selected ${state.hero.name}. The void awaits.`);
    if(state.hero.startItem) log(`Equipped starting item: ${STARTING_ITEMS[state.hero.startItem].name}`);
}

function showMap() {
    switchScreen('map-screen');
    document.getElementById('overlay').style.display = 'none';

    // Render Graph
    renderWorldMap();
    saveGame();

    // Init Drag Logic (Call once or check if init)
    if (!mapState.initialized) {
        initMapDrag();
        mapState.initialized = true;
        
        // Center view on first node initially
        const viewport = document.getElementById('map-viewport');
        viewport.scrollLeft = 0; // Or specific offset
    }
}

function showHeroScreen() {
    switchScreen('hero-screen');
    renderHeroScreen();
}

function closeHeroScreen() {
    document.getElementById('hero-screen').style.display = 'none';
    document.getElementById('map-screen').style.display = 'flex';
    saveGame();
}

function sellItem(index) {
    const item = state.inventory[index];
    const val = item.value || 0;
    
    state.gold += val;
    state.inventory.splice(index, 1);
    
    log(`Sold ${item.name} for ${val} Gold.`); // Logs to console if visible, or just updates state
    renderHeroScreen();
}

function showDeckScreen() {
    switchScreen('deck-screen');

    // Consolidate all cards into state.deck for management
    // (In case we came from a run where cards were in discard)
    state.deck = state.deck.concat(state.discard);
    state.discard = [];
    state.hand = []; // Should be empty from map logic, but safety first

    renderDeckManager();
}

function closeDeckScreen() {
    document.getElementById('deck-screen').style.display = 'none';
    document.getElementById('map-screen').style.display = 'flex';

    saveGame();
}

function moveToCollection(index) {
    if (state.deck.length <= 10) {
        alert("Deck must have at least 10 cards!");
        return;
    }
    const card = state.deck.splice(index, 1)[0];
    state.collection.push(card);
    renderDeckManager();
}

function moveToDeck(index) {
    const card = state.collection.splice(index, 1)[0];
    state.deck.push(card);
    renderDeckManager();
}

function renderDeckManager() {
    const deckGrid = document.getElementById('manager-deck-grid');
    const colGrid = document.getElementById('manager-col-grid');
    
    document.getElementById('manager-deck-count').innerText = state.deck.length;
    document.getElementById('manager-col-count').innerText = state.collection.length;

    deckGrid.innerHTML = '';
    colGrid.innerHTML = '';

    // Render Active Deck
    state.deck.forEach((card, idx) => {
        let div = createCardElement(card);
        // Add click to remove
        div.onclick = () => moveToCollection(idx);
        // Add visual cue
        let hint = document.createElement('div');
        hint.innerText = "Click to Remove";
        hint.style = "position:absolute; bottom:2px; width:100%; text-align:center; font-size:8px; color:red; opacity:0.7;";
        div.appendChild(hint);
        deckGrid.appendChild(div);
    });

    // Render Collection
    state.collection.forEach((card, idx) => {
        let div = createCardElement(card);
        // Add click to add
        div.onclick = () => moveToDeck(idx);
        // Add visual cue
        let hint = document.createElement('div');
        hint.innerText = "Click to Add";
        hint.style = "position:absolute; bottom:2px; width:100%; text-align:center; font-size:8px; color:green; opacity:0.7;";
        div.appendChild(hint);
        colGrid.appendChild(div);
    });
}

function mapEquipItem(invIndex) {
    if (state.equipped.length >= 3) {
        alert("Slots full! Unequip something first.");
        return;
    }
    const item = state.inventory.splice(invIndex, 1)[0];
    state.equipped.push(item);
    
    // Apply HP Bonus immediately if exists
    if (item.hpBonus) {
        state.hero.maxHp += item.hpBonus;
        state.hero.hp += item.hpBonus;
    }

    if (item.apBonus) {
        state.hero.maxAp += item.apBonus;
    }
    
    renderHeroScreen();
}

function mapUnequipItem(equipIndex) {
    const item = state.equipped[equipIndex];

    // Revert HP Bonus
    if (item.hpBonus) {
        state.hero.maxHp -= item.hpBonus;
        state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
    }

    if (item.apBonus) {
        state.hero.maxAp -= item.apBonus;
    }

    state.equipped.splice(equipIndex, 1);
    state.inventory.push(item);
    renderHeroScreen();
}

function renderHeroScreen() {
    if(state.hero) {
        document.getElementById('hero-screen-name').innerText = state.hero.name;
        document.getElementById('hero-screen-hp').innerText = state.hero.hp;
        document.getElementById('hero-screen-max-hp').innerText = state.hero.maxHp;
        document.getElementById('hero-screen-gold').innerText = state.gold;
    }

    // 1. Render Equipped
    const equipContainer = document.getElementById('hero-screen-equipped');
    equipContainer.innerHTML = '';
    state.equipped.forEach((item, idx) => {
        let div = createCardElement(item);
        div.classList.add('equipped');
        
        // Click card to Unequip
        div.onclick = () => mapUnequipItem(idx);
        div.style.cursor = "pointer";
        div.title = "Click to Unequip";
        
        equipContainer.appendChild(div);
    });

    // 2. Render Inventory
    const invContainer = document.getElementById('hero-screen-inventory');
    invContainer.innerHTML = '';
    state.inventory.forEach((item, idx) => {
        let div = createCardElement(item);
        div.classList.add('equipped'); 
        div.style.borderTop = "5px solid #f1c40f"; 

        // Click to Equip
        div.onclick = () => mapEquipItem(idx);
        div.title = "Click to Equip";
        
        // Sell Button
        let btn = document.createElement('button');
        btn.className = 'destroy-btn';
        btn.innerText = '$';
        btn.style.background = '#27ae60'; // Green for money
        btn.title = `Sell for ${item.value||0}g`;
        btn.onclick = (e) => { 
            e.stopPropagation(); // Prevent Equip
            sellItem(idx); 
        };
        div.appendChild(btn);
        
        invContainer.appendChild(div);
    });
    
    if (state.inventory.length === 0) invContainer.innerHTML = '<span style="font-style:italic; opacity:0.5;">Empty.</span>';
}

function isNodeAccessible(nodeId) {
    const node = MAP_GRAPH[nodeId];
    // Accessible if it has no parents OR if all parents are in completedNodes
    if (node.parents.length === 0) return true;
    return node.parents.every(parentId => state.completedNodes.includes(parentId));
}

// Map Dragging State
let mapState = {
    isDown: false,
    startX: 0,
    startY: 0,
    scrollLeft: 0,
    scrollTop: 0,
    isDragging: false // Distinguish click from drag
};

function initMapDrag() {
    const slider = document.getElementById('map-viewport');
    const content = document.getElementById('map-world');

    // Mouse Events
    slider.addEventListener('mousedown', (e) => {
        mapState.isDown = true;
        mapState.isDragging = false;
        mapState.startX = e.pageX - slider.offsetLeft;
        mapState.startY = e.pageY - slider.offsetTop;
        mapState.scrollLeft = slider.scrollLeft;
        mapState.scrollTop = slider.scrollTop;
    });

    slider.addEventListener('mouseleave', () => { mapState.isDown = false; });
    slider.addEventListener('mouseup', () => { 
        mapState.isDown = false; 
        setTimeout(() => mapState.isDragging = false, 50); 
    });

    slider.addEventListener('mousemove', (e) => {
        if (!mapState.isDown) return;
        e.preventDefault();
        mapState.isDragging = true;
        const x = e.pageX - slider.offsetLeft;
        const y = e.pageY - slider.offsetTop;
        const walkX = (x - mapState.startX);
        const walkY = (y - mapState.startY);
        slider.scrollLeft = mapState.scrollLeft - walkX;
        slider.scrollTop = mapState.scrollTop - walkY;
    });

    // Touch Events (Mobile)
    slider.addEventListener('touchstart', (e) => {
        mapState.isDown = true;
        mapState.isDragging = false;
        mapState.startX = e.touches[0].pageX - slider.offsetLeft;
        mapState.startY = e.touches[0].pageY - slider.offsetTop;
        mapState.scrollLeft = slider.scrollLeft;
        mapState.scrollTop = slider.scrollTop;
    });

    slider.addEventListener('touchend', () => { mapState.isDown = false; });

    slider.addEventListener('touchmove', (e) => {
        if (!mapState.isDown) return;
        mapState.isDragging = true;
        const x = e.touches[0].pageX - slider.offsetLeft;
        const y = e.touches[0].pageY - slider.offsetTop;
        const walkX = (x - mapState.startX);
        const walkY = (y - mapState.startY);
        slider.scrollLeft = mapState.scrollLeft - walkX;
        slider.scrollTop = mapState.scrollTop - walkY;
    });
}

function renderWorldMap() {
    const layer = document.getElementById('map-nodes-layer');
    const svgLayer = document.getElementById('map-lines');
    layer.innerHTML = '';
    svgLayer.innerHTML = '';

    // 1. Draw Lines (Parents -> Children)
    Object.values(MAP_GRAPH).forEach(node => {
        node.parents.forEach(parentId => {
            const parent = MAP_GRAPH[parentId];
            // Create SVG Line
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", parent.x);
            line.setAttribute("y1", parent.y);
            line.setAttribute("x2", node.x);
            line.setAttribute("y2", node.y);
            line.classList.add("map-connection");
            svgLayer.appendChild(line);
        });
    });

    // 2. Draw Nodes
    Object.values(MAP_GRAPH).forEach(node => {
        const isUnlocked = isNodeAccessible(node.id);
        const isCompleted = state.completedNodes.includes(node.id);
        
        const el = document.createElement('div');
        el.className = `map-node-visual`;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;

        // Logic for appearance/interaction
        if (isCompleted) {
            el.classList.add('completed');
            el.innerHTML = "âœ“";
        } else if (isUnlocked) {
            el.classList.add('unlocked');
            el.innerHTML = node.tier;
            el.onclick = (e) => { 
                // Prevent drag from triggering click
                if(!mapState.isDragging) enterDungeonNode(node.id); 
            };
        } else {
            el.classList.add('locked');
            el.innerHTML = "ðŸ”’";
        }

        // Label
        const label = document.createElement('div');
        label.className = 'node-label';
        label.innerText = node.name;
        el.appendChild(label);

        layer.appendChild(el);
    });
}

function enterDungeonNode(nodeId) {
    const node = MAP_GRAPH[nodeId];
    
    state.currentNodeId = nodeId;
    state.tier = node.tier; // Still needed for buildDungeonTier logic
    
    state.dungeonDeck = buildDungeonTier(node.tier);
    state.adventureRow = [];
    state.turn = 1;

    switchScreen('game-container');

    drawCards(5);
    
    // Ensure at least one monster to start
    if (state.dungeonDeck.length > 0) {
        // Ensure first is not event
        if (state.dungeonDeck[0].type === CARD_TYPES.EVENT) {
             const safeIdx = state.dungeonDeck.findIndex(c => c.type === CARD_TYPES.MONSTER);
             if(safeIdx > -1) [state.dungeonDeck[0], state.dungeonDeck[safeIdx]] = [state.dungeonDeck[safeIdx], state.dungeonDeck[0]];
        }
        state.adventureRow.push(state.dungeonDeck.shift());
    }

    log(`Entered: ${node.name}`);
    render();
}

function buildDungeonTier(tierNum) {
    let segment = [];
    const monsterPool = TIER_POOLS[tierNum];
    
    // Add 5 Monsters from the pool
    for(let i=0; i<5; i++) {
        segment.push({...monsterPool[Math.floor(Math.random() * monsterPool.length)]});
    }
    
    // Add 2 Random Events
    for(let i=0; i<2; i++) {
        segment.push({...COMMON_EVENTS[Math.floor(Math.random() * COMMON_EVENTS.length)]});
    }

    shuffle(segment);

    // Ensure the first card is NOT an event so the player isn't blocked immediately
    if (segment.length > 0 && segment[0].type === CARD_TYPES.EVENT) {
        const safeIndex = segment.findIndex(c => c.type === CARD_TYPES.MONSTER);
        if (safeIndex !== -1) {
            [segment[0], segment[safeIndex]] = [segment[safeIndex], segment[0]];
        }
    }

    // Add Boss at the bottom
    if (tierNum < 3) {
        const bossPool = MINI_BOSSES[tierNum];
        const boss = {...bossPool[Math.floor(Math.random() * bossPool.length)]};
        segment.push(boss);
    } else {
        segment.push({...FINAL_BOSS});
    }

    return segment;
}

/* --- ENGINE HELPERS --- */

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function drawCards(count) {
    for(let i=0; i<count; i++) {
        if(state.deck.length === 0) {
            if(state.discard.length === 0) break;
            state.deck = [...state.discard];
            state.discard = [];
            shuffle(state.deck);
            log("Deck reshuffled.");
        }
        state.hand.push(state.deck.pop());
    }
}

function spawnMonsters() {
    // Only add 1 card automatically at the start of the turn/refresh
    // Max size is now 5
    if(state.adventureRow.length < 5 && state.dungeonDeck.length > 0) {
        let card = state.dungeonDeck.shift(); 
        state.adventureRow.push(card);
    }
}

/* --- ACTIONS --- */

function exploreDungeon() {
    // Check Capacity (Max 5)
    if (state.adventureRow.length >= 5) {
        log("The path is too crowded.", "red");
        return;
    }
    
    // Check Empty Deck
    if (state.dungeonDeck.length === 0) {
        log("The dungeon is silent.", "red");
        return;
    }

    // Check for Events (Block exploration)
    const hasEvent = state.adventureRow.some(c => c.type === CARD_TYPES.EVENT);
    if (hasEvent) {
        log("You must resolve the Event before exploring further!", "red");
        return;
    }

    // Draw 1 card
    let card = state.dungeonDeck.shift();
    state.adventureRow.push(card);
    log("You explore deeper...");
    render();
}

function selectCard(index) {
    // 1. Handle Deselection
    if (state.selectedCardIndex === index) {
        state.selectedCardIndex = -1;
        render();
        return;
    }

    // 2. Select the card
    state.selectedCardIndex = index;
    const card = state.hand[index];

    // 3. Auto-Play: Self-Target (Loot or Non-Damage Skills)
    // Note: Hybrid cards (Dmg + Block) are treated as Attacks, so they skip this.
    if (card.type === CARD_TYPES.LOOT || (card.type === CARD_TYPES.SKILL && !card.dmg)) {
        playCard('hero');
        return;
    }

    // 4. Auto-Play: Attack (If exactly 1 Monster is present)
    if (card.type === CARD_TYPES.SKILL && card.dmg) {
        // Find valid targets (ignore Events)
        const monsterIndices = state.adventureRow
            .map((c, i) => c.type === CARD_TYPES.MONSTER ? i : -1)
            .filter(i => i !== -1);

        if (monsterIndices.length === 1) {
            playCard(monsterIndices[0]);
            return;
        }
    }

    // 5. Manual Target Required (Highlight card)
    render();
}

function playCard(target) {
    if (state.selectedCardIndex === -1) return;

    const card = state.hand[state.selectedCardIndex];
    
    if (card.type === CARD_TYPES.CURSE) {
        log("Cannot play Curses!", "red");
        return;
    }

    if (state.hero.ap < card.cost) {
        log("Not enough AP!", "red");
        return;
    }

    let success = false;

    if (card.type === CARD_TYPES.SKILL) {
        // 1. Handle Damage (Must target Enemy)
        if (card.dmg) {
            if (target === 'hero') return; 
            if (state.adventureRow[target].type === CARD_TYPES.EVENT) {
                log("Cannot attack an Event.", "red");
                return;
            }
            dealDamage(target, card.dmg);
            success = true;
        } 
        
        // 2. Handle Self-Effects (Block/Heal/AP)
        // These trigger if: 
        // A) It's a pure buff card (no dmg) and we targeted 'hero'
        // B) It's a hybrid card (has dmg) and we successfully hit an enemy (success is true)
        if (card.block || card.heal || card.gainAp) {
            if (!card.dmg && target !== 'hero') return; // Pure buff must target hero
            if (card.dmg && !success) return; // Hybrid failed to hit target

            if (card.block) addBlock(card.block);
            if (card.heal) healHero(card.heal);
            if (card.gainAp) { state.hero.ap += card.gainAp; log(`Gained ${card.gainAp} AP.`); }
            if (card.draw) {
                drawCards(card.draw);
                log(`Drew ${card.draw} cards.`);
            }
            success = true;
        }
    } else if (card.type === CARD_TYPES.LOOT) {
        if (target !== 'hero') return;
        
        // Check Slot Limit
        if (state.equipped.length >= 3) {
            log("Slots full! Destroy an item first.", "red");
            return;
        }
        
        equipItem(card);
        success = true;
    }

    if (success) {
        // 1. Pay Costs & Remove Card (Do this FIRST)
        state.hero.ap -= card.cost;
        const playedCard = state.hand.splice(state.selectedCardIndex, 1)[0];
        
        if (playedCard.type !== CARD_TYPES.LOOT) {
            state.discard.push(playedCard);
        }
        
        state.selectedCardIndex = -1;
        
        // 2. Trigger Item Passives
        state.equipped.forEach(item => {
            if(item.block) addBlock(item.block);
        });

        // 3. Render Updates
        render();

        // 4. Check for Auto-End Turn (Zone Cleared)
        // We do this last so the card completely resolves before the state resets
        if (state.adventureRow.length === 0) {
            log("Zone cleared. Ending turn...", "#95a5a6");
            endTurn();
        }
    }
}

// --- EVENT RESOLUTION ---
function resolveEventChoice(cardIndex, choiceIndex) {
    const eventCard = state.adventureRow[cardIndex];
    const choice = eventCard.choices[choiceIndex];

    log(`<span class="log-event">Event: ${choice.label}</span>`);

    // --- Original Events ---
    if (choice.effect === 'pray') {
        healHero(10);
        state.discard.push({...CURSE_CARD});
        log("You were healed, but cursed.");
        removeEvent();
    } 
    else if (choice.effect === 'fight') {
        spawnEventMonster('m_ghost');
    } 
    else if (choice.effect === 'leave') {
        log("You ignore it.");
        removeEvent();
    }
    
    // --- New Events ---
    
    // 1. Trap Door
    else if (choice.effect === 'trap_dmg') {
        state.hero.hp -= 5;
        log("You hit the ground hard. Took 5 DMG.", "red");
        removeEvent();
    }
    else if (choice.effect === 'trap_unequip') {
        if(state.equipped.length > 0) {
            const rIdx = Math.floor(Math.random() * state.equipped.length);
            const item = state.equipped[rIdx];
            
            // Revert Passive Stats
            if (item.hpBonus) {
                state.hero.maxHp -= item.hpBonus;
                state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
            }
            if (item.apBonus) {
                state.hero.maxAp -= item.apBonus;
            }

            // Move to inventory
            state.equipped.splice(rIdx, 1);
            state.inventory.push(item);
            
            log(`The fall knocked off your ${item.name}!`, "red");
            render(); // Update UI to show item is gone
        } else {
            log("You stumbled, but had nothing equipped to lose.");
        }
        removeEvent();
    }

    // 2. Tribute
    else if (choice.effect === 'tribute_pay') {
        state.hero.maxHp -= 5;
        state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
        // Give a strong item
        let relic = { id: 'l_blood', name: 'Blood Gem', type: CARD_TYPES.LOOT, value: 5, atkBuff: 3, desc: '+3 DMG' };
        state.inventory.push(relic);
        log("You sacrificed vitality for power.");
        removeEvent();
    }

    // 3. Suspicious Chest
    else if (choice.effect === 'chest_open') {
        if(Math.random() > 0.5) {
            log("It's a trap! MIMIC!", "red");
            spawnEventMonster('m_mimic');
        } else {
            // Pick random skill from library
            const randomSkill = SKILL_LIBRARY[Math.floor(Math.random() * SKILL_LIBRARY.length)];
            // Clone it to avoid reference issues
            const reward = JSON.parse(JSON.stringify(randomSkill));
            state.collection.push(reward);
            log(`You found a scroll: ${reward.name}!`);
            removeEvent();
        }
    }

    // 4. Weapon Master
    else if (choice.effect === 'train_str') {
        let card = { id: 's_heavy', name: 'Heavy Strike', type: CARD_TYPES.SKILL, cost: 2, dmg: 10, desc: 'Deal 10 DMG' };
        state.collection.push(card);
        log("Learned Heavy Strike.");
        removeEvent();
    }
    else if (choice.effect === 'train_def') {
        let card = { id: 's_iron', name: 'Iron Skin', type: CARD_TYPES.SKILL, cost: 1, block: 8, desc: 'Gain 8 Block' };
        state.collection.push(card);
        log("Learned Iron Skin.");
        removeEvent();
    }

    // 5. Spring
    else if (choice.effect === 'spring_heal') {
        healHero(5);
        removeEvent();
    }
    else if (choice.effect === 'spring_max') {
        state.hero.maxHp += 3;
        state.hero.hp += 3;
        log("You feel permanently stronger (+3 Max HP).", "green");
        removeEvent();
    }

    render();

    // Check for Auto-End Turn after event resolves
    if (state.adventureRow.length === 0) {
        log("Zone cleared. Ending turn...", "#95a5a6");
        endTurn();
    }

    // Helper to clear the event from the row
    function removeEvent() {
        state.adventureRow.splice(cardIndex, 1);
    }

    // Helper to swap event with monster
    function spawnEventMonster(id) {
        const monster = JSON.parse(JSON.stringify(EVENT_MONSTERS[id]));
        state.adventureRow[cardIndex] = monster;
        render();
    }
}

function equipItem(card) {
    state.equipped.push(card);
    log(`Equipped ${card.name}.`);
    if(card.hpBonus) {
        state.hero.maxHp += card.hpBonus;
        state.hero.hp += card.hpBonus;
        log(`Max HP increased by ${card.hpBonus}.`);
    }
}

function dealDamage(monsterIndex, amount) {
    let monster = state.adventureRow[monsterIndex];
    let bonus = 0;
    state.equipped.forEach(item => { if(item.atkBuff) bonus += item.atkBuff; });
    
    let totalDmg = amount + bonus;
    monster.hp -= totalDmg;
    
    log(`Hit ${monster.name} for <span class="log-dmg">${totalDmg}</span> dmg.`);

    if (monster.hp <= 0) {
        killMonster(monsterIndex);
    }
}

function killMonster(index) {
    let m = state.adventureRow[index];
    log(`${m.name} defeated!`);
    
    if (m.id === 'm_boss') {
        victory();
        return;
    }

    // Tier Transition
    if (m.isMiniBoss) {
        log(`Mini-Boss Defeated! Sector Cleared!`, "gold");
        
        // Mark Node as Complete
        if (state.currentNodeId && !state.completedNodes.includes(state.currentNodeId)) {
            state.completedNodes.push(state.currentNodeId);
            log(`Zone Cleared: ${MAP_GRAPH[state.currentNodeId].name}`, "gold");
        }
        
        // Transform Boss into a Legendary Reward
        if(Math.random() < 0.1){
            let reward = { id: 'l_boss_relic', name: 'Boss Relic', type: CARD_TYPES.LOOT, value: 10, atkBuff: 2, hpBonus: 5, desc: '+2 DMG & +5 Max HP' };
            state.inventory.push(reward);
        }
        
        state.adventureRow.splice(index, 1);
        
        // Delay slightly then go to map
        setTimeout(() => {
            log("Returning to Map...");
            // Clear hand/board
            state.hand.forEach(c => state.discard.push(c));
            state.hand = [];
            showMap();
        }, 1500);
        return;
    }

    // Loot Chance scales with danger (number of OTHER monsters in the row)
    // Base: 10% + 10% per other monster. 
    // 0 others = 10%, 4 others = 50%
    const otherMonsters = state.adventureRow.filter((c, i) => i !== index && c.type === CARD_TYPES.MONSTER).length;
    const dropChance = 0.10 + (otherMonsters * 0.10);

    log(`Drop Chance: ${Math.floor(dropChance * 100)}%`, "#7f8c8d");

    if (Math.random() < dropChance) {
        if (REWARDS[m.rewardId]) {
            let lootCard = JSON.parse(JSON.stringify(REWARDS[m.rewardId]));
            // Loot goes to Inventory now, not Deck
            if(lootCard.type === CARD_TYPES.LOOT){
                state.inventory.push(lootCard);
            } else {
                state.collection.push(lootCard);
            }
            log(`Looted: ${lootCard.name}`, "#2ecc71");
        }
    } else {
        log("No loot found.");
    }
    
    state.adventureRow.splice(index, 1);
}

function addBlock(amount) {
    state.hero.block += amount;
    log(`Gained ${amount} Block.`);
}

function healHero(amount) {
    state.hero.hp = Math.min(state.hero.maxHp, state.hero.hp + amount);
    log(`Healed for <span class="log-gain">${amount}</span> HP.`);
}

function endTurn() {
    log("--- Enemy Turn ---");
    
    state.adventureRow.forEach(m => {
        if(m.type === CARD_TYPES.EVENT) return;

        let dmg = m.atk;
        
        if (state.hero.block > 0) {
            if (state.hero.block >= dmg) {
                state.hero.block -= dmg;
                dmg = 0;
                log(`${m.name} attack blocked.`);
            } else {
                dmg -= state.hero.block;
                state.hero.block = 0;
                log(`${m.name} broke your shield!`);
            }
        }

        if (dmg > 0) {
            state.hero.hp -= dmg;
            log(`${m.name} deals <span class="log-dmg">${dmg}</span> damage!`);
        }
    });

    if (state.hero.hp <= 0) {
        gameOver();
        return;
    }

    state.hero.ap = state.hero.maxAp;
    state.hero.block = 0; 
    
    while(state.hand.length > 0) {
        state.discard.push(state.hand.pop());
    }

    drawCards(5);

    // If the row is completely empty (no monsters/events), the dungeon sends a new threat
    if (state.adventureRow.length === 0) {
        spawnMonsters();
    }

    state.turn++;
    state.selectedCardIndex = -1;
    render();
}

function checkWinCondition() {}

function victory() {
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('overlay-title').innerText = "VICTORY!";
    document.getElementById('overlay-title').style.color = "gold";
}

function gameOver() {
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('overlay-title').innerText = "YOU DIED";
    document.getElementById('overlay-title').style.color = "red";
}

function log(msg, color) {
    const el = document.getElementById('log-console');
    let style = color ? `style="color:${color}"` : '';
    // Append to end, CSS flex-direction: column-reverse handles order
    el.innerHTML += `<div class="log-entry" ${style}>${msg}</div>`; 
    // Keep only last 4 messages to save space
    if (el.children.length > 4) {
        el.removeChild(el.children[0]);
    }
}

/* --- RENDERING --- */

function switchScreen(activeScreenId) {
    const screens = ['hero-selection', 'map-screen', 'game-container', 'hero-screen', 'deck-screen'];
    screens.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.style.display = (id === activeScreenId) ? 'flex' : 'none';
        }
    });
}

function render() {
    // Hero Name
    document.getElementById('hero-name').innerText = state.hero.name;

    document.getElementById('hero-hp').innerText = state.hero.hp;
    document.getElementById('hero-max-hp').innerText = state.hero.maxHp;
    document.getElementById('hero-ap').innerText = state.hero.ap;
    document.getElementById('hero-max-ap').innerText = state.hero.maxAp;
    document.getElementById('hero-block').innerText = state.hero.block;
    
    document.getElementById('deck-count').innerText = state.deck.length;

    const advContainer = document.getElementById('adventure-row');
    
    // Check logic for button state
    const hasEvent = state.adventureRow.some(c => c.type === CARD_TYPES.EVENT);
    const isFull = state.adventureRow.length >= 5;
    const disabledAttr = (hasEvent || isFull || state.dungeonDeck.length === 0) ? 'disabled' : '';
    const btnColor = hasEvent ? '#e67e22' : '#7f8c8d'; // Visual cue

    advContainer.innerHTML = `
        <div class="area-label">
            Adventure Row
        </div>`;
    
    state.adventureRow.forEach((m, idx) => {
        let cardDiv = createCardElement(m, idx); 
        if(m.type === CARD_TYPES.MONSTER) {
            cardDiv.onclick = () => playCard(idx);
        }
        advContainer.appendChild(cardDiv);
    });

    // Hero
    const heroContainer = document.getElementById('hero-card-container');
    heroContainer.innerHTML = '';
    let heroCard = createCardElement(state.hero);
    heroCard.onclick = () => playCard('hero'); 
    heroContainer.appendChild(heroCard);

    const equipContainer = document.getElementById('equipment-slots');
    equipContainer.innerHTML = '';
    state.equipped.forEach((item) => {
        let div = createCardElement(item);
        div.classList.add('equipped');
        // No buttons here anymore
        equipContainer.appendChild(div);
    });

    // Hand
    const handContainer = document.getElementById('hand-row');
    handContainer.innerHTML = '<div class="area-label">Your Hand</div>';
    state.hand.forEach((card, idx) => {
        let div = createCardElement(card);
        div.onclick = (e) => {
            e.stopPropagation();
            selectCard(idx);
        };
        if (idx === state.selectedCardIndex) div.classList.add('selected');
        handContainer.appendChild(div);
    });
}

function createCardElement(data, index) {
    const div = document.createElement('div');
    div.classList.add('card');
    div.classList.add(`type-${data.type}`);
    
    let bodyHtml = '';
    let statsHtml = '';

    if (data.type === CARD_TYPES.MONSTER) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>âš”ï¸${data.atk}</span><span>â¤ï¸${data.hp}</span></div>`;
    } else if (data.type === CARD_TYPES.HERO) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>âš¡${data.ap}</span><span>â¤ï¸${data.hp}</span></div>`;
    } else if (data.type === CARD_TYPES.SKILL || data.type === CARD_TYPES.CURSE) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>âš¡${data.cost}</span></div>`;
    } else if (data.type === CARD_TYPES.LOOT) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        // Display Gold Value
        let valDisplay = data.value ? `<span style="color:#f1c40f;">ðŸ’°${data.value}</span>` : '';
        statsHtml = `<div class="card-stats">${valDisplay}</div>`;
    } else if (data.type === CARD_TYPES.EVENT) {
        let buttons = '';
        if(data.choices) {
            data.choices.forEach((choice, choiceIdx) => {
                buttons += `<button class="choice-btn" onclick="event.stopPropagation(); resolveEventChoice(${index}, ${choiceIdx})">${choice.label}</button>`;
            });
        }
        bodyHtml = `<div class="card-desc">${data.desc}${buttons}</div>`;
    } else {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
    }

    div.innerHTML = `
        <div class="card-header">${data.name}</div>
        ${bodyHtml}
        ${statsHtml}
    `;
    return div;
}

function saveGame() {
    // Save the entire state object
    localStorage.setItem('vanguardSave', JSON.stringify(state));
}

function loadGame() {
    const save = localStorage.getItem('vanguardSave');
    if (save) {
        try {
            state = JSON.parse(save);
            
            // If loaded, skip selection and go to Map
            // We reset the "run" state (hand/row) to ensure a clean load on the map
            state.hand = [];
            state.discard = [];
            state.adventureRow = []; 
            // Ensure deck is consolidated if we crashed mid-run
            if (state.deck.length < 10) { 
                // If deck is empty (cards in hand/discard), we might need to rebuild logic or just reset deck
                // For safety in this prototype, we assume saving happens mostly on Map
            }
            
            showMap();
            log("Game Loaded.");
            return true;
        } catch (e) {
            console.error("Save file corrupted", e);
            return false;
        }
    }
    return false;
}

function resetProgress() {
    if(confirm("Are you sure? This will wipe all progress.")) {
        localStorage.removeItem('vanguardSave');
        location.reload();
    }
}

// Start Game
if (!loadGame()) {
    initSelectionScreen();
}

</script>
</body>
</html>