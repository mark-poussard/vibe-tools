<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanguard of the Void</title>
    <style>
        :root {
            --bg-color: #202c39;
            --card-bg: #ecf0f1;
            --text-color: #2c3e50;
            --highlight: #f1c40f;
            --monster-color: #e74c3c;
            --skill-color: #3498db;
            --loot-color: #2ecc71;
            --hero-color: #9b59b6;
            --event-color: #e67e22;
            --curse-color: #7f8c8d;
            --ui-panel: rgba(0,0,0,0.4);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            padding: 0;
            height: 100dvh; /* Dynamic Viewport Height for mobile */
            overflow: hidden;
            font-size: 14px;
        }

        /* --- Common Layouts --- */
        .screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }

        h1 { margin: 10px 0; font-size: 24px; text-align: center; }
        button {
            padding: 12px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        button:active { transform: scale(0.98); }

        /* --- Notification System --- */
        #notification-area {
            position: fixed;
            top: -100px; /* Hidden by default */
            left: 50%;
            transform: translateX(-50%);
            min-width: 200px;
            text-align: center;
            padding: 15px 25px;
            border-radius: 0 0 15px 15px;
            z-index: 2000; /* Above everything */
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transition: top 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            pointer-events: none; /* Let clicks pass when hidden */
        }
        
        #notification-area.show {
            top: 0;
            pointer-events: auto;
        }

        .notify-gold { background-color: var(--highlight); color: #2c3e50; border: 2px solid #fff; }
        .notify-loss { background-color: #c0392b; color: white; border: 2px solid #fff; }
        .notify-skill { background-color: var(--skill-color); color: white; border: 2px solid #fff; }
        .notify-loot { background-color: var(--loot-color); color: white; border: 2px solid #fff; }
        .notify-item { background-color: #9b59b6; color: white; border: 2px solid #fff; }

        /* --- Game Screen Grid --- */
        #game-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 5px;
            display: none; /* Controlled by JS */
        }

        #game-main-area {
            flex: 1;
            overflow-y: auto;
            min-height: 0; /* Prevents flexbox overflow issues */
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Stats Bar (Compact) */
        #stats-bar {
            background: var(--ui-panel);
            padding: 8px;
            border-radius: 8px;
            font-size: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        .stat-row { display: flex; justify-content: space-between; }

        /* Scrollable Card Rows (The key to mobile layout) */
        .scroll-row {
            display: flex;
            gap: 8px;
            padding: 5px 2px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch; /* Smooth scroll iOS */
            min-height: 135px; /* Fits card height */
            align-items: center;
        }
        /* Hide scrollbar but keep functionality */
        .scroll-row::-webkit-scrollbar { display: none; }

        #adventure-row {
            background: rgba(231, 76, 60, 0.05);
            border-top: 2px solid var(--monster-color);
            border-bottom: 2px solid var(--monster-color);
        }

        #hand-row {
            background: rgba(52, 152, 219, 0.05);
            border-top: 2px solid var(--skill-color);
            margin-top: auto; /* Push to bottom */
            margin-bottom: 5px;
        }

        .area-label {
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.7;
            margin-left: 5px;
            margin-bottom: -5px;
            z-index: 1;
        }

        /* Hero Area (Middle) */
        #hero-area {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            flex-grow: 1;
            min-height: 100px;
        }
        #hero-card-container { transform: scale(0.9); transform-origin: left center; }
        #equipment-slots { display: flex; gap: 4px; overflow-x: auto; }
        
        #end-turn-container {
            margin-left: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #end-turn-btn {
            background: var(--monster-color);
            color: white;
            width: 80px;
            height: 60px;
            font-size: 12px;
            line-height: 1.2;
            white-space: pre-wrap;
        }

        /* --- Cards (Mobile Optimized) --- */
        .card {
            flex: 0 0 85px; /* Fixed width, no shrinking/growing */
            width: 85px;
            height: 120px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            position: relative;
            font-size: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            user-select: none;
        }

        .card-header {
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 10px;
            margin-bottom: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid #bdc3c7;
        }

        .card-desc {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 9px;
            line-height: 1.1;
            overflow: hidden;
        }
        
        .card-stats {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 11px;
            margin-top: 2px;
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
            padding: 2px;
        }

        /* Card Types Borders */
        .type-monster { border-bottom: 4px solid var(--monster-color); }
        .type-skill { border-bottom: 4px solid var(--skill-color); }
        .type-loot { border-bottom: 4px solid var(--loot-color); }
        .type-event { border-bottom: 4px solid var(--event-color); }
        .type-curse { border-bottom: 4px solid var(--curse-color); background: #bdc3c7; }
        .type-hero { border: 2px solid var(--hero-color); width: 90px; height: 120px; }

        .card.selected { border: 2px solid var(--highlight); transform: translateY(-10px); }
        .card.equipped { transform: scale(0.9);}

        /* Buttons on cards */
        .choice-btn { font-size: 8px; padding: 4px; width: 100%; margin-top: 2px; }
        .destroy-btn { width: 20px; height: 20px; font-size: 12px; }

        /* --- Map & Menus --- */
        #map-screen, #hero-selection, #hero-screen, #deck-screen, #merchant-screen {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
        }

        /* Draggable Map Styles */
        #map-screen { padding: 0; overflow: hidden; position: relative; background: #1a1a1a; }
        
        #map-viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            position: relative;
        }
        
        #map-viewport:active { cursor: grabbing; }

        #map-world {
            width: 2100px; /* Large virtual canvas */
            height: 800px;
            position: absolute;
            top: 0; left: 0;
            transform-origin: 0 0;
            background-image: radial-gradient(#34495e 1px, transparent 1px);
            background-size: 20px 20px; /* Grid pattern */
        }

        .map-node-visual {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #7f8c8d;
            background: #2c3e50;
            color: white;
            font-weight: bold;
            font-size: 18px;
            z-index: 5;
            transition: transform 0.2s, border-color 0.2s;
            /* Center the circle on the coord */
            transform: translate(-50%, -50%);
        }

        .map-node-visual.locked { opacity: 0.6; filter: grayscale(1); }
        .map-node-visual.unlocked { border-color: var(--highlight); background: #27ae60; cursor: pointer; box-shadow: 0 0 15px var(--highlight); animation: pulse 2s infinite; }
        .map-node-visual.completed { border-color: gold; background: #e67e22; cursor: pointer; }

        .map-node-visual:hover.unlocked { transform: translate(-50%, -50%) scale(1.1); }

        .node-label {
            position: absolute;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }

        /* SVG Connections Layer */
        #map-lines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        .map-connection {
            stroke: #7f8c8d;
            stroke-width: 4;
            opacity: 0.5;
        }

        /* UI Overlay Layer */
        .map-ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to map */
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .map-ui-overlay button { pointer-events: auto; } /* Re-enable buttons */

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }

        /* Hero Selection Specifics */
        .hero-select-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 20px;
            margin-top: auto;
            margin-bottom: auto;
        }
        
        /* Make Hero Selection cards slightly larger and interactive */
        .hero-select-container .card {
            transform: scale(1.2);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .hero-select-container .card:hover {
            transform: scale(1.3);
            box-shadow: 0 0 15px var(--highlight);
            z-index: 10;
        }

        .deck-manager-container {
            display: flex;
            flex-direction: column; /* Vertical stack */
            gap: 10px;
            flex: 1; /* Fill remaining screen height */
            overflow: hidden; /* Prevent container scroll */
            margin-top: 10px;
            min-height: 0; /* Flexbox nesting fix */
        }
        .deck-column {
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.2);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            padding: 5px;
            min-height: 0; /* Allow shrinking */
        }
        .deck-column h2 { 
            text-align: center; margin: 5px 0; font-size: 14px; color: var(--highlight); 
            flex-shrink: 0; 
        }
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            overflow-y: auto; /* Individual area scroll */
            flex: 1; /* Fill column space */
            padding: 5px;
        }

        .merchant-panel {
            background: rgba(0,0,0,0.3);
            border: 1px solid #f1c40f;
            border-radius: 8px;
            padding: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .merchant-price {
            position: absolute; bottom: 2px; right: 2px;
            background: rgba(0,0,0,0.8); color: #f1c40f;
            padding: 2px 4px; border-radius: 4px; font-size: 10px;
        }

        /* Grids for managers */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            padding-bottom: 20px;
        }

        /* Log (Mini Overlay) */
        #log-console {
            height: 40px;
            font-size: 10px;
            background: rgba(0,0,0,0.6);
            position: absolute;
            bottom: 150px; /* Above hand */
            left: 10px;
            right: 10px;
            pointer-events: none;
            padding: 5px;
            border-radius: 4px;
            z-index: 10;
            display: flex;
            flex-direction: column-reverse; /* Newest at bottom */
        }

                /* Settings Overlay */
        #settings-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none; /* Controlled by JS */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 101; /* Above other overlays */
        }
        .setting-row {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 16px;
        }
        .danger-btn {
            background-color: #c0392b !important;
            color: white;
        }

        /* Overlay */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        /* Event Specific Overlay */
        #event-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 90;
        }
        
        /* Explicit Ordering */
        #event-overlay h2 { order: 1; }
        #event-card-container { order: 2; }
        
        #event-overlay .card {
            transform: scale(1.5); 
            box-shadow: 0 0 30px rgba(230, 126, 34, 0.6);
            
            /* Fix Layout: Add margin to reserve space for the visual expansion.
               Card grows ~25% upwards and downwards (50% total scale). 
               120px height * 0.25 = 30px. We add 40px for safety. */
            margin: 40px; 
        }
        
        #event-overlay h2 {
            color: white;
            margin: 0; /* Let gap handle spacing */
            text-shadow: 0 2px 4px black;
            order: -1; /* Force to top */
        }
    </style>
</head>
<body>

<!-- Hero Selection Screen -->
<div id="hero-selection">
    <h1>Choose Your Hero</h1>
    <div class="hero-select-container" id="hero-select-container">
        <!-- Hero cards injected here -->
    </div>
</div>
    
<!-- Map Screen -->
<div id="map-screen">
    <!-- 1. The Moving World -->
    <div id="map-viewport">
        <div id="map-world">
            <svg id="map-lines"></svg>
            <div id="map-nodes-layer"></div>
        </div>
    </div>

    <!-- 2. Fixed UI Overlay -->
    <div class="map-ui-overlay">
        <!-- Top Bar -->
        <div style="display:flex; justify-content: space-between; align-items: start;">
            <div style="background:rgba(0,0,0,0.6); padding:5px; border-radius:4px;">
                <h1 style="font-size:16px; margin:0;">World Map</h1>
            </div>
            <div style="display:flex; flex-direction: column; gap:5px;">
                <button onclick="showHeroScreen()" style="background-color: var(--hero-color);">Hero</button>
                                <button onclick="showDeckScreen()" style="background-color: var(--skill-color);">Deck</button>
                <button onclick="showSettingsScreen()" style="background-color: var(--curse-color);">Settings</button>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div style="display:flex; justify-content: flex-end;">
            
        </div>
    </div>
</div>

<!-- Hero / Inventory Screen -->
<div id="hero-screen">
    <div style="display:flex; justify-content:space-between; align-items:center; width:100%; max-width:600px;">
        <h1>Hero Details</h1>
        <button onclick="closeHeroScreen()">Back to Map</button>
    </div>

    <div class="hero-panel">
        <!-- Stats -->
        <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #fff; padding-bottom:10px;">
            <strong style="color:var(--hero-color); font-size:1.5em;"><span id="hero-screen-name">Hero</span></strong>
            <div style="text-align:right;">
                <strong style="color:#f1c40f; font-size:1.2em; margin-right:15px;">Gold: <span id="hero-screen-gold">0</span></strong>
                <strong style="color:var(--monster-color); font-size:1.2em;">HP: <span id="hero-screen-hp">0</span>/<span id="hero-screen-max-hp">0</span></strong>
            </div>
        </div>

        <!-- Equipped -->
        <div>
            <div style="font-size:1em; margin-bottom:10px; color:var(--loot-color);">Equipped Items (Click to Unequip):</div>
            <div id="hero-screen-equipped" style="display:flex; gap:10px; min-height:100px; align-items:center; background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;"></div>
        </div>

        <!-- Inventory -->
        <div style="flex-grow: 1; overflow-y: auto;">
            <div style="font-size:1em; margin-bottom:10px; color:var(--highlight); position: sticky; top:0; background: var(--bg-color); padding: 5px;">Inventory</div>
            <div id="hero-screen-inventory" class="card-grid" style="background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;"></div>
        </div>
    </div>
</div>

<!-- Merchant Screen -->
<div id="merchant-screen">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1 style="color:#f1c40f;">Traveling Merchant</h1>
        <div style="display:flex; align-items:center; gap:10px;">
            <strong style="color:#f1c40f; font-size:1.2em;">Gold: <span id="merchant-gold">0</span></strong>
            <button onclick="closeMerchantScreen()">Leave Shop</button>
        </div>
    </div>

    <div style="display:flex; flex-direction:column; gap:10px; flex:1; overflow:hidden;">
        <!-- Buy Section -->
        <div class="merchant-panel">
            <h2 style="margin:0 0 5px 0; font-size:14px; color:#2ecc71;">Buy Items</h2>
            <div id="merchant-buy-grid" class="card-grid" style="overflow-y:auto;"></div>
        </div>

        <!-- Sell Section -->
        <div class="merchant-panel">
            <h2 style="margin:0 0 5px 0; font-size:14px; color:#e74c3c;">Sell Your Goods</h2>
            <div id="merchant-sell-grid" class="card-grid" style="overflow-y:auto;"></div>
        </div>
    </div>
</div>

<!-- Deck Management Screen -->
<div id="deck-screen">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1>Deck Manager</h1>
        <button onclick="closeDeckScreen()">Back to Map</button>
    </div>
    <div class="deck-manager-container">
        <!-- Active Deck (Fixed max height to 40% of screen) -->
        <div class="deck-column" style="flex: 0 0 40%;">
            <h2>Deck (<span id="manager-deck-count">0</span>)</h2>
            <div id="manager-deck-grid" class="card-grid"></div>
        </div>
        <!-- Collection (Takes remaining space) -->
        <div class="deck-column" style="flex: 1;">
            <h2>Collection (<span id="manager-col-count">0</span>)</h2>
            <div id="manager-col-grid" class="card-grid"></div>
        </div>
    </div>
</div>

<!-- Notification Overlay -->
<div id="notification-area" onclick="this.classList.remove('show')"></div>

<!-- Event Overlay -->
<div id="event-overlay">
    <h2>Event Encounter</h2>
    <div id="event-card-container"></div>
</div>

<!-- Settings Overlay -->
<div id="settings-overlay">
    <h1>Settings</h1>
    <div class="setting-row">
        <label for="auto-add-toggle">Auto-add new Skills to Deck</label>
        <input type="checkbox" id="auto-add-toggle" onchange="toggleAutoAddSetting(this.checked)">
    </div>
    <button onclick="resetProgress()" class="danger-btn">Reset Save Data</button>
    <button onclick="closeSettingsScreen()">Close</button>
</div>

<!-- Game Overlay (Win/Loss) -->
<div id="overlay">
    <h1 id="overlay-title">Game Over</h1>
    <button onclick="location.reload()">Play Again</button>
</div>

<!-- Main Game Interface -->
<div id="game-container">
    
    <!-- Top: Compact Stats -->
    <div id="stats-bar">
        <div class="stat-row">
            <strong style="color:var(--hero-color)"><span id="hero-name">Hero</span></strong>
            <strong style="color:var(--monster-color)">HP: <span id="hero-hp">0</span>/<span id="hero-max-hp">0</span></strong>
        </div>
        <div class="stat-row">
            <strong style="color:var(--highlight)">AP: <span id="hero-ap">0</span>/<span id="hero-max-ap">0</span></strong>
            <strong style="color:var(--skill-color)">Blk: <span id="hero-block">0</span></strong>
            <span>Deck:<span id="deck-count">0</span></span>
        </div>
    </div>

    <div id="game-main-area">
        <!-- Row 2: Adventure (Scrollable) -->
        <div id="adventure-row" class="scroll-row">
            <!-- Monsters injected here -->
        </div>

        <!-- Row 3: Hero & Equip -->
        <div id="hero-area">
            <div id="hero-card-container">
                <!-- Hero Card -->
            </div>
            <div style="flex-grow:1; overflow:hidden;">
                <div class="area-label" style="margin-bottom:2px;">Equipped</div>
                <div id="equipment-slots">
                    <!-- Equipped Items -->
                </div>
            </div>
            <div id="end-turn-container">
                <button id="end-turn-btn" onclick="endTurn()">END<br>TURN</button>
            </div>
        </div>
    </div>

    <!-- Log Overlay -->
    <div id="log-console"></div>

    <!-- Row 4: Hand (Scrollable, fixed bottom) -->
    <div class="area-label">Hand</div>
    <div id="hand-row" class="scroll-row">
        <!-- Hand cards -->
    </div>

</div>

<script>
/* --- GAME DATA --- */

const CARD_TYPES = {
    HERO: 'hero',
    GROUP: 'group',
    MONSTER: 'monster',
    SKILL: 'skill',
    LOOT: 'loot',
    EVENT: 'event',
    CURSE: 'curse',
    QUEST: 'quest',
    CONSUMABLE: 'consumable'
};

const HEROES = [
    { 
        id: 'h_ironclad', 
        name: 'Paladin', 
        type: CARD_TYPES.HERO, 
        hp: 20, maxHp: 20, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Tanky. Starts with Shield.',
        startItem: 'i_shield'
    },
    { 
        id: 'h_shadow', 
        name: 'Rogue', 
        type: CARD_TYPES.HERO, 
        hp: 20, maxHp: 20, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Agile. Acts fast.',
        startItem: 'i_cloak'
    },
    { 
        id: 'h_weaver', 
        name: 'Mage', 
        type: CARD_TYPES.HERO, 
        hp: 20, maxHp: 20, 
        ap: 3, maxAp: 3, 
        block: 0, 
        desc: 'Fragile. Powerful spells.',
        startItem: 'i_wand'
    }
];

/* --- DATABASE (ITEMS & SKILLS) --- */
const ITEM_DB = {
    // --- TIER 1 COMMON ---
    'l_dagger': { id: 'l_dagger', name: 'Rusty Dagger', type: CARD_TYPES.LOOT, rarity: 'common', value: 10, atkBuff: 1, desc: '+1 DMG' },
    'l_shield': { id: 'l_shield', name: 'Buckler', type: CARD_TYPES.LOOT, rarity: 'common', value: 10, block: 1, desc: '+1 Block / Turn' },
    's_bite':   { id: 's_bite',   name: 'Rabid Bite', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, dmg: 2, desc: 'Deal 2 DMG' },
    's_claw':   { id: 's_claw',   name: 'Feral Claw', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, dmg: 3, desc: 'Deal 3 DMG' },
    's_mend':   { id: 's_mend',   name: 'Mend',       type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, heal: 4, desc: 'Heal 4 HP' },

    // --- TIER 1 RARE ---
    'l_goo':    { id: 'l_goo',    name: 'Slime Shield', type: CARD_TYPES.LOOT, rarity: 'rare', value: 25, block: 2, desc: '+2 Block / Turn' },
    'l_spear':  { id: 'l_spear',  name: 'Short Spear',  type: CARD_TYPES.LOOT, rarity: 'rare', value: 25, atkBuff: 2, desc: '+2 DMG' },
    's_web':    { id: 's_web',    name: 'Web Shot',     type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, dmg: 5, desc: 'Deal 5 DMG' },

    // --- TIER 2 COMMON ---
    's_smash':  { id: 's_smash',  name: 'Big Smash',    type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, dmg: 8, desc: 'Deal 8 DMG' },
    'l_amulet': { id: 'l_amulet', name: 'Ghost Amulet', type: CARD_TYPES.LOOT, rarity: 'common', value: 20, atkBuff: 2, desc: '+2 DMG' },
    
    // --- TIER 2 RARE ---
    's_bolt':   { id: 's_bolt',   name: 'Dark Bolt',    type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, dmg: 12, desc: 'Deal 12 DMG' },
    'l_cloak':  { id: 'l_cloak',  name: 'Shadow Cloak', type: CARD_TYPES.LOOT, rarity: 'rare', value: 40, block: 1, apBonus: 1, desc: '+1 Block, +1 Max AP' },

    // --- TIER 3 LEGENDARY ---
    's_stone':  { id: 's_stone',  name: 'Stone Form',   type: CARD_TYPES.SKILL, rarity: 'legendary', cost: 2, block: 15, desc: 'Gain 15 Block' },
    'l_bark':   { id: 'l_bark',   name: 'Bark Skin',    type: CARD_TYPES.LOOT, rarity: 'legendary', value: 80, hpBonus: 5, desc: '+5 Max HP' },
    'l_scale':  { id: 'l_scale',  name: 'Dragon Scale', type: CARD_TYPES.LOOT, rarity: 'legendary', value: 80, block: 3, desc: '+3 Block / Turn' },
    'l_boss_relic': { id: 'l_boss_relic', name: 'Boss Relic', type: CARD_TYPES.LOOT, value: 50, atkBuff: 2, hpBonus: 5, desc: '+2 DMG & +5 Max HP' },
    
    // --- SECRET BOSS LOOT ---
    'l_infinity_blade': { id: 'l_infinity_blade', name: 'Infinity Blade', type: CARD_TYPES.LOOT, rarity: 'legendary', value: 300, atkBuff: 5, apBonus: 1, desc: '+5 DMG, +1 AP. Godly.' },

    // --- STARTING ITEMS ---
    'i_shield': { id: 'i_shield', name: 'Tower Shield', type: CARD_TYPES.LOOT, rarity: 'common', value: 5, block: 2, desc: '+2 Block / Turn' },
    'i_cloak':  { id: 'i_cloak',  name: 'Cloak',   type: CARD_TYPES.LOOT, rarity: 'common', value: 5, apBonus: 1, desc: '+1 Max AP' },
    'i_wand':   { id: 'i_wand',   name: 'Ember',   type: CARD_TYPES.LOOT, rarity: 'common', value: 5, atkBuff: 1, desc: '+1 DMG' },

// --- CONSUMABLES ---
    'c_potion_s': { id: 'c_potion_s', name: 'Health Potion', type: CARD_TYPES.CONSUMABLE, rarity: 'common', value: 15, heal: 10, desc: 'Restore 10 HP' },
    'c_str_brew': { id: 'c_str_brew', name: 'Strength Brew', type: CARD_TYPES.CONSUMABLE, rarity: 'rare', value: 30, buffAtk: 2, desc: '+2 DMG next Dungeon' },
    'c_iron_skin':{ id: 'c_iron_skin', name: 'Iron Flask',   type: CARD_TYPES.CONSUMABLE, rarity: 'rare', value: 30, buffBlock: 2, desc: '+2 Start Block next Dungeon' },

    // --- QUEST ITEMS ---
    'q_old_key':  { id: 'q_old_key',  name: 'Rusty Key',     type: CARD_TYPES.QUEST, rarity: 'rare', value: 0, desc: 'Opens locked chests' },
    'q_letter':   { id: 'q_letter',   name: 'Royal Letter',  type: CARD_TYPES.QUEST, rarity: 'legendary', value: 0, desc: 'Seal of the King' },

// --- SECRET CHAIN ITEMS ---
    'q_chain_1': { id: 'q_chain_1', name: 'Strange Coin', type: CARD_TYPES.QUEST, rarity: 'rare', value: 0, desc: 'It vibrates softly.' },
    'q_chain_2': { id: 'q_chain_2', name: 'Gem Eye', type: CARD_TYPES.QUEST, rarity: 'rare', value: 0, desc: 'It looks around wildly.' },
    'q_chain_3': { id: 'q_chain_3', name: 'Spectral Handle', type: CARD_TYPES.QUEST, rarity: 'legendary', value: 0, desc: 'Cold to the touch.' },
    'q_chain_4': { id: 'q_chain_4', name: 'Void Key', type: CARD_TYPES.QUEST, rarity: 'legendary', value: 0, desc: 'Opens the unknown.' },

    // --- SKILLS (Converted to Effect System) ---
    
    // Tier 1 Common
    's_bite':   { id: 's_bite',   name: 'Rabid Bite', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DAMAGE', val: 2, target: 'ENEMY' }], desc: 'Deal 2 DMG' },
    
    's_claw':   { id: 's_claw',   name: 'Feral Claw', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DAMAGE', val: 3, target: 'ENEMY' }], desc: 'Deal 3 DMG' },
    
    's_mend':   { id: 's_mend',   name: 'Mend',       type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [{ type: 'HEAL', val: 3, target: 'SELF' }], desc: 'Heal 3 HP' },

    // Tier 1 Rare
    's_web':    { id: 's_web',    name: 'Web Shot',     type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, 
                  effects: [{ type: 'DAMAGE', val: 5, target: 'ENEMY' }], desc: 'Deal 5 DMG' },

    // Tier 2 Common
    's_smash':  { id: 's_smash',  name: 'Big Smash',    type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, 
                  effects: [{ type: 'DAMAGE', val: 8, target: 'ENEMY' }], desc: 'Deal 8 DMG' },

    // Tier 2 Rare
    's_drain':  { id: 's_drain',  name: 'Void Spike',   type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, 
                  effects: [
                      { type: 'DAMAGE', val: 6, target: 'ENEMY' },
                      { type: 'HEAL', val: 2, target: 'SELF' } // Added logic for drain
                  ], desc: 'Deal 6 DMG & Heal 2' },

    // Tier 3 Legendary
    's_stone':  { id: 's_stone',  name: 'Stone Form',   type: CARD_TYPES.SKILL, rarity: 'legendary', cost: 2, 
                  effects: [{ type: 'BLOCK', val: 15, target: 'SELF' }], desc: 'Gain 15 Block' },

    // --- LIBRARY SKILLS (From Chests/Trainer) ---
    's_rush':   { id: 's_rush', name: 'Adrenaline', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'GAIN_AP', val: 2, target: 'SELF' }], desc: 'Gain 2 AP' },

    's_exec':   { id: 's_exec', name: 'Execution', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 3, 
                  effects: [{ type: 'DAMAGE', val: 15, target: 'ENEMY' }], desc: 'Deal 15 DMG' },

    's_step':   { id: 's_step', name: 'Quick Step', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'BLOCK', val: 2, target: 'SELF' }], desc: 'Gain 2 Block' },

    's_wall':   { id: 's_wall', name: 'Heavy Plate', type: CARD_TYPES.SKILL, rarity: 'common', cost: 2, 
                  effects: [{ type: 'BLOCK', val: 10, target: 'SELF' }], desc: 'Gain 10 Block' },

    's_shiv':   { id: 's_shiv', name: 'Shiv', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DAMAGE', val: 3, target: 'ENEMY' }], desc: 'Deal 3 DMG' },

    's_wild':   { id: 's_wild', name: 'Reckless Swing', type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [{ type: 'DAMAGE', val: 8, target: 'ENEMY' }], desc: 'Deal 8 DMG' },

    's_holy':   { id: 's_holy', name: 'Holy Light', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, 
                  effects: [{ type: 'HEAL', val: 8, target: 'SELF' }], desc: 'Heal 8 HP' },

    's_perf':   { id: 's_perf', name: 'Perfect Guard', type: CARD_TYPES.SKILL, rarity: 'legendary', cost: 3, 
                  effects: [{ type: 'BLOCK', val: 20, target: 'SELF' }], desc: 'Gain 20 Block' },

    's_plan':   { id: 's_plan', name: 'Planning', type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [{ type: 'DRAW', val: 2, target: 'SELF' }], desc: 'Draw 2 Cards' },

    // Trainer Exclusive Skills
    's_heavy':  { id: 's_heavy', name: 'Heavy Strike', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, 
                  effects: [{ type: 'DAMAGE', val: 10, target: 'ENEMY' }], desc: 'Deal 10 DMG' },

    's_iron':   { id: 's_iron', name: 'Iron Skin', type: CARD_TYPES.SKILL, rarity: 'rare', cost: 1, 
                  effects: [{ type: 'BLOCK', val: 8, target: 'SELF' }], desc: 'Gain 8 Block' },
    
    // Hero Starting Skills (Explicit Copies for reference in Decks)
    's_fast':   { id: 's_fast', name: 'Quick Draw', type: CARD_TYPES.SKILL, rarity: 'common', cost: 0, 
                  effects: [{ type: 'DRAW', val: 2, target: 'SELF' }], desc: 'Draw 2 Cards' },

    's_bash':   { id: 's_bash', name: 'Shield Bash', type: CARD_TYPES.SKILL, rarity: 'common', cost: 1, 
                  effects: [
                      { type: 'DAMAGE', val: 3, target: 'ENEMY' },
                      { type: 'BLOCK', val: 3, target: 'SELF' }
                  ], desc: '3 DMG & 3 Block' },

    's_bolt':   { id: 's_bolt',   name: 'Dark Bolt',    type: CARD_TYPES.SKILL, rarity: 'rare', cost: 2, 
                  effects: [{ type: 'DAMAGE', val: 12, target: 'ENEMY' }], desc: 'Deal 12 DMG' },

    's_strike': { id: 's_strike', name: 'Strike', type: CARD_TYPES.SKILL, cost: 1, effects: [{type:'DAMAGE', val:3, target:'ENEMY'}], desc: 'Deal 3 DMG' },

    's_defend': { id: 's_defend', name: 'Defend', type: CARD_TYPES.SKILL, cost: 1, effects: [{type:'BLOCK', val:3, target:'SELF'}], desc: 'Gain 3 Block' }
};

const HERO_DECKS = {
    'h_ironclad': [
        ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'],
        ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'],
        ITEM_DB['s_mend'],
        ITEM_DB['s_bash']
    ],
    'h_shadow': [
        ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'],
        ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'],
        ITEM_DB['s_fast']
    ],
    'h_weaver': [
        ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'], ITEM_DB['s_strike'],
        ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'], ITEM_DB['s_defend'],
        ITEM_DB['s_bolt']
    ]
};

/* --- LOOT TABLES --- */
const LOOT_TABLES = {
    'tier1_standard': [
        { id: 'l_dagger', weight: 20 },
        { id: 'l_shield', weight: 20 },
        { id: 's_bite',   weight: 20 },
        { id: 's_claw',   weight: 20 },
        { id: 's_mend',   weight: 10 },
        { id: null,       weight: 410 } // ~80% chance of nothing (Total weight 500)
    ],
    'tier1_elite': [
        { id: 's_web',    weight: 30 },
        { id: 'l_shield', weight: 10 },
        { id: null,       weight: 460 }
    ],
    'tier2_standard': [
        { id: 's_smash',  weight: 30 },
        { id: 'l_amulet', weight: 30 },
        { id: 's_bolt',   weight: 10 },
        { id: null,       weight: 280 } // Fallback
    ],
    'tier3_void': [
        { id: 's_stone',  weight: 30 },
        { id: 'l_bark',   weight: 30 },
        { id: 'l_scale',  weight: 30 },
        { id: 'l_cloak',  weight: 10 },
        { id: null,       weight: 400 }
    ],
    'chest_random': [
        { id: 'l_cloak',  weight: 10 },
        { id: 'l_spear',  weight: 20 },
        { id: 's_mend',   weight: 40 },
        { id: 'l_goo',    weight: 30 }
    ],
    'tier4_boss_loot': [
        { id: 'l_boss_relic', weight: 10 },
        { id: 'l_blood',      weight: 30 },
        { id: 'l_scale',      weight: 30 },
        { id: 's_stone',      weight: 30 },
        { id: null,           weight: 400 }
    ],
    'secret_boss_loot': [
        { id: 'l_infinity_blade', weight: 100 }
    ],
    'chest_t1_rare_items': [
        { id: 'l_goo',    weight: 1 },
        { id: 'l_spear',  weight: 1 },
        { id: 's_web',    weight: 1 }
    ],
    'chest_t2_rare_items': [
        { id: 's_drain',   weight: 1 },
        { id: 'l_cloak',  weight: 1 },
        { id: 's_bolt',  weight: 1 }
    ],
    'chest_t3_rare_items': [
        { id: 's_stone',  weight: 1 },
        { id: 'l_bark',   weight: 1 },
        { id: 'l_scale',  weight: 1 }
    ],
};

function rollLoot(tableId) {
    const table = LOOT_TABLES[tableId];
    if (!table) return null;

    // Calculate total weight
    const totalWeight = table.reduce((sum, entry) => sum + entry.weight, 0);
    let random = Math.floor(Math.random() * totalWeight);

    // Select item
    for (let entry of table) {
        random -= entry.weight;
        if (random < 0) {
            if (entry.id === null) return null; // Drop nothing
            return JSON.parse(JSON.stringify(ITEM_DB[entry.id]));
        }
    }
    return null;
}

const CURSE_CARD = { id: 'c_fatigue', name: 'Fatigue', type: CARD_TYPES.CURSE, cost: 1, desc: 'Unplayable trash.' };

const EVENT_MONSTERS = {
    'm_ghost': { id: 'm_ghost', name: 'Vengeful Spirit', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 4, rewardId: 'm_ghost', desc: 'Hit by Physical' },
    'm_mimic_t1': { id: 'm_mimic_t1', name: 'Wooden Mimic', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 5, desc: 'It has splinters!' },
    'm_mimic_t2': { id: 'm_mimic_t2', name: 'Iron Mimic', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 6, desc: 'Hard to chew!' },
    'm_mimic_t3': { id: 'm_mimic_t3', name: 'Gilded Mimic', type: CARD_TYPES.MONSTER, hp: 35, maxHp: 35, atk: 7, desc: 'Rich in flavor!' },
    'm_giant_groggy': { id: 'm_giant_groggy', name: 'Groggy Giant', type: CARD_TYPES.MONSTER, hp: 40, maxHp: 40, atk: 5, rewardId: 'm_goblin', desc: 'Disturbed!' },
    'm_giant_awakened': { id: 'm_giant_awakened', name: 'Awakened Giant', type: CARD_TYPES.MONSTER, hp: 60, maxHp: 60, atk: 8, rewardId: 'm_goblin', desc: 'Enraged!' },
    'm_bard_angry': { id: 'm_bard_angry', name: 'Angry Bard', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 3, rewardId: 'm_goblin', desc: 'You monster!' }
};

// --- TIERED DATA ---

const COMMON_EVENTS = [
    { 
        id: 'e_shrine', name: 'Cursed Shrine', type: CARD_TYPES.EVENT, minTier: 1, desc: 'A dark aura hums.',
        choices: [
            { label: 'Pray (Heal 10, Get Curse)', effect: 'pray' },
            { label: 'Desecrate (Fight Spirit)', effect: 'fight' },
            { label: 'Ignore (Leave)', effect: 'leave' }
        ]
    },
    {
        id: 'e_trap', name: 'Trap Door', type: CARD_TYPES.EVENT, minTier: 1, desc: 'The floor crumbles!',
        choices: [
            { label: 'Jump (Unequip Random Item)', effect: 'trap_unequip' },
            { label: 'Brace (Take 5 DMG)', effect: 'trap_dmg' }
        ]
    },
    {
        id: 'e_chest_t1', name: 'Wooden Chest', type: CARD_TYPES.EVENT, minTier: 1, desc: 'Is it breathing?',
        choices: [
            { label: 'Open it', effect: 'chest_open_t1' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_chest_t2', name: 'Iron Chest', type: CARD_TYPES.EVENT, minTier: 2, desc: 'It seems sturdy.',
        choices: [
            { label: 'Open it', effect: 'chest_open_t2' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_chest_t3', name: 'Gilded Chest', type: CARD_TYPES.EVENT, minTier: 3, desc: 'It gleams with promise.',
        choices: [
            { label: 'Open it', effect: 'chest_open_t3' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_tribute', name: 'Dark Altar', type: CARD_TYPES.EVENT, minTier: 2, desc: 'Requires a sacrifice.',
        choices: [
            { label: 'Sacrifice (Lose 5 Max HP, Get Relic)', effect: 'tribute_pay' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_trainer', name: 'Old Master', type: CARD_TYPES.EVENT, minTier: 2, desc: 'He offers training.',
        choices: [
            { label: 'Train Attack (Get Heavy Strike)', effect: 'train_str' },
            { label: 'Train Defense (Get Iron Skin)', effect: 'train_def' },
            { label: 'Ignore', effect: 'leave' }
        ]
    },
    {
        id: 'e_spring', name: 'Magic Spring', type: CARD_TYPES.EVENT, minTier: 1, desc: 'Glowing blue water.',
        choices: [
            { label: 'Drink (Heal 5 HP)', effect: 'spring_heal' },
            { label: 'Bottle (Get +1 Max HP)', effect: 'spring_max' }
        ]
    },
    {
        id: 'e_gambler', name: "Gambler's Den", type: CARD_TYPES.EVENT, minTier: 1, desc: 'A shady figure offers a game of chance.',
        choices: [
            { label: 'Bet 10 Gold (50% Win)', effect: 'gamble_gold', reqGold: 10 },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_fountain', name: 'Fountain of Youth', type: CARD_TYPES.EVENT, minTier: 2, desc: 'The water shimmers with life.',
        choices: [
            { label: 'Drink Deep (Full Heal, -1 Max HP)', effect: 'fountain_full_heal' },
            { label: 'Sip (Heal 5 HP)', effect: 'fountain_sip' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_giant', name: 'Sleeping Giant', type: CARD_TYPES.EVENT, minTier: 2, desc: 'A colossal giant slumbers in your path.',
        choices: [
            { label: 'Sneak Past (50% fail)', effect: 'giant_sneak' },
            { label: 'Poke it (Fight Groggy Giant)', effect: 'giant_attack' }
        ]
    },
    {
        id: 'e_bard', name: 'Wandering Bard', type: CARD_TYPES.EVENT, minTier: 1, desc: 'A bard offers a song for some coin.',
        choices: [
            { label: 'Pay 5g for a song (+1 AP buff)', effect: 'bard_pay', reqGold: 5 },
            { label: 'Rob the bard (Fight)', effect: 'bard_rob' },
            { label: 'Listen for free', effect: 'leave' }
        ]
    },
    {
        id: 'e_armory', name: 'Abandoned Armory', type: CARD_TYPES.EVENT, minTier: 1, desc: 'You can take one item for the next fight.',
        choices: [
            { label: 'Take Sword (+2 Atk Buff)', effect: 'armory_sword' },
            { label: 'Take Shield (+2 Block Buff)', effect: 'armory_shield' }
        ]
    },
    {
        id: 'e_idol', name: 'Cursed Idol', type: CARD_TYPES.EVENT, minTier: 2, desc: 'An idol pulses with dark energy.',
        choices: [
            { label: 'Take Idol (Get Relic, Get Curse)', effect: 'idol_take' },
            { label: 'Destroy it', effect: 'leave' }
        ]
    },
    {
        id: 'e_hermit', name: 'Hermit\'s Hut', type: CARD_TYPES.EVENT, minTier: 1, desc: 'A hermit offers a trade.',
        choices: [
            { label: 'Trade 10 HP for a rare skill', effect: 'hermit_trade_hp' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_goblin_shop', name: 'Goblin Merchant', type: CARD_TYPES.EVENT, minTier: 1, desc: 'A goblin offers "rare" goods.',
        choices: [
            { label: 'Buy Mystery Potion (15g)', effect: 'goblin_potion', reqGold: 15 },
            { label: 'Buy Shiny Rock (10g)', effect: 'goblin_rock', reqGold: 10 },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    {
        id: 'e_library', name: 'Ancient Library', type: CARD_TYPES.EVENT, minTier: 2, desc: 'Scrolls of forgotten lore are scattered around.',
        choices: [
            { label: 'Study Combat (Get Attack Skill)', effect: 'library_combat' },
            { label: 'Study Defense (Get Defense Skill)', effect: 'library_defense' }
        ]
    },
    {
        id: 'e_rift', name: 'Void Rift', type: CARD_TYPES.EVENT, minTier: 3, desc: 'A tear in reality hums before you.',
        choices: [
            { label: 'Reach Inside', effect: 'rift_touch' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    // Chain Step 1 (Start - Greenlands)
    {
        id: 'e_chain_1', name: 'The Old Beggar', type: CARD_TYPES.EVENT, minTier: 1, desc: 'A hooded figure extends a trembling hand.',
        choices: [
            { label: 'Give 5 Gold', effect: 'chain_step_1', reqGold: 5 },
            { label: 'Ignore', effect: 'leave' }
        ]
    },
    // Chain Step 2 (Desert - Requires Coin)
    {
        id: 'e_chain_2', name: 'Buried Statue', type: CARD_TYPES.EVENT, minTier: 2, desc: 'A one-eyed statue protrudes from the sand.',
        choices: [
            { label: 'Insert Strange Coin', effect: 'chain_step_2', reqItem: 'q_chain_1' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    // Chain Step 3 (Dead Lands - Requires Gem)
    {
        id: 'e_chain_3', name: 'Whispering Tomb', type: CARD_TYPES.EVENT, minTier: 3, desc: 'A grave has a slot shaped like an eye.',
        choices: [
            { label: 'Place Gem Eye', effect: 'chain_step_3', reqItem: 'q_chain_2' },
            { label: 'Desecrate', effect: 'fight' },
            { label: 'Leave', effect: 'leave' }
        ]
    },
    // Chain Step 4 (Castle - Requires Handle)
    {
        id: 'e_chain_4', name: 'Forgotten Smithy', type: CARD_TYPES.EVENT, minTier: 3, desc: 'A ghostly anvil sits before a blade without a hilt.',
        choices: [
            { label: 'Attach Spectral Handle', effect: 'chain_step_4', reqItem: 'q_chain_3' },
            { label: 'Search for scrap', effect: 'leave' }
        ]
    },
    // Chain Step 5 (The Dungeons - Requires Key - Unlocks Node)
    {
        id: 'e_chain_5', name: 'The Flickering Gateway', type: CARD_TYPES.EVENT, minTier: 4, desc: 'A wall of reality glitches in front of you.',
        targetNode: 'n_secret',
        choices: [
            { label: 'Insert Void Key', effect: 'unlock_node', reqItem: 'q_chain_4' },
            { label: 'Touch it', effect: 'trap_dmg' },
            { label: 'Walk away', effect: 'leave' }
        ]
    }
];

const MAP_GRAPH = {
    // --- START: THE GREENLANDS ---
    'n1': { id: 'n1', name: 'Village Gates',    type: 'VILLAGE_OUTSKIRTS', parents: [], x: 100, y: 400 },

    // Branch 1: The High Road (Combat Heavy)
    'n2a':{ id: 'n2a', name: 'Old Bridge',      type: 'OLD_BRIDGE',        parents: ['n1'], x: 250, y: 250 },
    'n3a':{ id: 'n3a', name: 'Mossy Ruins',     type: 'MOSSY_RUINS',       parents: ['n2a'], x: 400, y: 200 },
    
    // Branch 2: The Low Road (Event/Merchant Heavy)
    'n2b':{ id: 'n2b', name: 'Whispering Woods',type: 'WHISPERING_WOODS',  parents: ['n1'], x: 250, y: 550 },
    'n3b':{ id: 'n3b', name: 'Traveler\'s Rest',type: 'TRAVELERS_REST',    parents: ['n2b'], x: 400, y: 600 },

    // Convergence 1: Border to Desert
    'n4': { id: 'n4', name: 'Canyon Pass',      type: 'CANYON_PASS',       parents: ['n3a', 'n3b'], x: 550, y: 400 },

    // --- SPLIT: THE DESERT ---
    // North Path: Dangerous Shortcuts
    'n5a':{ id: 'n5a', name: 'Scorpion Pit',    type: 'SCORPION_PIT',      parents: ['n4'], x: 700, y: 250 },
    'n6a':{ id: 'n6a', name: 'Sand Dunes',      type: 'SAND_DUNES',        parents: ['n5a'], x: 850, y: 200 },

    // South Path: Safe Trade Route// South Path: Safe Trade Route
    'n5b':{ id: 'n5b', name: 'Cursed Oasis',    type: 'CURSED_OASIS',      parents: ['n4'], x: 700, y: 550 },
    'n6b':{ id: 'n6b', name: 'Desert Bazaar',   type: 'DESERT_BAZAAR',     parents: ['n5b'], x: 850, y: 600 },

    // Convergence 2: Border to Dead Lands
    'n7': { id: 'n7', name: 'Foggy Graveyard',  type: 'FOGGY_GRAVEYARD',   parents: ['n6a', 'n6b'], x: 1000, y: 400 },

    // --- THE DEAD LANDS (Web Structure) ---
    'n8a':{ id: 'n8a', name: 'Haunted Hills',   type: 'HAUNTED_HILLS',     parents: ['n7'], x: 1150, y: 300 },
    'n8b':{ id: 'n8b', name: 'Crypt Entrance',  type: 'CRYPT_ENTRANCE',    parents: ['n7'], x: 1150, y: 500 },
    
    'n9': { id: 'n9', name: 'Mausoleum',        type: 'MAUSOLEUM',         parents: ['n8a', 'n8b'], x: 1300, y: 400 },

    // --- THE CASTLE (Gauntlet) ---
    'n10':{ id: 'n10',name: 'Castle Gates',     type: 'CASTLE_GATES',      parents: ['n9'], x: 1450, y: 400 },
    'n11':{ id: 'n11',name: 'Void Trader',      type: 'VOID_TRADER',       parents: ['n10'], x: 1600, y: 250 }, // Side room
    'n12':{ id: 'n12',name: 'The Dungeons',     type: 'THE_DUNGEONS',      parents: ['n10'], x: 1600, y: 550 }, // Side room
    
    'n13':{ id: 'n13',name: 'Grand Hall',       type: 'GRAND_HALL',        parents: ['n11', 'n12'], x: 1750, y: 400 },
    'n14':{ id: 'n14',name: 'Throne Room',      type: 'THRONE_ROOM',       parents: ['n13'], x: 1950, y: 400 },

    // --- SECRET NODE ---
    'n_secret': { id: 'n_secret', name: '???', type: 'SECRET_VOID', parents: ['n12'], x: 1800, y: 700, isSecret: true }, // Hidden until unlocked
};

/* --- DUNGEON NODE CONFIGURATIONS --- */
const NODE_CONFIGS = {
    'SECRET_VOID': {
        icon: '', minCards: 0, maxCards: 0,
        monsters: [],
        events: [], bossPool: ['g_secret_boss'] // A hard challenge
    },

    // --- REGION 1: THE GREENLANDS (Easy) ---
    'VILLAGE_OUTSKIRTS': {
        icon: '', minCards: 4, maxCards: 5,
        monsters: ['m_rat', 'm_goblin', 'm_thief', 'm_bat_swarm'],
        events: ['e_chest_t1'], bossPool: []
    },
    'WHISPERING_WOODS': {
        icon: '', minCards: 5, maxCards: 6,
        monsters: ['m_goblin', 'm_wolf', 'm_bear', 'm_hornet', 'm_treant'],
        events: ['e_trap', 'e_spring'], bossPool: ['mb_brood', 'mb_bandit_king', 'g_wolf_pack']
    },
    'MOSSY_RUINS': {
        icon: '', minCards: 5, maxCards: 7,
        monsters: ['m_slime', 'm_spider', 'm_moss_golem', 'm_bat_swarm'],
        events: ['e_shrine', 'e_chain_1'], bossPool: ['mb_giant_slime']
    },
    'OLD_BRIDGE': {
        icon: '', minCards: 6, maxCards: 6,
        monsters: ['m_bandit', 'm_orc', 'm_thief', 'm_shaman'],
        events: ['e_trap'], bossPool: ['mb_troll', 'mb_chimera']
    },
    
    // --- MERCHANT 1 ---
    'TRAVELERS_REST': {
        icon: '', isMerchant: true,
        itemPool: [
            { id: 'l_dagger', price: 15 }, { id: 'l_shield', price: 15 },
            { id: 's_mend', price: 20 }, { id: 's_rush', price: 25 }, 
            { id: 'q_old_key', price: 50 }, { id: 'c_potion_s', price: 10 }
        ]
    },

    // --- REGION 2: THE SUN-SCORCHED SANDS (Medium) ---
    'SAND_DUNES': {
        icon: '', minCards: 6, maxCards: 8,
        monsters: ['m_kobold', 'm_sandworm', 'm_scorpion', 'm_dust_devil'],
        events: ['e_chest_t2', 'e_chain_2'], bossPool: ['mb_sandworm_q']
    },
    'CANYON_PASS': {
        icon: '', minCards: 7, maxCards: 9,
        monsters: ['m_kobold', 'm_orc', 'm_vulture', 'm_nomad'],
        events: ['e_trap', 'e_tribute'], bossPool: []
    },
    'CURSED_OASIS': {
        icon: '', minCards: 6, maxCards: 8,
        monsters: ['m_slime', 'm_leech', 'm_sand_spirit', 'm_cactus'],
        events: ['e_spring', 'e_shrine'], bossPool: ['mb_brood', 'mb_giant_slime'] 
    },
    'SCORPION_PIT': {
        icon: '', minCards: 8, maxCards: 8,
        monsters: ['m_spider', 'm_scorpion', 'm_basilisk', 'm_mummy'],
        events: ['e_trap'], bossPool: ['mb_scorp_king']
    },

    // --- MERCHANT 2 ---
    'DESERT_BAZAAR': {
        icon: '', isMerchant: true,
        itemPool: [
            { id: 'l_spear', price: 50 }, { id: 's_web', price: 40 },
            { id: 's_bolt', price: 45 }, { id: 'l_goo', price: 50 }
        ]
    },

    // --- REGION 3: THE DEAD LANDS (Hard) ---
    'FOGGY_GRAVEYARD': {
        icon: '', minCards: 8, maxCards: 10,
        monsters: ['m_skeleton', 'm_zombie', 'm_ghoul', 'm_bat_swarm'],
        events: ['e_shrine'], bossPool: ['mb_necromancer']
    },
    'HAUNTED_HILLS': {
        icon: '', minCards: 8, maxCards: 10,
        monsters: ['m_wraith', 'm_wolf', 'm_specter', 'm_banshee'],
        events: ['e_trap', 'e_chain_3', 'e_chest_t3'], bossPool: ['mb_lich', 'mb_vampire']
    },
    'CRYPT_ENTRANCE': {
        icon: '', minCards: 9, maxCards: 11,
        monsters: ['m_skeleton', 'm_bone_warrior', 'm_mummy', 'm_gargoyle'],
        events: ['e_shrine'], bossPool: ['mb_lich', 'mb_necromancer']
    },
    'MAUSOLEUM': {
        icon: '', minCards: 10, maxCards: 12,
        monsters: ['m_wraith', 'm_necromancer', 'm_abomination', 'm_zombie'],
        events: ['e_shrine'], bossPool: ['mb_lich']
    },

    // --- MERCHANT 3 ---
    'VOID_TRADER': {
        icon: '', isMerchant: true,
        itemPool: [
            { id: 'l_cloak', price: 100 }, { id: 'l_blood', price: 120 },
            { id: 's_stone', price: 80 }, { id: 's_exec', price: 90 }
        ]
    },

    // --- REGION 4: THE DARK CASTLE (Endgame) ---
    'CASTLE_GATES': {
        icon: '', minCards: 10, maxCards: 12,
        monsters: ['m_guard', 'm_armor', 'm_gargoyle', 'm_orc'],
        events: ['e_trap', 'e_chain_4'], bossPool: ['mb_knight', 'mb_commander']
    },
    'THE_DUNGEONS': {
        icon: '', minCards: 10, maxCards: 14,
        monsters: ['m_rat', 'm_skeleton', 'm_executioner', 'm_imp'],
        events: ['e_tribute', 'e_chain_5'], bossPool: []
    },
    'GRAND_HALL': {
        icon: '', minCards: 12, maxCards: 15,
        monsters: ['m_royal_guard', 'm_sorcerer', 'm_dark_knight', 'm_warlock'],
        events: ['e_trainer'], bossPool: ['mb_knight', 'mb_gargoyle_p']
    },
    'THRONE_ROOM': {
        icon: '', minCards: 1, maxCards: 1, // Just the boss
        monsters: [],
        events: [], bossPool: ['mb_malakor', 'mb_void_dragon']
    }
};

const MONSTER_DB = {
    // Tier 1
    'm_goblin': { id: 'm_goblin', name: 'Goblin', type: CARD_TYPES.MONSTER, hp: 4, maxHp: 4, atk: 2, lootTable: 'tier1_standard', desc: 'Common Enemy' },
    'm_rat':    { id: 'm_rat',    name: 'Giant Rat', type: CARD_TYPES.MONSTER, hp: 3, maxHp: 3, atk: 3, lootTable: 'tier1_standard', desc: 'Fast Enemy' },
    'm_slime':  { id: 'm_slime',  name: 'Acid Slime', type: CARD_TYPES.MONSTER, hp: 5, maxHp: 5, atk: 1, lootTable: 'tier1_standard', desc: 'Sticky' },
    'm_kobold': { id: 'm_kobold', name: 'Kobold', type: CARD_TYPES.MONSTER, hp: 6, maxHp: 6, atk: 3, lootTable: 'tier1_elite', desc: 'Elite Scout' },
    
    // Tier 2
    'm_orc':    { id: 'm_orc',    name: 'Orc', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 4, lootTable: 'tier2_standard', desc: 'Heavy Hitter' },
    'm_spider': { id: 'm_spider', name: 'Cave Spider', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 2, lootTable: 'tier2_standard', desc: 'Poisonous' },
    'm_wolf':   { id: 'm_wolf',   name: 'Dire Wolf', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 3, lootTable: 'tier2_standard', desc: 'Fast Biter' },
    'm_cultist':{ id: 'm_cultist',name: 'Dark Cultist', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 5, lootTable: 'tier2_standard', desc: 'Glass Cannon' },
    'm_leech':  { id: 'm_leech',  name: 'Void Leech', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 2, lootTable: 'tier2_standard', desc: 'Life Drainer' },

    // Tier 3
    'm_golem':  { id: 'm_golem',  name: 'Stone Golem', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 2, lootTable: 'tier3_void', desc: 'Tank' },
    'm_assassin':{ id: 'm_assassin', name: 'Void Assassin', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 6, lootTable: 'tier3_void', desc: 'High Damage!' },
    'm_ent':    { id: 'm_ent',    name: 'Rotting Ent', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 3, lootTable: 'tier3_void', desc: 'Ancient Wood' },
    'm_drake':  { id: 'm_drake',  name: 'Baby Drake', type: CARD_TYPES.MONSTER, hp: 18, maxHp: 18, atk: 5, lootTable: 'tier3_void', desc: 'Fierce!' },
    
    'm_bandit': { id: 'm_bandit', name: 'Bandit', type: CARD_TYPES.MONSTER, hp: 6, maxHp: 6, atk: 3, lootTable: 'tier1_standard', desc: 'Thief' },
    'm_skeleton': { id: 'm_skeleton', name: 'Skeleton', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 3, lootTable: 'tier2_standard', desc: 'Undead' },
    'm_sandworm': { id: 'm_sandworm', name: 'Sand Worm', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 4, lootTable: 'tier2_standard', desc: 'Burrower' },
    'm_wraith':   { id: 'm_wraith', name: 'Wraith', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 5, lootTable: 'tier3_void', desc: 'Spirit' },
    'm_guard':    { id: 'm_guard', name: 'Castle Guard', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 4, lootTable: 'tier2_standard', desc: 'Armored' },
    // --- NEW EXPANSION: REGION 1 (Greenlands) ---
    'm_bear':       { id: 'm_bear', name: 'Brown Bear', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 3, lootTable: 'tier1_standard', desc: 'High HP' },
    'm_thief':      { id: 'm_thief', name: 'Petty Thief', type: CARD_TYPES.MONSTER, hp: 5, maxHp: 5, atk: 3, lootTable: 'tier1_standard', desc: 'Sneaky' },
    'm_hornet':     { id: 'm_hornet', name: 'Giant Hornet', type: CARD_TYPES.MONSTER, hp: 3, maxHp: 3, atk: 5, lootTable: 'tier1_standard', desc: 'Glass Cannon' },
    'm_treant':     { id: 'm_treant', name: 'Young Treant', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 1, lootTable: 'tier1_elite', desc: 'Bark Skin' },
    'm_moss_golem': { id: 'm_moss_golem', name: 'Moss Golem', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 2, lootTable: 'tier1_elite', desc: 'Ruins Guard' },
    'm_shaman':     { id: 'm_shaman', name: 'Goblin Shaman', type: CARD_TYPES.MONSTER, hp: 6, maxHp: 6, atk: 3, lootTable: 'tier1_standard', desc: 'Magic User' },
    'm_bat_swarm':  { id: 'm_bat_swarm', name: 'Bat Swarm', type: CARD_TYPES.MONSTER, hp: 4, maxHp: 4, atk: 2, lootTable: 'tier1_standard', desc: 'Annoying' },

    // --- GROUPS ---
    'g_goblin_raid': { 
        id: 'g_goblin_raid', 
        type: CARD_TYPES.GROUP, 
        members: ['m_goblin', 'm_goblin', 'm_shaman'], // 2 Goblins + 1 Shaman
        desc: 'Goblin Ambush' 
    },
    'g_wolf_pack': { 
        id: 'g_wolf_pack', 
        type: CARD_TYPES.GROUP, 
        members: ['m_wolf', 'm_wolf', 'm_wolf'], 
        desc: 'Wolf Pack' 
    },

    // --- NEW EXPANSION: REGION 2 (Desert) ---
    'm_scorpion':   { id: 'm_scorpion', name: 'Scorpion', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 4, lootTable: 'tier2_standard', desc: 'Venomous' },
    'm_vulture':    { id: 'm_vulture', name: 'Carrion Bird', type: CARD_TYPES.MONSTER, hp: 6, maxHp: 6, atk: 4, lootTable: 'tier1_standard', desc: 'Flying' },
    'm_mummy':      { id: 'm_mummy', name: 'Mummy', type: CARD_TYPES.MONSTER, hp: 14, maxHp: 14, atk: 2, lootTable: 'tier2_standard', desc: 'Undead' },
    'm_nomad':      { id: 'm_nomad', name: 'Desert Nomad', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 3, lootTable: 'tier2_standard', desc: 'Warrior' },
    'm_basilisk':   { id: 'm_basilisk', name: 'Basilisk', type: CARD_TYPES.MONSTER, hp: 16, maxHp: 16, atk: 3, lootTable: 'tier2_standard', desc: 'Petrifying' },
    'm_sand_spirit':{ id: 'm_sand_spirit', name: 'Sand Spirit', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 5, lootTable: 'tier2_standard', desc: 'Ethereal' },
    'm_cactus':     { id: 'm_cactus', name: 'Living Cactus', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 2, lootTable: 'tier1_elite', desc: 'Spiky' },
    'm_dust_devil': { id: 'm_dust_devil', name: 'Dust Devil', type: CARD_TYPES.MONSTER, hp: 7, maxHp: 7, atk: 4, lootTable: 'tier2_standard', desc: 'Windy' },

    // --- NEW EXPANSION: REGION 3 (Dead Lands) ---
    'm_zombie':     { id: 'm_zombie', name: 'Zombie', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 2, lootTable: 'tier2_standard', desc: 'Relentless' },
    'm_ghoul':      { id: 'm_ghoul', name: 'Flesh Ghoul', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 4, lootTable: 'tier2_standard', desc: 'Hungry' },
    'm_bone_warrior':{ id: 'm_bone_warrior', name: 'Bone Warrior', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 5, lootTable: 'tier3_void', desc: 'Armed' },
    'm_necromancer':{ id: 'm_necromancer', name: 'Necromancer', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 6, lootTable: 'tier3_void', desc: 'Summoner' },
    'm_banshee':    { id: 'm_banshee', name: 'Banshee', type: CARD_TYPES.MONSTER, hp: 9, maxHp: 9, atk: 5, lootTable: 'tier3_void', desc: 'Screamer' },
    'm_gargoyle':   { id: 'm_gargoyle', name: 'Gargoyle', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 3, lootTable: 'tier3_void', desc: 'Stone Skin' },
    'm_abomination':{ id: 'm_abomination', name: 'Abomination', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 4, lootTable: 'tier3_void', desc: 'Hulking' },
    'm_specter':    { id: 'm_specter', name: 'Specter', type: CARD_TYPES.MONSTER, hp: 10, maxHp: 10, atk: 6, lootTable: 'tier3_void', desc: 'Ghostly' },

    // --- NEW EXPANSION: REGION 4 (Castle) ---
    'm_armor':      { id: 'm_armor', name: 'Dark Armor', type: CARD_TYPES.MONSTER, hp: 22, maxHp: 22, atk: 3, lootTable: 'tier3_void', desc: 'Animated' },
    'm_warlock':    { id: 'm_warlock', name: 'Cult Warlock', type: CARD_TYPES.MONSTER, hp: 12, maxHp: 12, atk: 7, lootTable: 'tier3_void', desc: 'Dark Magic' },
    'm_royal_guard':{ id: 'm_royal_guard', name: 'Royal Guard', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 5, lootTable: 'tier3_void', desc: 'Elite' },
    'm_imp':        { id: 'm_imp', name: 'Chaos Imp', type: CARD_TYPES.MONSTER, hp: 8, maxHp: 8, atk: 6, lootTable: 'tier2_standard', desc: 'Fast' },
    'm_executioner':{ id: 'm_executioner', name: 'Executioner', type: CARD_TYPES.MONSTER, hp: 30, maxHp: 30, atk: 4, lootTable: 'tier3_void', desc: 'Headsman' },
    'm_sorcerer':   { id: 'm_sorcerer', name: 'Void Sorcerer', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 6, lootTable: 'tier3_void', desc: 'Caster' },
    'm_dark_knight':{ id: 'm_dark_knight', name: 'Dark Knight', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 6, lootTable: 'tier3_void', desc: 'Champion' },

// --- NEW BOSSES ---
    // Tier 1 (Greenlands/Ruins)
    'mb_bandit_king': { id: 'mb_bandit_king', name: 'Bandit King', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 4, isBoss: true, goldReward: 3, desc: 'BOSS: Leader' },
    'mb_giant_slime': { id: 'mb_giant_slime', name: 'King Slime', type: CARD_TYPES.MONSTER, hp: 35, maxHp: 35, atk: 3, isBoss: true, goldReward: 3, desc: 'BOSS: Massive' },
    'mb_chimera':     { id: 'mb_chimera', name: 'Chimera', type: CARD_TYPES.MONSTER, hp: 30, maxHp: 30, atk: 5, isBoss: true, goldReward: 5, desc: 'BOSS: Hybrid' },

    // Tier 2 (Desert)
    'mb_sandworm_q':  { id: 'mb_sandworm_q', name: 'Sandworm Queen', type: CARD_TYPES.MONSTER, hp: 40, maxHp: 40, atk: 5, isBoss: true, goldReward: 5, desc: 'BOSS: Devourer' },
    'mb_scorp_king':  { id: 'mb_scorp_king', name: 'Scorpion King', type: CARD_TYPES.MONSTER, hp: 35, maxHp: 35, atk: 6, isBoss: true, goldReward: 5, desc: 'BOSS: Venomous' },

    // Tier 3 (Dead Lands)
    'mb_necromancer': { id: 'mb_necromancer', name: 'High Necromancer', type: CARD_TYPES.MONSTER, hp: 30, maxHp: 30, atk: 8, isBoss: true, goldReward: 10, desc: 'BOSS: Dark Magic' },
    'mb_vampire':     { id: 'mb_vampire', name: 'Vampire Count', type: CARD_TYPES.MONSTER, hp: 45, maxHp: 45, atk: 5, isBoss: true, goldReward: 10, desc: 'BOSS: Immortal' },

    // Tier 4 (Castle/Endgame)
    'mb_commander':   { id: 'mb_commander', name: 'Castle Commander', type: CARD_TYPES.MONSTER, hp: 50, maxHp: 50, atk: 6, goldReward: 13, lootTable: 'tier4_boss_loot', isBoss: true, desc: 'BOSS: Armored' },
    'mb_gargoyle_p':  { id: 'mb_gargoyle_p', name: 'Gargoyle Prime', type: CARD_TYPES.MONSTER, hp: 55, maxHp: 55, atk: 5, goldReward: 13, lootTable: 'tier4_boss_loot', isBoss: true, desc: 'BOSS: Stone God' },
    'mb_void_dragon': { id: 'mb_void_dragon', name: 'Void Dragon', type: CARD_TYPES.MONSTER, hp: 70, maxHp: 70, atk: 9, goldReward: 20, lootTable: 'tier4_boss_loot', isBoss: true, desc: 'BOSS: Apex' },

    // Bosses
    // Bosses
    'mb_troll': { id: 'mb_troll', name: 'Cave Troll', type: CARD_TYPES.MONSTER, hp: 20, maxHp: 20, atk: 4, isBoss: true, goldReward: 3, desc: 'BOSS: Gatekeeper' },
    'mb_brood': { id: 'mb_brood', name: 'Broodmother', type: CARD_TYPES.MONSTER, hp: 15, maxHp: 15, atk: 5, isBoss: true, goldReward: 3, desc: 'BOSS: Gatekeeper' },
    'mb_lich':  { id: 'mb_lich',  name: 'Elder Lich', type: CARD_TYPES.MONSTER, hp: 25, maxHp: 25, atk: 5, isBoss: true, goldReward: 5, desc: 'BOSS: Gatekeeper' },
    'mb_knight':{ id: 'mb_knight', name: 'Void Knight', type: CARD_TYPES.MONSTER, hp: 30, maxHp: 30, atk: 4, isBoss: true, goldReward: 5, desc: 'BOSS: Gatekeeper' },
    'mb_malakor':{ id: 'mb_malakor', name: 'MALAKOR', type: CARD_TYPES.MONSTER, hp: 60, maxHp: 60, atk: 7, isBoss: true, goldReward: 20, desc: 'FINAL BOSS' },

    // 1. The Underlings (Powerful Elites)
    'm_void_sentinel': { 
        id: 'm_void_sentinel', 
        name: 'Void Sentinel', 
        type: CARD_TYPES.MONSTER, 
        hp: 30, maxHp: 30, atk: 5, 
        lootTable: 'tier3_void', 
        desc: 'Guards the Emperor' 
    },

    // 2. The Secret Boss (Double Malakor's HP, higher DMG)
    'mb_azaroth': { 
        id: 'mb_azaroth', 
        name: 'Azaroth', 
        type: CARD_TYPES.MONSTER, 
        hp: 120, maxHp: 120, atk: 9, 
        goldReward: 100, 
        lootTable: 'secret_boss_loot', 
        isBoss: true, 
        desc: 'THE VOID EMPEROR' 
    },

    // 3. The Encounter Group (Boss + 2 Underlings)
    'g_secret_boss': { 
        id: 'g_secret_boss', 
        type: CARD_TYPES.GROUP, 
        members: ['m_void_sentinel', 'mb_azaroth', 'm_void_sentinel'], 
        desc: 'The Emperor awaits...' 
    },
};

const EVENT_DB = {}; 
COMMON_EVENTS.forEach(e => EVENT_DB[e.id] = e); // Quick mapping helper

/* --- STATE --- */

let state = {
    hero: null,
    deck: [],
    hand: [],
    discard: [],
    dungeonDeck: [],
    adventureRow: [], 
    equipped: [],
    selectedCardIndex: -1,
    turn: 1,
    completedNodes: [], // Array of node IDs (e.g. ['node_caverns'])
    currentNodeId: null, // The node currently being played
    collection: [], // Cards removed from deck
    inventory: [],
    gold: 0,
    settings: { autoAddToDeck: true },
    // Track temporary buffs from consumables (reset after dungeon)
    buffs: { atk: 0, block: 0, maxHp: 0, ap: 0 } 
};

/* --- EVENT MANAGER (STORE PATTERN) --- */
const EVENTS = {
    GAME_UPDATED: 'game_updated',       // Hand, Row, Deck, Discard changed
    HERO_UPDATED: 'hero_updated',       // HP, AP, Gold, Block, Stats changed
    INVENTORY_UPDATED: 'inv_updated',   // Equipment/Inventory changed
    MAP_UPDATED: 'map_updated'          // Nodes unlocked/completed
};

const EventManager = {
    listeners: {},
    on(event, callback) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(callback);
    },
    emit(event, data) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(cb => cb(data));
        }
    }
};

// Setup UI Subscribers
function initUIListeners() {
    // When Game State changes (Turn loop), redraw the Game Screen
    EventManager.on(EVENTS.GAME_UPDATED, () => {
        if (document.getElementById('game-container').style.display === 'flex') {
            render();
        }
    });

    // When Hero Stats change, update Game Bar AND Hero Screen
    EventManager.on(EVENTS.HERO_UPDATED, () => {
        // Update Game Top Bar (if visible)
        if (document.getElementById('game-container').style.display === 'flex') {
            render(); // This updates stats bar
        }
        // Update Hero Screen (if visible)
        if (document.getElementById('hero-screen').style.display === 'flex') {
            renderHeroScreen();
        }
    });

    // When Inventory changes, redraw Hero Screen
    EventManager.on(EVENTS.INVENTORY_UPDATED, () => {
        renderHeroScreen();
    });

    // When Map changes, redraw Nodes
    EventManager.on(EVENTS.MAP_UPDATED, () => {
        renderWorldMap();
    });
}

/* --- SCREEN MANAGER --- */
const Screens = {
    HERO_SELECT: {
        id: 'hero-selection',
        onEnter: () => {
            // If we need to re-render the selection cards dynamically, do it here
            // (Currently static in HTML, but could be moved here)
        }
    },
    MAP: {
        id: 'map-screen',
        onEnter: () => {
            document.getElementById('overlay').style.display = 'none';
            EventManager.emit(EVENTS.MAP_UPDATED); // Render Graph
            saveGame();
            
            // Init Drag Logic
            if (!mapState.initialized) {
                initMapDrag();
                mapState.initialized = true;
                document.getElementById('map-viewport').scrollLeft = 0;
            }
        }
    },
    GAME: {
        id: 'game-container',
        onEnter: () => {
            // Force update UI when entering combat
            EventManager.emit(EVENTS.GAME_UPDATED);
            EventManager.emit(EVENTS.HERO_UPDATED);
        }
    },
    HERO_DETAIL: {
        id: 'hero-screen',
        onEnter: () => {
            EventManager.emit(EVENTS.HERO_UPDATED);
            EventManager.emit(EVENTS.INVENTORY_UPDATED);
        }
    },
    MERCHANT: {
        id: 'merchant-screen',
        onEnter: () => {
            renderMerchantScreen();
        }
    },
    DECK_MANAGER: {
        id: 'deck-screen',
        onEnter: () => {
            // Consolidate Deck logic moved here
            state.deck = state.deck.concat(state.discard);
            state.discard = [];
            state.hand = [];
            renderDeckManager();
        }
    }
};

const ScreenManager = {
    activeScreen: null,
    
    show(screenName) {
        const target = Screens[screenName];
        if (!target) return;

        this.activeScreen = screenName;

        // 1. Hide All Screens
        Object.values(Screens).forEach(scr => {
            const el = document.getElementById(scr.id);
            if (el) el.style.display = 'none';
        });

        // 2. Show Target
        const el = document.getElementById(target.id);
        if (el) {
            el.style.display = 'flex';
            // 3. Run Setup Logic
            if (target.onEnter) target.onEnter();
        }
    }
};

/* --- STARTUP LOGIC --- */

function initSelectionScreen() {
    ScreenManager.show('HERO_SELECT');
    const container = document.getElementById('hero-select-container');
    HEROES.forEach((hero, index) => {
        // Create a card for the hero
        let div = createCardElement(hero);
        div.onclick = () => startGame(index);
        // Add a "Select" label
        let label = document.createElement('div');
        label.innerHTML = "<br><strong>CLICK TO SELECT</strong>";
        label.style.textAlign = "center";
        label.style.fontSize = "10px";
        div.appendChild(label);
        container.appendChild(div);
    });
}

function startGame(heroIndex) {
    // Switch UI
    document.getElementById('hero-selection').style.display = 'none';
    document.getElementById('game-container').style.display = 'flex';

    // Initialize State
    state.hero = JSON.parse(JSON.stringify(HEROES[heroIndex]));
    state.unlockedSecretNodes = [];
    // Load unique hero deck
    state.deck = JSON.parse(JSON.stringify(HERO_DECKS[state.hero.id]));
    
    // Hand/Discard reset
    state.hand = [];
    state.discard = [];
    state.equipped = [];
    
    // Start Item Logic
    state.equipped = [];
    if(state.hero.startItem) {
        let item = ITEM_DB[state.hero.startItem];
        // If item gives HP bonus immediately
        if(item.hpBonus) {
            state.hero.maxHp += item.hpBonus;
            state.hero.hp += item.hpBonus;
        }
        // If item gives AP bonus immediately
        if(item.apBonus) {
            state.hero.maxAp += item.apBonus;
            state.hero.ap += item.apBonus;
        }
        // We push deep copy to equipped
        state.equipped.push(JSON.parse(JSON.stringify(item)));
    }

    // Setup Deck
    shuffle(state.deck);
    
    // Go to Map
    ScreenManager.show('MAP');
    saveGame();

    log(`You selected ${state.hero.name}. The void awaits.`);
    if(state.hero.startItem) log(`Equipped starting item: ${ITEM_DB[state.hero.startItem].name}`);
}

function showMap() {
    ScreenManager.show('MAP');
}

function showHeroScreen() {
    ScreenManager.show('HERO_DETAIL');
}

function closeHeroScreen() {
    ScreenManager.show('MAP');
    saveGame();
}

function sellItem(index) {
    const item = state.inventory[index];
    const val = item.value || 0;
    
    state.gold += val;
    state.inventory.splice(index, 1);
    
    log(`Sold ${item.name} for ${val} Gold.`);
    EventManager.emit(EVENTS.HERO_UPDATED);
    EventManager.emit(EVENTS.INVENTORY_UPDATED);

    showNotification(`Sold: +${val} Gold`, 'gold');
}

function showDeckScreen() {
    ScreenManager.show('DECK_MANAGER');
}

function closeDeckScreen() {
    ScreenManager.show('MAP');
    saveGame();
}

function moveToCollection(index) {
    if (state.deck.length <= 10) {
        alert("Deck must have at least 10 cards!");
        return;
    }
    const card = state.deck.splice(index, 1)[0];
    state.collection.push(card);
    renderDeckManager();
}

function moveToDeck(index) {
    const card = state.collection.splice(index, 1)[0];
    state.deck.push(card);
    renderDeckManager();
}

function renderDeckManager() {
    const deckGrid = document.getElementById('manager-deck-grid');
    const colGrid = document.getElementById('manager-col-grid');
    
    document.getElementById('manager-deck-count').innerText = state.deck.length;
    document.getElementById('manager-col-count').innerText = state.collection.length;

    deckGrid.innerHTML = '';
    colGrid.innerHTML = '';

    // Render Active Deck
    state.deck.forEach((card, idx) => {
        let div = createCardElement(card);
        // Add click to remove
        div.onclick = () => moveToCollection(idx);
        // Add visual cue
        let hint = document.createElement('div');
        hint.innerText = "Click to Remove";
        hint.style = "position:absolute; bottom:2px; width:100%; text-align:center; font-size:8px; color:red; opacity:0.7;";
        div.appendChild(hint);
        deckGrid.appendChild(div);
    });

    // Render Collection
    state.collection.forEach((card, idx) => {
        let div = createCardElement(card);
        // Add click to add
        div.onclick = () => moveToDeck(idx);
        // Add visual cue
        let hint = document.createElement('div');
        hint.innerText = "Click to Add";
        hint.style = "position:absolute; bottom:2px; width:100%; text-align:center; font-size:8px; color:green; opacity:0.7;";
        div.appendChild(hint);
        colGrid.appendChild(div);
    });
}

function useInventoryItem(invIndex) {
    const item = state.inventory[invIndex];

    // 1. Handle LOOT (Equip)
    if (item.type === CARD_TYPES.LOOT) {
        if (state.equipped.length >= 3) {
            alert("Slots full! Unequip something first.");
            return;
        }
        // Move to equipped
        state.inventory.splice(invIndex, 1)[0];
        state.equipped.push(item);
        
        // Apply Passive Stats
        if (item.hpBonus) {
            state.hero.maxHp += item.hpBonus;
            state.hero.hp += item.hpBonus;
        }
        if (item.apBonus) state.hero.maxAp += item.apBonus;
        
        renderHeroScreen();
        return;
    }

    // 2. Handle CONSUMABLE (Use)
    if (item.type === CARD_TYPES.CONSUMABLE) {
        // Apply Immediate Effects
        if (item.heal) {
            healHero(item.heal);
        }
        // Apply Dungeon Buffs
        if (item.buffAtk) state.buffs.atk += item.buffAtk;
        if (item.buffBlock) state.buffs.block += item.buffBlock;
        if (item.buffMaxHp) state.buffs.maxHp += item.buffMaxHp; // (If you add this prop later)

        // Remove from inventory
        state.inventory.splice(invIndex, 1);
        log(`Used ${item.name}.`);
        
        // Update Event system
        EventManager.emit(EVENTS.HERO_UPDATED);
        EventManager.emit(EVENTS.INVENTORY_UPDATED);
        return;
    }

    // 3. Handle QUEST (Info)
    if (item.type === CARD_TYPES.QUEST) {
        alert(`${item.name}: ${item.desc}`);
    }
}

function mapUnequipItem(equipIndex) {
    const item = state.equipped[equipIndex];

    // Revert HP Bonus
    if (item.hpBonus) {
        state.hero.maxHp -= item.hpBonus;
        state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
    }

    if (item.apBonus) {
        state.hero.maxAp -= item.apBonus;
    }

    state.equipped.splice(equipIndex, 1);
    state.inventory.push(item);
    EventManager.emit(EVENTS.HERO_UPDATED); // Stats might change (HP/AP bonus)
    EventManager.emit(EVENTS.INVENTORY_UPDATED);
}

function renderHeroScreen() {
    if(state.hero) {
        document.getElementById('hero-screen-name').innerText = state.hero.name;
        document.getElementById('hero-screen-hp').innerText = state.hero.hp;
        document.getElementById('hero-screen-max-hp').innerText = state.hero.maxHp;
        document.getElementById('hero-screen-gold').innerText = state.gold;
    }

    // 1. Render Equipped
    const equipContainer = document.getElementById('hero-screen-equipped');
    equipContainer.innerHTML = '';
    state.equipped.forEach((item, idx) => {
        let div = createCardElement(item);
        div.classList.add('equipped');
        
        // Click card to Unequip
        div.onclick = () => mapUnequipItem(idx);
        div.style.cursor = "pointer";
        div.title = "Click to Unequip";
        
        equipContainer.appendChild(div);
    });

    // 2. Render Inventory
    const invContainer = document.getElementById('hero-screen-inventory');
    invContainer.innerHTML = '';
    state.inventory.forEach((item, idx) => {
        // Render Card
        // Render Card
        let div = createCardElement(item);
        div.style.flex = "0 0 auto"; 
        
        // Styling & Interaction based on Type
        if (item.type === CARD_TYPES.LOOT) {
            div.style.borderTop = "5px solid #f1c40f"; // Gold (Equip)
            div.title = "Click to Equip";
        } else if (item.type === CARD_TYPES.CONSUMABLE) {
            div.style.borderTop = "5px solid #2ecc71"; // Green (Use)
            div.title = "Click to Consume";
        } else if (item.type === CARD_TYPES.QUEST) {
            div.style.borderTop = "5px solid #9b59b6"; // Purple (Key Item)
            div.style.cursor = "help";
            div.title = "Key Item";
        }

        div.onclick = () => useInventoryItem(idx);
        
        invContainer.appendChild(div);
    });
    
    if (state.inventory.length === 0) invContainer.innerHTML = '<span style="font-style:italic; opacity:0.5;">Empty.</span>';
}

function isNodeAccessible(nodeId) {
    const node = MAP_GRAPH[nodeId];
    // Accessible if it has no parents OR if all parents are in completedNodes
    if (node.parents.length === 0) return true;
    return node.parents.every(parentId => state.completedNodes.includes(parentId));
}

// Map Dragging State
let mapState = {
    isDown: false,
    startX: 0,
    startY: 0,
    scrollLeft: 0,
    scrollTop: 0,
    isDragging: false // Distinguish click from drag
};

function initMapDrag() {
    const slider = document.getElementById('map-viewport');
    const content = document.getElementById('map-world');

    // Mouse Events
    slider.addEventListener('mousedown', (e) => {
        mapState.isDown = true;
        mapState.isDragging = false;
        mapState.startX = e.pageX - slider.offsetLeft;
        mapState.startY = e.pageY - slider.offsetTop;
        mapState.scrollLeft = slider.scrollLeft;
        mapState.scrollTop = slider.scrollTop;
    });

    slider.addEventListener('mouseleave', () => { mapState.isDown = false; });
    slider.addEventListener('mouseup', () => { 
        mapState.isDown = false; 
        setTimeout(() => mapState.isDragging = false, 50); 
    });

    slider.addEventListener('mousemove', (e) => {
        if (!mapState.isDown) return;
        e.preventDefault();
        mapState.isDragging = true;
        const x = e.pageX - slider.offsetLeft;
        const y = e.pageY - slider.offsetTop;
        const walkX = (x - mapState.startX);
        const walkY = (y - mapState.startY);
        slider.scrollLeft = mapState.scrollLeft - walkX;
        slider.scrollTop = mapState.scrollTop - walkY;
    });

    // Touch Events (Mobile)
    slider.addEventListener('touchstart', (e) => {
        mapState.isDown = true;
        mapState.isDragging = false;
        mapState.startX = e.touches[0].pageX - slider.offsetLeft;
        mapState.startY = e.touches[0].pageY - slider.offsetTop;
        mapState.scrollLeft = slider.scrollLeft;
        mapState.scrollTop = slider.scrollTop;
    });

    slider.addEventListener('touchend', () => { mapState.isDown = false; });

    slider.addEventListener('touchmove', (e) => {
        if (!mapState.isDown) return;
        mapState.isDragging = true;
        const x = e.touches[0].pageX - slider.offsetLeft;
        const y = e.touches[0].pageY - slider.offsetTop;
        const walkX = (x - mapState.startX);
        const walkY = (y - mapState.startY);
        slider.scrollLeft = mapState.scrollLeft - walkX;
        slider.scrollTop = mapState.scrollTop - walkY;
    });
}

function renderWorldMap() {
    const layer = document.getElementById('map-nodes-layer');
    const svgLayer = document.getElementById('map-lines');
    layer.innerHTML = '';
    svgLayer.innerHTML = '';

    // 1. Draw Lines (Parents -> Children)
    Object.values(MAP_GRAPH).forEach(node => {
        // HIDE SECRET NODE CONNECTION
        if (node.isSecret && !state.unlockedSecretNodes.includes(node.id)) return; 

        node.parents.forEach(parentId => {
            const parent = MAP_GRAPH[parentId];
            // Create SVG Line
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", parent.x);
            line.setAttribute("y1", parent.y);
            line.setAttribute("x2", node.x);
            line.setAttribute("y2", node.y);
            line.classList.add("map-connection");
            svgLayer.appendChild(line);
        });
    });

    // 2. Draw Nodes
    Object.values(MAP_GRAPH).forEach(node => {
        const isUnlocked = isNodeAccessible(node.id);
        const isCompleted = state.completedNodes.includes(node.id);
        
        // HIDE SECRET NODE VISUAL
        if (node.isSecret && !state.unlockedSecretNodes.includes(node.id)) return; 

        const el = document.createElement('div');
        el.className = `map-node-visual`;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;

        const config = NODE_CONFIGS[node.type];
        // Logic for appearance/interaction
        if (isCompleted) {
            el.classList.add('completed');
            el.innerHTML = config.icon;
        } else if (isUnlocked) {
            el.classList.add('unlocked');
            el.innerHTML = config.icon;
        } else {
            el.classList.add('locked');
            el.innerHTML = "";
        }

        // Allow entry if Unlocked OR Completed
        if (isUnlocked || isCompleted) {
             el.onclick = (e) => { 
                // Prevent drag from triggering click
                if(!mapState.isDragging) enterDungeonNode(node.id); 
            };
        }

        // Label
        const label = document.createElement('div');
        label.className = 'node-label';
        label.innerText = node.name;
        el.appendChild(label);

        layer.appendChild(el);
    });
}

function enterDungeonNode(nodeId) {
    const node = MAP_GRAPH[nodeId];
    const config = NODE_CONFIGS[node.type];
    
    // Handle Merchant Node
    if (config.isMerchant) {
        state.currentNodeId = nodeId;
        ScreenManager.show('MERCHANT');
        log(`Entered: ${node.name}`);
        return;
    }
    
    state.currentNodeId = nodeId;
    state.tier = node.tier; // Still needed for buildDungeonTier logic
    
    state.dungeonDeck = buildDungeonFromConfig(node.type);
    state.adventureRow = [];
    state.turn = 1;

    // Reset Combat Stats (AP/Block) & Apply Buffs
    state.hero.maxAp += (state.buffs.ap || 0); // Temp AP buff
    state.hero.ap = state.hero.maxAp;
    state.hero.block = 0;

    // Apply Start-of-Turn Equipment Effects (Turn 1)
    state.equipped.forEach(item => {
        if(item.block) state.hero.block += item.block;
    });
    // Apply Consumable Buffs (Start Block)
    if (state.buffs != null && state.buffs.block != null) state.hero.block += state.buffs.block;

    ScreenManager.show('GAME');

    drawCards(5);
    
    // Ensure at least one monster to start
    if (state.dungeonDeck.length > 0) {
        // Ensure first is not event
        if (state.dungeonDeck[0].type === CARD_TYPES.EVENT) {
             const safeIdx = state.dungeonDeck.findIndex(c => c.type === CARD_TYPES.MONSTER);
             if(safeIdx > -1) [state.dungeonDeck[0], state.dungeonDeck[safeIdx]] = [state.dungeonDeck[safeIdx], state.dungeonDeck[0]];
        }
        state.adventureRow.push(state.dungeonDeck.shift());
    }

    log(`Entered: ${node.name}`);
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function buyMerchantItem(itemId, price) {
    if (state.gold >= price) {
        state.gold -= price;
        
        // Create fresh copy
        const item = JSON.parse(JSON.stringify(ITEM_DB[itemId]));
        
        // Add to appropriate storage
        if (item.type === CARD_TYPES.SKILL) {
            addSkillToPlayer(item);
        } else {
            state.inventory.push(item);
            showNotification(`Bought: ${item.name}`, 'loot');
        }
        
        renderMerchantScreen();
        log(`Bought ${item.name} for ${price}g.`);
    } else {
        alert("Not enough Gold!");
    }
}

function sellMerchantItem(source, index) {
    let item;
    if (source === 'inventory') {
        item = state.inventory.splice(index, 1)[0];
    } else {
        item = state.collection.splice(index, 1)[0];
    }
    
    const val = item.value || 0;
    state.gold += val;
    
    renderMerchantScreen();
    log(`Sold ${item.name} for ${val}g.`);

    showNotification(`Sold: +${val} Gold`, 'gold');
}

function renderMerchantScreen() {
    document.getElementById('merchant-gold').innerText = state.gold;

    // 1. Render Buy Grid (Infinite Stock)
    const buyGrid = document.getElementById('merchant-buy-grid');
    buyGrid.innerHTML = '';
    
    // Get current merchant config
    const node = MAP_GRAPH[state.currentNodeId];
    const config = NODE_CONFIGS[node.type];

    config.itemPool.forEach(offer => {
        const baseItem = ITEM_DB[offer.id];
        const price = offer.price;

        let wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        
        let div = createCardElement(baseItem);
        
        // Add Price Tag
        let priceTag = document.createElement('div');
        priceTag.className = 'merchant-price';
        priceTag.innerText = `Buy: ${price}g`;
        div.appendChild(priceTag);

        div.onclick = () => buyMerchantItem(offer.id, price);
        div.style.cursor = 'pointer';

        // Overlay if too expensive
        if (state.gold < price) {
            div.style.opacity = '0.5';
        }

        wrapper.appendChild(div);
        buyGrid.appendChild(wrapper);
    });

    // 2. Render Sell Grid (Inventory + Collection)
    const sellGrid = document.getElementById('merchant-sell-grid');
    sellGrid.innerHTML = '';

    // Helper to render sellable item
    const renderSellable = (item, source, idx) => {
        let div = createCardElement(item);
        div.onclick = () => sellMerchantItem(source, idx);
        div.style.cursor = 'pointer';
        
        let valTag = document.createElement('div');
        valTag.className = 'merchant-price';
        valTag.style.color = '#e74c3c'; // Red for sell
        valTag.innerText = `Sell: ${item.value || 0}g`;
        div.appendChild(valTag);
        
        sellGrid.appendChild(div);
    };

    state.inventory.forEach((item, idx) => renderSellable(item, 'inventory', idx));
    state.collection.forEach((item, idx) => renderSellable(item, 'collection', idx));

    if(state.inventory.length === 0 && state.collection.length === 0) {
        sellGrid.innerHTML = '<span style="opacity:0.5; padding:10px;">Nothing to sell.</span>';
    }
}

function closeMerchantScreen() {
    // Mark node as complete when leaving shop
    if (state.currentNodeId && !state.completedNodes.includes(state.currentNodeId)) {
        state.completedNodes.push(state.currentNodeId);
        EventManager.emit(EVENTS.MAP_UPDATED);
    }
    
    ScreenManager.show('MAP');
    saveGame();
}

function buildDungeonFromConfig(configKey) {
    let segment = [];
    const config = NODE_CONFIGS[configKey];
    if (!config) { console.error("Missing config:", configKey); return []; }

    // 1. Determine Length
    const cardCount = Math.floor(Math.random() * (config.maxCards - config.minCards + 1)) + config.minCards;

    // Clone event pool to ensure uniqueness per run
    let availableEvents = [...config.events];

    // 2. Fill with Monsters & Events
    // Simple Logic: 70% Monster, 30% Event
    for(let i=0; i<cardCount; i++) {
        // Check if we should add event (30% chance) AND we have unique events left
        if ((Math.random() > 0.3 || availableEvents.length === 0)) {
            // Add Monster
            if (config.monsters.length > 0) {
                const mId = config.monsters[Math.floor(Math.random() * config.monsters.length)];
                segment.push({...MONSTER_DB[mId]});
            }
        } else {
            // Add Event (Unique)
            const rIdx = Math.floor(Math.random() * availableEvents.length);
            const eId = availableEvents[rIdx];
            
            // Remove from pool so it isn't picked again
            availableEvents.splice(rIdx, 1);
            
            segment.push({...EVENT_DB[eId]});
        }
    }

    shuffle(segment);

    // 3. Safety Check (No Event at start)
    if (segment.length > 0 && segment[0].type === CARD_TYPES.EVENT) {
        const safeIndex = segment.findIndex(c => c.type === CARD_TYPES.MONSTER);
        if (safeIndex !== -1) {
            [segment[0], segment[safeIndex]] = [segment[safeIndex], segment[0]];
        }
    }

    // 4. Add Boss
    if (config.bossPool && config.bossPool.length > 0) {
        const bId = config.bossPool[Math.floor(Math.random() * config.bossPool.length)];
        segment.push({...MONSTER_DB[bId]});
    }

    return segment;
}

/* --- ENGINE HELPERS --- */

let notifyTimer = null;

function showNotification(message, type) {
    const el = document.getElementById('notification-area');
    
    // Clear previous timer to ensure singleton behavior
    if (notifyTimer) clearTimeout(notifyTimer);
    
    // Set content and type
    el.innerHTML = message;
    el.className = `show notify-${type}`; // Reset classes
    
    // Auto-dismiss after 1 second
    notifyTimer = setTimeout(() => {
        el.classList.remove('show');
    }, 1000);
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function drawCards(count) {
    for(let i=0; i<count; i++) {
        if(state.deck.length === 0) {
            if(state.discard.length === 0) break;
            state.deck = [...state.discard];
            state.discard = [];
            shuffle(state.deck);
            log("Deck reshuffled.");
        }
        state.hand.push(state.deck.pop());
    }
}

function spawnMonsters() {
    // Spawn logic: If row is empty (or we want to fill), draw from deck
    if(state.adventureRow.length < 5 && state.dungeonDeck.length > 0) {
        let card = state.dungeonDeck.shift(); 
        
        if (card.type === CARD_TYPES.GROUP) {
            // Unpack the group
            log(`${card.desc || 'Ambush'}! Enemies incoming!`, '#e67e22');
            
            card.members.forEach(monsterId => {
                if (state.adventureRow.length < 5) {
                    // Clone the monster from DB
                    const monster = JSON.parse(JSON.stringify(MONSTER_DB[monsterId]));
                    state.adventureRow.push(monster);
                }
            });
        } else {
            // Standard spawn
            state.adventureRow.push(card);
        }
    }
}

/* --- ACTIONS --- */

function selectCard(index) {
    // 1. Handle Deselection
    if (state.selectedCardIndex === index) {
        state.selectedCardIndex = -1;
        render();
        return;
    }

    // 2. Select the card
    state.selectedCardIndex = index;
    const card = state.hand[index];

    // Analyze Card Intent
    const hasEnemyEffect = card.type === CARD_TYPES.SKILL && card.effects && card.effects.some(e => e.target === 'ENEMY');

    // 3. Auto-Play: Self-Target (Loot or Pure Buffs)
    if (card.type === CARD_TYPES.LOOT || (card.type === CARD_TYPES.SKILL && !hasEnemyEffect)) {
        playCard('hero');
        return;
    }

    // 4. Auto-Play: Attack (If exactly 1 Monster is present)
    if (hasEnemyEffect) {
        const monsterIndices = state.adventureRow
            .map((c, i) => c.type === CARD_TYPES.MONSTER ? i : -1)
            .filter(i => i !== -1);

        if (monsterIndices.length === 1) {
            playCard(monsterIndices[0]);
            return;
        }
    }

    // 5. Manual Target Required (Highlight card)
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function playCard(target) {
    if (state.selectedCardIndex === -1) return;

    const card = state.hand[state.selectedCardIndex];
    
    if (card.type === CARD_TYPES.CURSE) {
        log("Cannot play Curses!", "red");
        return;
    }

    if (state.hero.ap < card.cost) {
        log("Not enough AP!", "red");
        return;
    }

    let success = false;

    if (card.effects) {
        // Validate Target for Hybrid Cards (e.g. if card has ANY enemy target effect, we need a valid target)
        const requiresEnemy = card.effects.some(e => e.target === 'ENEMY');
        
        if (requiresEnemy) {
            if (target === 'hero' || state.adventureRow[target].type !== CARD_TYPES.MONSTER) {
                log("Must target an enemy!", "red");
                return;
            }
        }

        // Execute Logic
        success = processEffects(card.effects, target);
    }

    if (success) {
        // 1. Pay Costs & Remove Card (Do this FIRST)
        state.hero.ap -= card.cost;
        const playedCard = state.hand.splice(state.selectedCardIndex, 1)[0];
        
        if (playedCard.type !== CARD_TYPES.LOOT) {
            state.discard.push(playedCard);
        }
        
        state.selectedCardIndex = -1;
        
        // 2. Trigger Item Passives

        // 3. State Updated
        EventManager.emit(EVENTS.GAME_UPDATED);
        EventManager.emit(EVENTS.HERO_UPDATED); // In case block/stats changed

        // 4. Check for Auto-End Turn OR Dungeon Clear
        // We do this last so the card completely resolves before the state resets
        if (state.adventureRow.length === 0) {
            if (state.dungeonDeck.length === 0) {
                // ALL threats removed
                dungeonComplete();
            } else {
                // Just the current batch
                log("Zone cleared. Ending turn...", "#95a5a6");
                endTurn();
            }
            return;
        }

        // Check for No Playable Options (Is there any non-curse card affordable with current AP?)
        const canPlayAnything = state.hand.some(c => c.cost <= state.hero.ap);
        
        if (!canPlayAnything) {
            log("Out of moves. Ending turn...", "#95a5a6");
            endTurn();
        }
    }
}

function processEffects(effects, targetIndex) {
    let success = false;

    effects.forEach(eff => {
        // TARGET VALIDATION
        if (eff.target === 'ENEMY') {
            // Check if target is valid enemy
            if (targetIndex === 'hero' || state.adventureRow[targetIndex].type !== CARD_TYPES.MONSTER) return;
            
            if (eff.type === 'DAMAGE') {
                dealDamage(targetIndex, eff.val);
                success = true;
            }
        }
        
        if (eff.target === 'SELF') {
            if (eff.type === 'BLOCK') addBlock(eff.val);
            if (eff.type === 'HEAL') healHero(eff.val);
            if (eff.type === 'GAIN_AP') { state.hero.ap += eff.val; log(`Gained ${eff.val} AP.`); }
            if (eff.type === 'DRAW') { drawCards(eff.val); log(`Drew ${eff.val} cards.`); }
            success = true; // Self effects always succeed if played
        }
    });

    return success;
}

// --- EVENT RESOLUTION ---
function resolveEventChoice(cardIndex, choiceIndex) {
    // Verify card exists (edge case safety)
    if (!state.adventureRow[cardIndex]) return;

    const eventCard = state.adventureRow[cardIndex];
    const choice = eventCard.choices[choiceIndex];

    log(`<span class="log-event">Event: ${choice.label}</span>`);

    // --- Original Events ---
    if (choice.effect === 'pray') {
        healHero(10);
        showNotification('Healed +10 HP', 'loot');
        state.discard.push({...CURSE_CARD});
        log("You were healed, but cursed.");
        removeEvent();
    } 
    else if (choice.effect === 'fight') {
        spawnEventMonster('m_ghost');
    } 
    else if (choice.effect === 'leave') {
        log("You ignore it.");
        removeEvent();
    }
    
    // --- New Events ---
    
    // 1. Trap Door
    else if (choice.effect === 'trap_dmg') {
        state.hero.hp -= 5;
        log("You hit the ground hard. Took 5 DMG.", "red");
        showNotification("Took 5 Damage", "loss");
        removeEvent();
    }
    else if (choice.effect === 'trap_unequip') {
        if(state.equipped.length > 0) {
            const rIdx = Math.floor(Math.random() * state.equipped.length);
            const item = state.equipped[rIdx];
            
            // Revert Passive Stats
            if (item.hpBonus) {
                state.hero.maxHp -= item.hpBonus;
                state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
            }
            if (item.apBonus) {
                state.hero.maxAp -= item.apBonus;
            }

            // Move to inventory
            state.equipped.splice(rIdx, 1);
            state.inventory.push(item);
            
            log(`The fall knocked off your ${item.name}!`, "red");
            // Update UI to show item is gone
            EventManager.emit(EVENTS.GAME_UPDATED); 
            EventManager.emit(EVENTS.INVENTORY_UPDATED);
        } else {
            log("You stumbled, but had nothing equipped to lose.");
        }
        removeEvent();
    }

    // 2. Tribute
    else if (choice.effect === 'tribute_pay') {
        state.hero.maxHp -= 5;
        state.hero.hp = Math.min(state.hero.hp, state.hero.maxHp);
        // Give a strong item
        let relic = { id: 'l_blood', name: 'Blood Gem', type: CARD_TYPES.LOOT, value: 5, atkBuff: 3, desc: '+3 DMG' };
        log("You sacrificed vitality for power.");
        acquireLoot(relic);
        removeEvent();
    }

    // 3. Chests & Mimics
    else if (choice.effect === 'chest_open_t1') {
        if (Math.random() > 0.5) { // 50% mimic
            log("It's a trap! A Wooden Mimic!", "red");
            spawnEventMonster('m_mimic_t1');
        } else { // 50% not a mimic
            if (Math.random() > 0.5) { // 50% chance of loot
                const reward = rollLoot('chest_t1_rare_items');
                if (reward) {
                    log(`You opened it and found: ${reward.name}!`);
                    acquireLoot(reward);
                } else {
                    log("The chest is empty.");
                }
            } else { // 50% chance of nothing
                log("The chest is empty.");
            }
            removeEvent();
        }
    } else if (choice.effect === 'chest_open_t2') {
        if (Math.random() > 0.5) { // 50% mimic
            log("It's a trap! An Iron Mimic!", "red");
            spawnEventMonster('m_mimic_t2');
        } else { // 50% not a mimic
            if (Math.random() > 0.5) { // 50% chance of loot
                const reward = rollLoot('chest_t2_rare_items');
                if (reward) {
                    log(`You opened it and found: ${reward.name}!`);
                    acquireLoot(reward);
                } else {
                    log("The chest is empty.");
                }
            } else { // 50% chance of nothing
                log("The chest is empty.");
            }
            removeEvent();
        }
    } else if (choice.effect === 'chest_open_t3') {
        if (Math.random() > 0.5) { // 50% mimic
            log("It's a trap! A Gilded Mimic!", "red");
            spawnEventMonster('m_mimic_t3');
        } else { // 50% not a mimic
            if (Math.random() > 0.5) { // 50% chance of loot
                const reward = rollLoot('chest_t3_rare_items');
                if (reward) {
                    log(`You opened it and found: ${reward.name}!`);
                    acquireLoot(reward);
                } else {
                    log("The chest is empty.");
                }
            } else { // 50% chance of nothing
                log("The chest is empty.");
            }
            removeEvent();
        }
    }
    // 4. Weapon Master
    else if (choice.effect === 'train_str') {
        let card = JSON.parse(JSON.stringify(ITEM_DB['s_heavy']));
        log("Learned Heavy Strike.");
        acquireLoot(card);
        removeEvent();
    }
    else if (choice.effect === 'train_def') {
        let card = JSON.parse(JSON.stringify(ITEM_DB['s_iron']));
        log("Learned Iron Skin.");
        acquireLoot(card);
        removeEvent();
    }

    // 5. Spring
    else if (choice.effect === 'spring_heal') {
        healHero(5);
        showNotification('Healed +5 HP', 'loot');
        removeEvent();
    }
    else if (choice.effect === 'spring_max') {
        state.hero.maxHp += 1;
        log("You feel permanently stronger (+1 Max HP).", "green");
        removeEvent();
    }
    // --- 10 New Events ---
    // 6. Gambler
    else if (choice.effect === 'gamble_gold') {
        if(state.gold >= 10) {
            state.gold -= 10;
            if(Math.random() > 0.5) {
                state.gold += 20;
                log("You win! Gained 10 Gold.", "gold");
                showNotification("Won: +10 Gold", "gold");
            } else {
                log("You lose! The house always wins.", "red");
                showNotification("Lost: 10 Gold", "loss");
            }
        } else {
            log("Not enough gold to bet.");
        }
        removeEvent();
    }
    // 7. Fountain
    else if (choice.effect === 'fountain_full_heal') {
        state.hero.hp = state.hero.maxHp;
        state.hero.maxHp -= 1;
        showNotification('Fully Healed!', 'loot');
        log("You are fully healed, but feel weaker (-1 Max HP).", "green");
        removeEvent();
    }
    else if (choice.effect === 'fountain_sip') {
        healHero(5);
        showNotification('Healed +5 HP', 'loot');
        removeEvent();
    }
    // 8. Giant
    else if (choice.effect === 'giant_sneak') {
        if (Math.random() > 0.5) {
            log("You successfully sneak past the giant.");
            removeEvent();
        } else {
            log("The giant wakes up! It's enraged!", "red");
            spawnEventMonster('m_giant_awakened');
        }
    }
    else if (choice.effect === 'giant_attack') {
        log("You poke the sleeping giant. It awakens, groggy and confused.", "orange");
        spawnEventMonster('m_giant_groggy');
    }
    // 9. Bard
    else if (choice.effect === 'bard_pay') {
        if(state.gold >= 5) {
            state.gold -= 5;
            state.buffs.ap = (state.buffs.ap || 0) + 1;
            log("The song is inspiring! +1 AP next dungeon.", "cyan");
        } else {
            log("You can't afford the song.");
        }
        removeEvent();
    }
    else if (choice.effect === 'bard_rob') {
        log("You attack the bard! What have you done?", "red");
        state.deck.push({...CURSE_CARD});
        log("You feel the weight of your actions. Gained a Curse.", "gray");
        spawnEventMonster('m_bard_angry');
    }
    // 10. Armory
    else if (choice.effect === 'armory_sword') {
        state.buffs.atk += 2;
        log("You sharpen your blade. +2 ATK next dungeon.", "green");
        removeEvent();
    }
    else if (choice.effect === 'armory_shield') {
        state.buffs.block += 2;
        log("You reinforce your shield. +2 Block next dungeon.", "green");
        removeEvent();
    }
    // 11. Idol
    else if (choice.effect === 'idol_take') {
        let relic = { id: 'l_idol_relic', name: 'Idol of Power', type: CARD_TYPES.LOOT, value: 5, atkBuff: 2, hpBonus: -5, desc: '+2 DMG, -5 Max HP' };
        state.deck.push({...CURSE_CARD});
        log("The idol grants power, but at a cost.", "purple");
        acquireLoot(relic);
        removeEvent();
    }
    // 12. Hermit
    else if (choice.effect === 'hermit_trade_hp') {
        if (state.hero.hp > 10) {
            state.hero.hp -= 10;
            // Give a random rare skill
            const rareSkills = ['s_web', 's_drain', 's_heavy', 's_iron'];
            const randomSkillId = rareSkills[Math.floor(Math.random() * rareSkills.length)];
            const card = JSON.parse(JSON.stringify(ITEM_DB[randomSkillId]));
            log(`You trade vitality for knowledge. Lost 10 HP.`, "red");
            acquireLoot(card);
        } else {
            log("You don't have enough HP to trade.");
        }
        removeEvent();
    }
    // 13. Goblin Merchant
    else if (choice.effect === 'goblin_potion') {
        if(state.gold >= 15) {
            state.gold -= 15;
            if(Math.random() > 0.5) {
                let potion = { id: 'c_goblin_brew', name: 'Goblin Brew', type: CARD_TYPES.CONSUMABLE, rarity: 'common', value: 0, heal: 15, desc: 'Heals 15 HP. Smells weird.' };
                log("The potion seems helpful!", "green");
                acquireLoot(potion);
            } else {
                state.deck.push({...CURSE_CARD, name: 'Tummy Ache'});
                log("The potion was just swamp water. You get a curse.", "red");
            }
        } else { log("Not enough gold."); }
        removeEvent();
    }
    else if (choice.effect === 'goblin_rock') {
        if(state.gold >= 10) {
            state.gold -= 10;
            let rock = { id: 'q_shiny_rock', name: 'Shiny Rock', type: CARD_TYPES.QUEST, rarity: 'common', value: 1, desc: 'It\'s just a rock.' };
            log("You bought a shiny rock. The goblin cackles.", "gray");
            acquireLoot(rock);
        } else { log("Not enough gold."); }
        removeEvent();
    }
    // 14. Library
    else if (choice.effect === 'library_combat') {
        const combatSkills = ['s_smash', 's_wild', 's_exec'];
        const randomSkillId = combatSkills[Math.floor(Math.random() * combatSkills.length)];
        const card = JSON.parse(JSON.stringify(ITEM_DB[randomSkillId]));
        log("You learn a new combat technique.");
        acquireLoot(card);
        removeEvent();
    }
    else if (choice.effect === 'library_defense') {
        const defenseSkills = ['s_wall', 's_step', 's_iron'];
        const randomSkillId = defenseSkills[Math.floor(Math.random() * defenseSkills.length)];
        const card = JSON.parse(JSON.stringify(ITEM_DB[randomSkillId]));
        log("You learn a new defensive maneuver.");
        acquireLoot(card);
        removeEvent();
    }
    // 15. Void Rift
    else if (choice.effect === 'rift_touch') {
        const outcome = Math.floor(Math.random() * 5);
        if (outcome === 0) {
            state.hero.hp -= 10;
            log("A tendril lashes out! -10 HP.", "red");
            showNotification("Took 10 Damage", "loss");
        } else if (outcome === 1) {
            healHero(10);
            showNotification('Healed +10 HP', 'loot');
            log("A warm light heals you. +10 HP.", "green");
        } else if (outcome === 2) {
            state.gold += 25;
            log("Gold spills from the rift! +25g.", "gold");
        } else if (outcome === 3) {
            const loot = rollLoot('tier3_void');
            if (loot) {
                const colors = { common: '#bdc3c7', rare: '#3498db', legendary: '#f1c40f' };
                log(`Pulled from the void: <span style="color:${colors[loot.rarity] || '#fff'}">${loot.name}</span>`);
                acquireLoot(loot);
            } else {
                log("You reach inside but find nothing.");
            }
        } else {
            state.deck.push({...CURSE_CARD, name: 'Void Taint'});
            log("A dark energy clings to you. Gained a curse.", "purple");
        }
        removeEvent();
    }
    // --- SECRET CHAIN LOGIC ---
    else if (choice.effect === 'chain_step_1') {
        if (state.gold >= 5) {
            state.gold -= 5;
            log("The beggar hands you a vibrating coin.", "gold");
            acquireLoot(JSON.parse(JSON.stringify(ITEM_DB['q_chain_1'])));
        } else {
            log("Not enough gold.");
        }
        removeEvent();
    }
    else if (choice.effect === 'chain_step_2') {
        // Remove Step 1 Item
        const idx = state.inventory.findIndex(i => i.id === 'q_chain_1');
        if (idx > -1) state.inventory.splice(idx, 1);
        
        // Give Step 2 Item
        log(" The statue's eye pops out. You take it.", "purple");
        acquireLoot(JSON.parse(JSON.stringify(ITEM_DB['q_chain_2'])));
        removeEvent();
    }
    else if (choice.effect === 'chain_step_3') {
        // Remove Step 2 Item
        const idx = state.inventory.findIndex(i => i.id === 'q_chain_2');
        if (idx > -1) state.inventory.splice(idx, 1);
        
        // Give Step 3 Item
        log("The tomb slides open. You find a handle.", "purple");
        acquireLoot(JSON.parse(JSON.stringify(ITEM_DB['q_chain_3'])));
        removeEvent();
    }
    else if (choice.effect === 'chain_step_4') {
        // Remove Step 3 Item
        const idx = state.inventory.findIndex(i => i.id === 'q_chain_3');
        if (idx > -1) state.inventory.splice(idx, 1);
        
        // Give Step 4 Item
        log("You forge the pieces together. It forms a Void Key.", "gold");
        acquireLoot(JSON.parse(JSON.stringify(ITEM_DB['q_chain_4'])));
        removeEvent();
    }
    else if (choice.effect === 'unlock_node') {
        // Remove Key
        const idx = state.inventory.findIndex(i => i.id === 'q_chain_4');
        if (idx > -1) state.inventory.splice(idx, 1);
        
        // Unlock Node
        const targetNodeId = eventCard.targetNode;
        if (targetNodeId && !state.unlockedSecretNodes.includes(targetNodeId)) {
            state.unlockedSecretNodes.push(targetNodeId);
            log("The reality wall shatters! A new path is revealed.", "#e74c3c");
            EventManager.emit(EVENTS.MAP_UPDATED);
        }
        
        EventManager.emit(EVENTS.INVENTORY_UPDATED);
        removeEvent();
    }

    render();

    // Check for Auto-End Turn OR Dungeon Clear
    if (state.adventureRow.length === 0) {
        if (state.dungeonDeck.length === 0) {
            // ALL threats removed (including deck)
            dungeonComplete();
        } else {
            log("Zone cleared. Ending turn...", "#95a5a6");
            endTurn();
        }
    }

    // Helper to clear the event from the row
    function removeEvent() {
        state.adventureRow.splice(cardIndex, 1);
    }

    // Helper to swap event with monster
    function spawnEventMonster(id) {
        const monster = JSON.parse(JSON.stringify(MONSTER_DB[id] || EVENT_MONSTERS[id]));
        state.adventureRow[cardIndex] = monster;
        EventManager.emit(EVENTS.GAME_UPDATED);
    }
}

function equipItem(card) {
    state.equipped.push(card);
    log(`Equipped ${card.name}.`);
    if(card.hpBonus) {
        state.hero.maxHp += card.hpBonus;
        state.hero.hp += card.hpBonus;
        log(`Max HP increased by ${card.hpBonus}.`);
    }
}

function dealDamage(monsterIndex, amount) {
    let monster = state.adventureRow[monsterIndex];
    let bonus = 0;
    state.equipped.forEach(item => { if(item.atkBuff) bonus += item.atkBuff; });
    
    // Add Consumable Buffs
    if(state.buffs != null && state.buffs.atk != null){
        bonus += (state.buffs.atk || 0);
    }

    let totalDmg = amount + bonus;
    monster.hp -= totalDmg;
    
    log(`Hit ${monster.name} for <span class="log-dmg">${totalDmg}</span> dmg.`);

    if (monster.hp <= 0) {
        killMonster(monsterIndex);
    }
}

function killMonster(index) {
    let m = state.adventureRow[index];
    log(`${m.name} defeated!`);

    // 0. Gold Drop Logic
    if (m.goldReward) {
        state.gold += m.goldReward;
        log(`Gained ${m.goldReward} Gold.`, "#f1c40f");
        showNotification(`Gained: +${m.goldReward} Gold`, 'gold');
        EventManager.emit(EVENTS.HERO_UPDATED);
    }

    if (m.lootTable) {
        const lootCard = rollLoot(m.lootTable);
        if (lootCard) {
            acquireLoot(lootCard);
        } else {
            log("No loot found.");
        }
    } else {
        log("No loot found.");
    }
    
    state.adventureRow.splice(index, 1);
}

function acquireLoot(lootCard) {
    if (!lootCard) {
        return; // Silently fail if no loot
    }

    if (lootCard.type === CARD_TYPES.SKILL) {
        addSkillToPlayer(lootCard); // This already handles logging and notifications
    } else {
        state.inventory.push(lootCard);
        
        let notificationType = 'loot';
        if (lootCard.type === CARD_TYPES.QUEST || lootCard.type === CARD_TYPES.CONSUMABLE) {
            notificationType = 'item';
        }
        showNotification(`Looted: ${lootCard.name}`, notificationType);

        const colors = { common: '#bdc3c7', rare: '#3498db', legendary: '#f1c40f' };
        log(`Looted: <span style="color:${colors[lootCard.rarity] || '#fff'}">${lootCard.name}</span>`);

        EventManager.emit(EVENTS.INVENTORY_UPDATED);
    }
}

function dungeonComplete() {
    // Standard Node Completion
    log("Dungeon Cleared!", "gold");
    
    // Mark Node as Complete
        if (state.currentNodeId && !state.completedNodes.includes(state.currentNodeId)) {
            state.completedNodes.push(state.currentNodeId);
            EventManager.emit(EVENTS.MAP_UPDATED);
        }

    // Delay slightly then go to map
    setTimeout(() => {
        log("Returning to Map...");
        continueGame(); // Reuses the logic to consolidate deck and show map
    }, 1500);
}

function continueGame() {
    document.getElementById('overlay').style.display = 'none';
    
    // Consolidate Deck (Hand/Discard -> Deck)
    while(state.hand.length > 0) state.deck.push(state.hand.pop());
    while(state.discard.length > 0) state.deck.push(state.discard.pop());
    
    state.adventureRow = [];

    // Revert temporary buffs before resetting them
    state.hero.maxAp -= (state.buffs.ap || 0);

    // Reset Temporary Buffs
    state.buffs = { atk: 0, block: 0, maxHp: 0, ap: 0 };
    
    ScreenManager.show('MAP');
}

function addBlock(amount) {
    state.hero.block += amount;
    log(`Gained ${amount} Block.`);
    EventManager.emit(EVENTS.HERO_UPDATED);
}

function healHero(amount) {
    state.hero.hp = Math.min(state.hero.maxHp, state.hero.hp + amount);
    log(`Healed for <span class="log-gain">${amount}</span> HP.`);
    EventManager.emit(EVENTS.HERO_UPDATED);
}

function endTurn() {
    log("--- Enemy Turn ---");
    
    let totalDamageTaken = 0;
    state.adventureRow.forEach(m => {
        if(m.type === CARD_TYPES.EVENT) return;

        let dmg = m.atk;
        
        if (state.hero.block > 0) {
            if (state.hero.block >= dmg) {
                state.hero.block -= dmg;
                dmg = 0;
                log(`${m.name} attack blocked.`);
            } else {
                dmg -= state.hero.block;
                state.hero.block = 0;
                log(`${m.name} broke your shield!`);
            }
        }

        if (dmg > 0) {
            state.hero.hp -= dmg;
            totalDamageTaken += dmg;
            log(`${m.name} deals <span class="log-dmg">${dmg}</span> damage!`);
        }
    });

    if (totalDamageTaken > 0) {
        showNotification(`Took ${totalDamageTaken} damage`, 'loss');
    }

    if (state.hero.hp <= 0) {
        gameOver();
        return;
    }

    state.hero.ap = Math.max(state.hero.ap, state.hero.maxAp);
    state.hero.block = 0; 

    // Apply Start-of-Turn Equipment Effects
    state.equipped.forEach(item => {
        if(item.block) {
            // Direct modification to avoid excessive logging/events during transition
            state.hero.block += item.block; 
        }
    });
    if(state.hero.block > 0) log(`Equipment: Gained ${state.hero.block} Block.`);
    
    // Keep unplayed cards in hand (Persistence)
    // Draw up to hand limit (5)
    const cardsNeeded = Math.max(0, 5 - state.hand.length);
    if (cardsNeeded > 0) {
        drawCards(cardsNeeded);
    }

    // If the row is completely empty (no monsters/events), the dungeon sends a new threat
    if (state.adventureRow.length === 0) {
        spawnMonsters();
    }

    state.turn++;
    state.selectedCardIndex = -1;
    EventManager.emit(EVENTS.GAME_UPDATED);
}

function checkWinCondition() {}

function gameOver() {
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('overlay-title').innerText = "YOU DIED";
    document.getElementById('overlay-title').style.color = "red";
}

function log(msg, color) {
    const el = document.getElementById('log-console');
    let style = color ? `style="color:${color}"` : '';
    // Append to end, CSS flex-direction: column-reverse handles order
    el.innerHTML += `<div class="log-entry" ${style}>${msg}</div>`; 
    // Keep only last 4 messages to save space
    if (el.children.length > 4) {
        el.removeChild(el.children[0]);
    }
}

/* --- RENDERING --- */

function render() {
    // Hero Name
    document.getElementById('hero-name').innerText = state.hero.name;

    document.getElementById('hero-hp').innerText = state.hero.hp;
    document.getElementById('hero-max-hp').innerText = state.hero.maxHp;
    document.getElementById('hero-ap').innerText = state.hero.ap;
    document.getElementById('hero-max-ap').innerText = state.hero.maxAp;
    document.getElementById('hero-block').innerText = state.hero.block;
    
    document.getElementById('deck-count').innerText = state.deck.length;

    const advContainer = document.getElementById('adventure-row');
    
    // Check logic for button state
    const eventIndex = state.adventureRow.findIndex(c => c.type === CARD_TYPES.EVENT);
    const hasEvent = eventIndex !== -1;
    const isFull = state.adventureRow.length >= 5;

    // --- EVENT OVERLAY LOGIC ---
    const evtOverlay = document.getElementById('event-overlay');
    const evtContainer = document.getElementById('event-card-container');
    
    if (hasEvent) {
        // Show Overlay
        evtOverlay.style.display = 'flex';
        evtContainer.innerHTML = '';
        
        // Render the Event Card into the overlay
        // We pass the index so the buttons work correctly
        const eventCard = createCardElement(state.adventureRow[eventIndex], eventIndex);
        
        // Prevent clicking the card body itself (optional aesthetic tweak)
        eventCard.style.pointerEvents = "auto"; 
        
        evtContainer.appendChild(eventCard);
    } else {
        // Hide Overlay
        evtOverlay.style.display = 'none';
    }
    const disabledAttr = (hasEvent || isFull || state.dungeonDeck.length === 0) ? 'disabled' : '';
    const btnColor = hasEvent ? '#e67e22' : '#7f8c8d'; // Visual cue

    advContainer.innerHTML = `
        <div class="area-label">
            Adventure Row
        </div>`;
    
    state.adventureRow.forEach((m, idx) => {
        let cardDiv = createCardElement(m, idx); 
        if(m.type === CARD_TYPES.MONSTER) {
            cardDiv.onclick = () => playCard(idx);
        }
        advContainer.appendChild(cardDiv);
    });

    // Hero
    const heroContainer = document.getElementById('hero-card-container');
    heroContainer.innerHTML = '';
    let heroCard = createCardElement(state.hero);
    heroCard.onclick = () => playCard('hero'); 
    heroContainer.appendChild(heroCard);

    const equipContainer = document.getElementById('equipment-slots');
    equipContainer.innerHTML = '';
    state.equipped.forEach((item) => {
        let div = createCardElement(item);
        div.classList.add('equipped');
        // No buttons here anymore
        equipContainer.appendChild(div);
    });

    // Hand
    const handContainer = document.getElementById('hand-row');
    handContainer.innerHTML = '<div class="area-label">Your Hand</div>';
    state.hand.forEach((card, idx) => {
        let div = createCardElement(card);
        div.onclick = (e) => {
            e.stopPropagation();
            selectCard(idx);
        };
        if (idx === state.selectedCardIndex) div.classList.add('selected');
        handContainer.appendChild(div);
    });
}

function createCardElement(data, index) {
    const div = document.createElement('div');
    div.classList.add('card');
    div.classList.add(`type-${data.type}`);
    
    let bodyHtml = '';
    let statsHtml = '';

    if (data.type === CARD_TYPES.MONSTER) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>${data.atk}</span><span>${data.hp}</span></div>`;
    } else if (data.type === CARD_TYPES.HERO) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        statsHtml = `<div class="card-stats"><span>${data.ap}</span><span>${data.hp}</span></div>`;
    } else if (data.type === CARD_TYPES.SKILL || data.type === CARD_TYPES.CURSE) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        
        // Generate mini-icons based on effects
        let icons = `<span>${data.cost}</span>`;
        if (data.effects) {
             data.effects.forEach(e => {
                 if(e.type === 'DAMAGE') icons += ` <span>${e.val}</span>`;
                 if(e.type === 'BLOCK') icons += ` <span>${e.val}</span>`;
                 if(e.type === 'HEAL') icons += ` <span>${e.val}</span>`;
             });
        }
        statsHtml = `<div class="card-stats">${icons}</div>`;
    } else if (data.type === CARD_TYPES.LOOT) {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
        // Display Gold Value
        let valDisplay = data.value ? `<span style="color:#f1c40f;">${data.value}</span>` : '';
        statsHtml = `<div class="card-stats">${valDisplay}</div>`;
    } else if (data.type === CARD_TYPES.EVENT) {
        let buttons = '';
        if(data.choices) {
            data.choices.forEach((choice, choiceIdx) => {
                // Check Quest Item Requirement
                let disabled = '';
                let label = choice.label;
                
                if (choice.reqItem) {
                    const hasItem = state.inventory.some(i => i.id === choice.reqItem);
                    if (!hasItem) {
                        disabled = 'disabled';
                        label = ` ${choice.label} (Missing Item)`;
                    }
                } else if (choice.reqGold && state.gold < choice.reqGold) {
                    disabled = 'disabled';
                    label = ` ${choice.label} (Not enough Gold)`;
                }

                buttons += `<button class="choice-btn" ${disabled} onclick="event.stopPropagation(); resolveEventChoice(${index}, ${choiceIdx})">${label}</button>`;
            });
        }
        bodyHtml = `<div class="card-desc">${data.desc}${buttons}</div>`;
    } else {
        bodyHtml = `<div class="card-desc">${data.desc}</div>`;
    }

    div.innerHTML = `
        <div class="card-header">${data.name}</div>
        ${bodyHtml}
        ${statsHtml}
    `;
    return div;
}

function saveGame() {
    // Save the entire state object
    localStorage.setItem('vanguardSave', JSON.stringify(state));
}

function loadGame() {
    const save = localStorage.getItem('vanguardSave');
    if (save) {
        try {
                        state = JSON.parse(save);

            // Backwards compatibility for saves without settings
            if (!state.settings) {
                state.settings = { autoAddToDeck: true };
            }
            
            // Backwards compatibility for secret nodes
            if (state.secretNodeUnlocked === true) {
                state.unlockedSecretNodes = ['n_secret'];
            } else if (!state.unlockedSecretNodes) {
                state.unlockedSecretNodes = [];
            }
            delete state.secretNodeUnlocked;
            
            // If loaded, skip selection and go to Map
            // We reset the "run" state (hand/row) to ensure a clean load on the map
            state.hand = [];
            state.discard = [];
            state.adventureRow = []; 
            // Ensure deck is consolidated if we crashed mid-run
            if (state.deck.length < 10) { 
                // If deck is empty (cards in hand/discard), we might need to rebuild logic or just reset deck
                // For safety in this prototype, we assume saving happens mostly on Map
            }
            
            ScreenManager.show('MAP');
            log("Game Loaded.");
            return true;
        } catch (e) {
            console.error("Save file corrupted", e);
            return false;
        }
    }
    return false;
}

function showSettingsScreen() {
    document.getElementById('settings-overlay').style.display = 'flex';
    // Sync toggle with current state
    if (!state.settings) state.settings = { autoAddToDeck: true };
    document.getElementById('auto-add-toggle').checked = state.settings.autoAddToDeck;
}

function closeSettingsScreen() {
    document.getElementById('settings-overlay').style.display = 'none';
    saveGame(); // Save settings when closing
}

function toggleAutoAddSetting(isChecked) {
    if (!state.settings) state.settings = {}; // Safety init
    state.settings.autoAddToDeck = isChecked;
    log(`Auto-add skills to deck is now ${isChecked ? 'ON' : 'OFF'}.`);
}

function addSkillToPlayer(skillCard) {
    // Default to true if setting is missing for some reason
    const shouldAddToDeck = (state.settings && state.settings.autoAddToDeck !== undefined) ? state.settings.autoAddToDeck : true;
    
    if (shouldAddToDeck) {
        state.deck.push(skillCard);
        log(`Added <span style="color:var(--skill-color)">${skillCard.name}</span> to Deck.`);
    } else {
        state.collection.push(skillCard);
        log(`Added <span style="color:var(--skill-color)">${skillCard.name}</span> to Collection.`);
    }
    
    showNotification(`Learned: ${skillCard.name}`, 'skill');
}

function resetProgress() {
    if(confirm("Are you sure? This will wipe all progress.")) {
        localStorage.removeItem('vanguardSave');
        location.reload();
    }
}

// Init Event System
initUIListeners();

// Start Game
if (!loadGame()) {
    initSelectionScreen();
}

</script>
</body>
</html>