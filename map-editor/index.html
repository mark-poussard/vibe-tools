<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Editor</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; height: 100vh; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; background: #0f172a; color: #f8fafc; }
    #toolbar { background: #1e293b; border-bottom: 1px solid #334155; padding: 8px; display: flex; gap: 12px; align-items: center; z-index: 10; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.3); overflow-x: auto; scrollbar-width: none; -ms-overflow-style: none; }
    #toolbar::-webkit-scrollbar { display: none; }
    .tool-section { display: flex; align-items: center; gap: 8px; border-right: 1px solid #475569; padding-right: 12px; flex-shrink: 0; }
    .palette { display: flex; gap: 4px; align-items: center; flex-shrink: 0; }
    .label { font-size: 10px; font-weight: 800; text-transform: uppercase; color: #94a3b8; letter-spacing: 0.05em; }
    button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px; white-space: nowrap; touch-action: manipulation; min-height: 38px; }
    button:hover { background: #475569; }
    button.active { background: #2563eb; border-color: #3b82f6; color: white; }
    #viewport { flex-grow: 1; position: relative; overflow: hidden; }
    canvas { display: block; touch-action: none; }
    .swatch { width: 12px; height: 12px; border: 1px solid rgba(0,0,0,0.3); border-radius: 2px; }
    #status { position: fixed; bottom: 16px; right: 16px; background: rgba(15, 23, 42, 0.9); padding: 4px 12px; border-radius: 100px; font-size: 12px; color: #94a3b8; border: 1px solid #334155; pointer-events: none; }
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 100; }
    .modal.active { display: flex; }
    .modal-content { background: #1e293b; padding: 24px; border-radius: 8px; width: 90%; max-width: 400px; border: 1px solid #475569; }
    .modal-content h2 { margin-top: 0; font-size: 18px; color: #f8fafc; }
    .form-group { margin-bottom: 12px; }
    .form-group label { display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px; text-transform: uppercase; font-weight: 700; }
    .form-group input { width: 100%; background: #0f172a; border: 1px solid #475569; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; outline: none; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
    select { background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; padding: 6px; outline: none; font-size: 13px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-section">
      <span class="label">Mode</span>
      <button id="tool-pan">Pan</button>
      <button id="tool-pen">Tiles</button>
      <button id="tool-zone">Zones</button>
      <button id="tool-warp">Warps</button>
      <button id="tool-toggle-zones">View Zones</button>
      <button id="tool-toggle-warps">View Warps</button>
      <button id="btn-settings">Settings</button><button id="btn-manage-encounters">Encounters</button>
    </div>
    <div class="tool-section" id="map-select-section" style="display:none">
      <span class="label">Map</span>
      <select id="map-select"></select>
    </div>
    <div class="tool-section">
      <span class="label">Zone ID</span>
      <input type="number" id="zone-id" value="1" min="0" max="99" style="width: 45px; background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; padding: 4px; outline: none;">
    </div>
    <div class="palette" id="palette">
      <span class="label">Tiles</span>
    </div>
  </div>
  <div id="viewport">
    <canvas id="editorCanvas"></canvas>
  </div>
  <div id="status">X: 0, Y: 0</div>
  <div id="warp-modal" class="modal">
    <div class="modal-content">
      <h2 id="warp-modal-title">Edit Warp</h2>
      <div class="form-group">
        <label>Destination Map</label>
        <select id="warp-dest-map"></select>
      </div>
      <div class="form-group">
        <label>Destination X</label>
        <input type="number" id="warp-dest-x">
      </div>
      <div class="form-group">
        <label>Destination Y</label>
        <input type="number" id="warp-dest-y">
      </div>
      <div class="modal-actions">
        <button id="btn-warp-delete" style="background: #ef4444; border-color: #ef4444;">Delete</button>
        <button id="btn-warp-save" style="background: #2563eb; border-color: #2563eb;">Save</button>
        <button id="btn-warp-close">Close</button>
      </div>
    </div>
  </div>
  <div id="zones-modal" class="modal"><div class="modal-content" style="max-width: 500px; max-height: 85vh; overflow-y: auto;"><h2>Encounter Zones</h2><div class="form-group"><label>Zone ID</label><input type="number" id="edit-zone-id" value="1" min="1"></div><div id="encounters-list"></div><div class="modal-actions"><button id="btn-add-encounter" style="background: #10b981; border-color: #10b981;">Add Encounter</button><button id="btn-zones-close">Close</button></div></div></div><div id="settings-modal" class="modal">
    <div class="modal-content">
      <h2>GitHub Settings</h2>
      <div class="form-group">
        <label>Personal Access Token (Optional)</label>
        <input type="password" id="gh-token">
      </div>
      <div class="form-group">
        <label>Owner</label>
        <input type="text" id="gh-owner" placeholder="username">
      </div>
      <div class="form-group">
        <label>Repo</label>
        <input type="text" id="gh-repo" placeholder="repository-name">
      </div>
      <div class="form-group">
        <label>Path</label>
        <input type="text" id="gh-path" placeholder="path/to/index.html">
      </div>
      <div class="modal-actions">
        <button id="btn-gh-import" style="background: #059669; border-color: #059669;">Import Maps</button>
        <button id="btn-gh-export" style="background: #2563eb; border-color: #2563eb;">Export Maps</button>
        <button id="btn-settings-close">Close</button>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const palette = document.getElementById('palette');
    const status = document.getElementById('status');
    const TILE_SIZE = 32;
    const DEFAULT_SIZE = 60;
    const TILES = {
      'T': { type: 'tree', color: '#064e3b' },
      ' ': { type: 'grass', color: '#2ecc71' },
      'D': { type: 'dirt', color: '#d35400' },
      'f': { type: 'forest', color: '#1b5e20' },
      'm': { type: 'mountain', color: '#7f8c8d' },
      's': { type: 'sand', color: '#f1c40f' },
      'W': { type: 'water', color: '#3498db' },
      'b': { type: 'boulder', color: '#475569' }
    };
    let allMaps = { 'default': { layout: Array.from({ length: DEFAULT_SIZE }, () => ' '.repeat(DEFAULT_SIZE)), encounters: Array.from({ length: DEFAULT_SIZE }, () => Array(DEFAULT_SIZE).fill(0)), warps: [] } };
    let currentMapName = 'default';
    let mapData = allMaps['default'].layout;
    let zoneData = allMaps['default'].encounters;
    let warpData = allMaps['default'].warps || [];
    let cam = { x: 50, y: 50 };
    let mode = 'pen';
    let brush = ' ';
    let activeZone = 1;
    let isDown = false;
    let lastPos = { x: 0, y: 0 };
    let showZones = false;
    let showWarps = false;
    let editingWarp = null; let encounterZones = {};

function saveToStorage() {
      allMaps[currentMapName] = { layout: mapData, encounters: zoneData, warps: warpData };
      localStorage.setItem('map_editor_save', JSON.stringify({ allMaps, currentMapName, encounterZones }));
    }

    function loadFromStorage() {
      const saved = localStorage.getItem('map_editor_save');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (data.allMaps) {
            allMaps = data.allMaps;
            currentMapName = data.currentMapName || Object.keys(allMaps)[0];
            mapData = allMaps[currentMapName].layout;
            zoneData = allMaps[currentMapName].encounters;
            warpData = allMaps[currentMapName].warps || [];
            encounterZones = data.encounterZones || {};
            updateMapSelector();
          }
        } catch (e) { console.error("Failed to load map", e); }
      }
      document.getElementById('gh-token').value = localStorage.getItem('gh_token') || '';
      document.getElementById('gh-owner').value = localStorage.getItem('gh_owner') || '';
      document.getElementById('gh-repo').value = localStorage.getItem('gh_repo') || '';
      document.getElementById('gh-path').value = localStorage.getItem('gh_path') || '';
    }

    function init() {
      loadFromStorage();
      Object.entries(TILES).forEach(([char, cfg]) => {
        const b = document.createElement('button');
        b.innerHTML = `<div class="swatch" style="background:${cfg.color}"></div>${cfg.type}`;
        b.onclick = (e) => { e.preventDefault(); brush = char; setMode('pen'); };
        b.dataset.char = char;
        palette.appendChild(b);
      });
      document.getElementById('tool-pan').onclick = () => setMode('pan');
      document.getElementById('tool-pen').onclick = () => setMode('pen');
      document.getElementById('tool-zone').onclick = () => setMode('zone');
      document.getElementById('tool-warp').onclick = () => setMode('warp');
      document.getElementById('tool-toggle-zones').onclick = () => {
        showZones = !showZones;
        document.getElementById('tool-toggle-zones').classList.toggle('active', showZones);
      };
      document.getElementById('tool-toggle-warps').onclick = () => {
        showWarps = !showWarps;
        document.getElementById('tool-toggle-warps').classList.toggle('active', showWarps);
      };
      document.getElementById('btn-settings').onclick = () => document.getElementById('settings-modal').classList.add('active');
      document.getElementById('btn-settings-close').onclick = () => document.getElementById('settings-modal').classList.remove('active');
      document.getElementById('btn-manage-encounters').onclick = () => { document.getElementById('zones-modal').classList.add('active'); refreshEncountersUI(); };
      document.getElementById('btn-zones-close').onclick = () => document.getElementById('zones-modal').classList.remove('active');
      document.getElementById('btn-add-encounter').onclick = () => window.addEncounter(document.getElementById('edit-zone-id').value);
      document.getElementById('edit-zone-id').onchange = refreshEncountersUI;
      document.getElementById('btn-gh-import').onclick = importFromGitHub;
      document.getElementById('btn-gh-export').onclick = exportToGitHub;
      document.getElementById('btn-warp-save').onclick = saveWarp;
      document.getElementById('btn-warp-delete').onclick = deleteWarp;
      document.getElementById('btn-warp-close').onclick = () => document.getElementById('warp-modal').classList.remove('active');
      document.getElementById('map-select').onchange = (e) => switchMap(e.target.value);
      document.getElementById('zone-id').onchange = (e) => activeZone = parseInt(e.target.value) || 0;
      window.addEventListener('resize', resize);
      const handleStart = (e) => {
        isDown = true;
        const p = e.touches ? e.touches[0] : e;
        lastPos = { x: p.clientX, y: p.clientY };
        if (mode !== 'pan') paint(p.clientX, p.clientY);
      };
      const handleMove = (e) => {
        const p = e.touches ? e.touches[0] : e;
        const rect = canvas.getBoundingClientRect();
        const mx = Math.floor((p.clientX - rect.left - cam.x) / TILE_SIZE);
        const my = Math.floor((p.clientY - rect.top - cam.y) / TILE_SIZE);
        const curW = mapData[0]?.length || 0;
        const curH = mapData.length;
        if (mx >= 0 && mx < curW && my >= 0 && my < curH) status.innerText = `X: ${mx}, Y: ${my}`;
        if (!isDown) return;
        if (mode === 'pan') {
          cam.x += p.clientX - lastPos.x;
          cam.y += p.clientY - lastPos.y;
        } else paint(p.clientX, p.clientY);
        lastPos = { x: p.clientX, y: p.clientY };
      };
      const handleEnd = () => isDown = false;
      canvas.addEventListener('mousedown', handleStart);
      canvas.addEventListener('touchstart', handleStart, { passive: false });
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('touchmove', handleMove, { passive: false });
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchend', handleEnd);
      window.addEventListener('touchcancel', handleEnd);
      resize();
      setMode('pen');
      render();
    }

    function updateMapSelector() {
      const select = document.getElementById('map-select');
      const container = document.getElementById('map-select-section');
      const keys = Object.keys(allMaps);
      if (keys.length <= 1) {
        container.style.display = 'none';
      } else {
        container.style.display = 'flex';
        select.innerHTML = '';
        keys.forEach(k => {
          const opt = document.createElement('option');
          opt.value = k; opt.textContent = k; opt.selected = (k === currentMapName);
          select.appendChild(opt);
        });
      }
    }

    function switchMap(name) {
      allMaps[currentMapName] = { layout: mapData, encounters: zoneData, warps: warpData };
      currentMapName = name;
      mapData = allMaps[name].layout;
      zoneData = allMaps[name].encounters;
      warpData = allMaps[name].warps || [];
    }

    function openWarpModal(tx, ty) {
      editingWarp = warpData.find(w => w.x === tx && w.y === ty);
      document.getElementById('warp-modal-title').textContent = editingWarp ? 'Edit Warp' : 'New Warp';
      const destSelect = document.getElementById('warp-dest-map');
      destSelect.innerHTML = '';
      Object.keys(allMaps).forEach(m => {
        const opt = document.createElement('option');
        opt.value = m; opt.textContent = m;
        destSelect.appendChild(opt);
      });
      if (editingWarp) {
        destSelect.value = editingWarp.destMap;
        document.getElementById('warp-dest-x').value = editingWarp.destX;
        document.getElementById('warp-dest-y').value = editingWarp.destY;
        document.getElementById('btn-warp-delete').style.display = 'block';
      } else {
        destSelect.value = currentMapName;
        document.getElementById('warp-dest-x').value = tx;
        document.getElementById('warp-dest-y').value = ty;
        document.getElementById('btn-warp-delete').style.display = 'none';
        editingWarp = { x: tx, y: ty };
      }
      document.getElementById('warp-modal').classList.add('active');
    }

    function saveWarp() {
      const w = { x: editingWarp.x, y: editingWarp.y, destMap: document.getElementById('warp-dest-map').value, destX: parseInt(document.getElementById('warp-dest-x').value) || 0, destY: parseInt(document.getElementById('warp-dest-y').value) || 0 };
      const idx = warpData.findIndex(ex => ex.x === w.x && ex.y === w.y);
      if (idx !== -1) warpData[idx] = w; else warpData.push(w);
      saveToStorage();
      document.getElementById('warp-modal').classList.remove('active');
    }

    function deleteWarp() {
      warpData = warpData.filter(w => !(w.x === editingWarp.x && w.y === editingWarp.y));
      saveToStorage();
      document.getElementById('warp-modal').classList.remove('active');
    }

    async function importFromGitHub() {
      const tokenInput = document.getElementById('gh-token').value.trim();
      const owner = document.getElementById('gh-owner').value.trim();
      const repo = document.getElementById('gh-repo').value.trim();
      const path = document.getElementById('gh-path').value.trim();
      if (tokenInput) localStorage.setItem('gh_token', tokenInput);
      localStorage.setItem('gh_owner', owner);
      localStorage.setItem('gh_repo', repo);
      localStorage.setItem('gh_path', path);
      const token = tokenInput || localStorage.getItem('gh_token') || '';
      if (!owner || !repo || !path) return alert('Fill owner, repo and path');
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const headers = token ? { 'Authorization': `token ${token}` } : {};
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        const content = atob(data.content);
        const match = content.match(/(?:const|let|var)\s+MAP_DATA\s*=\s*({[\s\S]*?});/);
        if (!match) throw new Error("MAP_DATA not found in file");
        const parsed = new Function(`return ${match[1]}`)();
        const matchZones = content.match(/(?:const|let|var)\s+ENCOUNTER_ZONES\s*=\s*({[\s\S]*?});/);
        if (matchZones) encounterZones = new Function(`return ${matchZones[1]}`)();
        allMaps = parsed;
        currentMapName = Object.keys(allMaps)[0];
        mapData = allMaps[currentMapName].layout;
        zoneData = allMaps[currentMapName].encounters;
        warpData = allMaps[currentMapName].warps || [];
        updateMapSelector();
        saveToStorage();
        document.getElementById('settings-modal').classList.remove('active');
        alert("Imported " + Object.keys(allMaps).length + " maps");
      } catch (e) { alert("Error: " + e.message); }
    }

    async function exportToGitHub() {
      saveToStorage();
      const tokenInput = document.getElementById('gh-token').value.trim();
      const owner = document.getElementById('gh-owner').value.trim();
      const repo = document.getElementById('gh-repo').value.trim();
      const path = document.getElementById('gh-path').value.trim();
      if (tokenInput) localStorage.setItem('gh_token', tokenInput);
      localStorage.setItem('gh_owner', owner);
      localStorage.setItem('gh_repo', repo);
      localStorage.setItem('gh_path', path);
      const token = tokenInput || localStorage.getItem('gh_token') || '';
      if (!token || !owner || !repo || !path) return alert('Fill token, owner, repo and path');
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' };
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error("Fetch failed: " + res.statusText);
        const fileData = await res.json();
        const content = decodeURIComponent(escape(atob(fileData.content)));
        const sha = fileData.sha;
        const regex = /((?:const|let|var)\s+MAP_DATA\s*=\s*)({[\s\S]*?});/;
        const regexZones = /((?:const|let|var)\s+ENCOUNTER_ZONES\s*=\s*)({[\s\S]*?});/;
        const match = content.match(regex);
        let remoteMaps = {};
        if (match) {
          try { remoteMaps = new Function(`return ${match[2]}`)(); } catch(e) {}
        }
        const mergedMaps = {};
        Object.keys(allMaps).forEach(key => {
          const remoteEntry = remoteMaps[key] || {};
          mergedMaps[key] = {
            ...remoteEntry,
            layout: allMaps[key].layout,
            encounters: allMaps[key].encounters,
            warps: allMaps[key].warps || []
          };
        });
        const jsonStr = JSON.stringify(mergedMaps);
        let newContent = content.replace(regex, (m, p1, p2) => p1 + jsonStr + ";");
        newContent = newContent.replace(regexZones, (m, p1, p2) => p1 + JSON.stringify(encounterZones) + ";");
        const updateRes = await fetch(url, {
          method: 'PUT',
          headers,
          body: JSON.stringify({
            message: 'Update MAP_DATA via Map Editor',
            content: btoa(unescape(encodeURIComponent(newContent))),
            sha: sha
          })
        });
        if (!updateRes.ok) throw new Error((await updateRes.json()).message || updateRes.statusText);
        alert("Successfully exported to GitHub!");
        document.getElementById('settings-modal').classList.remove( 'active');
      } catch (e) { alert("Export Error: " + e.message); }
    }

    function setMode(m) {
      mode = m;
      document.getElementById('tool-pan').classList.toggle('active', mode === 'pan');
      document.getElementById('tool-pen').classList.toggle('active', mode === 'pen');
      document.getElementById('tool-zone').classList.toggle('active', mode === 'zone');
      document.getElementById('tool-warp').classList.toggle('active', mode === 'warp');
      Array.from(palette.getElementsByTagName('button')).forEach(b => {
        b.classList.toggle('active', mode === 'pen' && b.dataset.char === brush);
      });
      canvas.style.cursor = mode === 'pan' ? 'grab' : (mode === 'zone' ? 'cell' : (mode === 'warp' ? 'alias' : 'crosshair'));
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
    }

    function paint(ex, ey) {
      const rect = canvas.getBoundingClientRect();
      const tx = Math.floor((ex - rect.left - cam.x) / TILE_SIZE);
      const ty = Math.floor((ey - rect.top - cam.y) / TILE_SIZE);
      const curW = mapData[0]?.length || 0;
      const curH = mapData.length;
      if (tx >= 0 && tx < curW && ty >= 0 && ty < curH) {
        let changed = false;
        if (mode === 'pen') {
          const row = mapData[ty];
          if (row[tx] !== brush) {
            mapData[ty] = row.substring(0, tx) + brush + row.substring(tx + 1);
            changed = true;
          }
        } else if (mode === 'zone') {
          if (zoneData[ty][tx] !== activeZone) {
            zoneData[ty][tx] = activeZone;
            changed = true;
          }
        } else if (mode === 'warp') {
          isDown = false;
          openWarpModal(tx, ty);
        }
        if (changed) saveToStorage();
      }
    }

    function render() {
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(cam.x, cam.y);
      const curW = mapData[0]?.length || 0;
      const curH = mapData.length;
      const vX0 = Math.max(0, Math.floor(-cam.x / TILE_SIZE));
      const vX1 = Math.min(curW, Math.ceil((canvas.width - cam.x) / TILE_SIZE));
      const vY0 = Math.max(0, Math.floor(-cam.y / TILE_SIZE));
      const vY1 = Math.min(curH, Math.ceil((canvas.height - cam.y) / TILE_SIZE));
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(0, 0, curW * TILE_SIZE, curH * TILE_SIZE);
      for (let y = vY0; y < vY1; y++) {
        for (let x = vX0; x < vX1; x++) {
          ctx.fillStyle = TILES[mapData[y][x]].color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          const zid = zoneData[y][x];
          if (zid > 0 && (showZones || mode === 'zone')) {
            ctx.fillStyle = 'white';
            ctx.shadowBlur = 3;
            ctx.shadowColor = 'black';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(zid, x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2 + 4);
            ctx.shadowBlur = 0;
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
      if (showWarps || mode === 'warp') {
        warpData.forEach(w => {
          if (w.x >= vX0 && w.x < vX1 && w.y >= vY0 && w.y < vY1) {
            ctx.fillStyle = '#f43f5e';
            ctx.beginPath();
            ctx.arc(w.x * TILE_SIZE + TILE_SIZE/2, w.y * TILE_SIZE + TILE_SIZE/2, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.lineWidth = 1;
          }
        });
      }
      ctx.restore();
      requestAnimationFrame(render);
    }
    window.addEncounter = (zid) => { if(!encounterZones[zid]) encounterZones[zid]=[]; encounterZones[zid].push({weight:0.1, ennemies:[]}); saveToStorage(); refreshEncountersUI(); };
    window.removeEncounter = (zid, idx) => { encounterZones[zid].splice(idx,1); saveToStorage(); refreshEncountersUI(); };
    window.addEnemy = (zid, encIdx) => { encounterZones[zid][encIdx].ennemies.push({key:'slime', lvl:[1,5]}); saveToStorage(); refreshEncountersUI(); };
    window.removeEnemy = (zid, encIdx, enIdx) => { encounterZones[zid][encIdx].ennemies.splice(enIdx,1); saveToStorage(); refreshEncountersUI(); };
    window.updateEncValue = (zid, encIdx, k, v) => { encounterZones[zid][encIdx][k] = k==='weight'?parseFloat(v):v; saveToStorage(); };
    window.updateEnemyValue = (zid, encIdx, enIdx, k, si, v) => { if(k==='lvl') encounterZones[zid][encIdx].ennemies[enIdx].lvl[si]=parseInt(v); else encounterZones[zid][encIdx].ennemies[enIdx][k]=v; saveToStorage(); };
    function refreshEncountersUI() {
      const zid = document.getElementById('edit-zone-id').value;
      const list = document.getElementById('encounters-list');
      list.innerHTML = '';
      if(!encounterZones[zid]) return;
      encounterZones[zid].forEach((enc, encIdx) => {
        const div = document.createElement('div');
        div.style = "background:#334155; padding:10px; margin-bottom:10px; border-radius:4px; border:1px solid #475569";
        div.innerHTML = `<div class="form-group"><label>Weight (0-1)</label><input type="number" step="0.1" value="${enc.weight}" onchange="window.updateEncValue('${zid}',${encIdx},'weight',this.value)"></div><div style="margin-bottom:8px"><span class="label">Enemies</span></div><div id="enemies-${encIdx}"></div><button onclick="window.addEnemy('${zid}',${encIdx})" style="padding:4px 8px; font-size:11px; background:#10b981; border-color:#10b981; margin-top:5px; display:inline-block; width:auto">Add Enemy</button><button onclick="window.removeEncounter('${zid}',${encIdx})" style="padding:4px 8px; font-size:11px; background:#ef4444; border-color:#ef4444; margin-top:5px; display:inline-block; width:auto">Delete Encounter</button>`;
        list.appendChild(div);
        const elist = div.querySelector(`#enemies-${encIdx}`);
        enc.ennemies.forEach((en, enIdx) => {
          const row = document.createElement('div'); row.style = "display:flex; gap:4px; margin-bottom:4px;";
          row.innerHTML = `<input type="text" value="${en.key}" placeholder="key" style="flex:2; padding:4px; font-size:11px" onchange="window.updateEnemyValue('${zid}',${encIdx},${enIdx},'key',0,this.value)"><input type="number" value="${en.lvl[0]}" placeholder="min" style="flex:1; padding:4px; font-size:11px" onchange="window.updateEnemyValue('${zid}',${encIdx},${enIdx},'lvl',0,this.value)"><input type="number" value="${en.lvl[1]}" placeholder="max" style="flex:1; padding:4px; font-size:11px" onchange="window.updateEnemyValue('${zid}',${encIdx},${enIdx},'lvl',1,this.value)"><button onclick="window.removeEnemy('${zid}',${encIdx},${enIdx})" style="padding:4px 8px; background:#ef4444; border-color:#ef4444">Ã—</button>`;
          elist.appendChild(row);
        });
      });
    }
    init();
  </script>
</body>
</html>