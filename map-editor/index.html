<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Editor</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; height: 100vh; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; background: #0f172a; color: #f8fafc; }
    #toolbar { background: #1e293b; border-bottom: 1px solid #334155; padding: 8px; display: flex; gap: 12px; align-items: center; z-index: 10; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.3); overflow-x: auto; scrollbar-width: none; -ms-overflow-style: none; }
    #toolbar::-webkit-scrollbar { display: none; }
    .tool-section { display: flex; align-items: center; gap: 8px; border-right: 1px solid #475569; padding-right: 12px; flex-shrink: 0; }
    .palette { display: flex; gap: 4px; align-items: center; flex-shrink: 0; }
    .label { font-size: 10px; font-weight: 800; text-transform: uppercase; color: #94a3b8; letter-spacing: 0.05em; }
    button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px; white-space: nowrap; touch-action: manipulation; min-height: 38px; }
    button:hover { background: #475569; }
    button.active { background: #2563eb; border-color: #3b82f6; color: white; }
    #viewport { flex-grow: 1; position: relative; overflow: hidden; }
    canvas { display: block; touch-action: none; }
    .swatch { width: 12px; height: 12px; border: 1px solid rgba(0,0,0,0.3); border-radius: 2px; }
    #status { position: fixed; bottom: 16px; right: 16px; background: rgba(15, 23, 42, 0.9); padding: 4px 12px; border-radius: 100px; font-size: 12px; color: #94a3b8; border: 1px solid #334155; pointer-events: none; }
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 100; }
    .modal.active { display: flex; }
    .modal-content { background: #1e293b; padding: 24px; border-radius: 8px; width: 90%; max-width: 400px; border: 1px solid #475569; }
    .modal-content h2 { margin-top: 0; font-size: 18px; color: #f8fafc; }
    .form-group { margin-bottom: 12px; }
    .form-group label { display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px; text-transform: uppercase; font-weight: 700; }
    .form-group input { width: 100%; background: #0f172a; border: 1px solid #475569; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; outline: none; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
    select { background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; padding: 6px; outline: none; font-size: 13px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-section">
      <span class="label">Mode</span>
      <button id="tool-pan">Pan</button>
      <button id="tool-pen">Tiles</button>
      <button id="tool-zone">Zones</button>
      <button id="tool-warp">Warps</button>
      <button id="tool-npc">NPCs</button>
      <button id="tool-toggle-zones">View Zones</button>
      <button id="tool-toggle-warps">View Warps</button>
      <button id="tool-toggle-npcs">View NPCs</button>
      <button id="btn-settings">Settings</button><button id="btn-manage-encounters">Encounters</button>
    </div>
    <div class="tool-section" id="map-select-section" style="display:none">
      <span class="label">Map</span>
      <select id="map-select"></select>
    </div>
    <div class="tool-section">
      <span class="label">Zone ID</span>
      <input type="number" id="zone-id" value="1" min="0" max="99" style="width: 45px; background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; padding: 4px; outline: none;">
    </div>
    <div class="palette" id="palette">
      <span class="label">Tiles</span>
    </div>
  </div>
  <div id="viewport">
    <canvas id="editorCanvas"></canvas>
  </div>
  <div id="status">X: 0, Y: 0</div>
  <div id="warp-modal" class="modal">
    <div class="modal-content">
      <h2 id="warp-modal-title">Edit Warp</h2>
      <div class="form-group">
        <label>Destination Map</label>
        <select id="warp-dest-map"></select>
      </div>
      <div class="form-group">
        <label>Destination X</label>
        <input type="number" id="warp-dest-x">
      </div>
      <div class="form-group">
        <label>Destination Y</label>
        <input type="number" id="warp-dest-y">
      </div>
      <div class="modal-actions">
        <button id="btn-warp-delete" style="background: #ef4444; border-color: #ef4444;">Delete</button>
        <button id="btn-warp-save" style="background: #2563eb; border-color: #2563eb;">Save</button>
        <button id="btn-warp-close">Close</button>
      </div>
    </div>
  </div>
  <div id="npc-modal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <h2 id="npc-modal-title">Edit NPC</h2>
      <div class="form-group">
        <label>NPC ID</label>
        <input type="text" id="npc-id">
      </div>
      <div class="form-group">
        <label>Map ID</label>
        <select id="npc-map-id"></select>
      </div>
      <div style="display:flex; gap:8px">
        <div class="form-group" style="flex:1">
          <label>X</label>
          <input type="number" id="npc-x">
        </div>
        <div class="form-group" style="flex:1">
          <label>Y</label>
          <input type="number" id="npc-y">
        </div>
      </div>
      <div class="form-group">
        <label>Data (JSON)</label>
        <textarea id="npc-json" style="width:100%; height:150px; background:#0f172a; color:#f8fafc; border:1px solid #475569; border-radius:4px; font-family:monospace; padding:8px; box-sizing:border-box; outline:none;"></textarea>
      </div>
      <div class="modal-actions">
        <button id="btn-npc-delete" style="background: #ef4444; border-color: #ef4444;">Delete</button>
        <button id="btn-npc-save" style="background: #2563eb; border-color: #2563eb;">Save</button>
        <button id="btn-npc-close">Close</button>
      </div>
    </div>
  </div>
  <!-- Modal 1: Zones List -->
  <div id="modal-zones-1" class="modal">
    <div class="modal-content">
      <h2>Encounter Zones</h2>
      <div id="zones-list-container" style="display: flex; flex-direction: column; gap: 8px; max-height: 60vh; overflow-y: auto; margin-bottom: 20px;"></div>
      <div class="modal-actions">
        <button onclick="window.addNewZone()" style="background: #10b981; border-color: #10b981;">Add Zone</button>
        <button onclick="window.closeModal('modal-zones-1')">Close</button>
      </div>
    </div>
  </div>
  <!-- Modal 2: Zone Detail -->
  <div id="modal-zones-2" class="modal">
    <div class="modal-content">
      <h2 id="m2-title">Zone Details</h2>
      <div class="form-group">
        <label>Zone ID</label>
        <input type="number" id="m2-zone-id" onchange="window.renameZone(this.value)">
      </div>
      <div id="encounters-list-container" style="display: flex; flex-direction: column; gap: 8px; max-height: 50vh; overflow-y: auto; margin-bottom: 20px;"></div>
      <div class="modal-actions">
        <button onclick="window.addNewEncounter()" style="background: #10b981; border-color: #10b981;">Add Encounter</button>
        <button onclick="window.deleteCurrentZone()" style="background: #ef4444; border-color: #ef4444;">Delete Zone</button>
        <button onclick="window.openModal1()">Back</button>
      </div>
    </div>
  </div>
  <!-- Modal 3: Encounter Detail -->
  <div id="modal-zones-3" class="modal">
    <div class="modal-content">
      <h2>Encounter Details</h2>
      <div class="form-group">
        <label>Weight (0.0 - 1.0)</label>
        <input type="number" step="0.1" id="m3-weight" onchange="window.updateWeight(this.value)">
      </div>
      <label class="label">Enemies</label>
      <div id="enemies-list-container" style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px; max-height: 40vh; overflow-y: auto; margin-bottom: 20px;"></div>
      <div class="modal-actions">
        <button onclick="window.addNewEnemy()" style="background: #10b981; border-color: #10b981;">Add Enemy</button>
        <button onclick="window.deleteCurrentEncounter()" style="background: #ef4444; border-color: #ef4444;">Delete Encounter</button>
        <button onclick="window.openModal2(window.currentZoneId)">Back</button>
      </div>
    </div>
  </div><div id="settings-modal" class="modal">
    <div class="modal-content">
      <h2>GitHub Settings</h2>
      <div class="form-group">
        <label>Personal Access Token (Optional)</label>
        <input type="password" id="gh-token">
      </div>
      <div class="form-group">
        <label>Owner</label>
        <input type="text" id="gh-owner" placeholder="username">
      </div>
      <div class="form-group">
        <label>Repo</label>
        <input type="text" id="gh-repo" placeholder="repository-name">
      </div>
      <div class="form-group">
        <label>Path</label>
        <input type="text" id="gh-path" placeholder="path/to/index.html">
      </div>
      <div class="modal-actions">
        <button id="btn-gh-import" style="background: #059669; border-color: #059669;">Import Maps</button>
        <button id="btn-gh-export" style="background: #2563eb; border-color: #2563eb;">Export Maps</button>
        <button id="btn-settings-close">Close</button>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const palette = document.getElementById('palette');
    const status = document.getElementById('status');
    const TILE_SIZE = 32;
    const DEFAULT_SIZE = 60;
    const TILES = {
      'T': { type: 'tree', color: '#064e3b' },
      ' ': { type: 'grass', color: '#2ecc71' },
      'D': { type: 'dirt', color: '#d35400' },
      'f': { type: 'forest', color: '#1b5e20' },
      'm': { type: 'mountain', color: '#7f8c8d' },
      's': { type: 'sand', color: '#f1c40f' },
      'W': { type: 'water', color: '#3498db' },
      'b': { type: 'boulder', color: '#475569' }
    };
    let allMaps = { 'default': { layout: Array.from({ length: DEFAULT_SIZE }, () => ' '.repeat(DEFAULT_SIZE)), encounters: Array.from({ length: DEFAULT_SIZE }, () => Array(DEFAULT_SIZE).fill(0)), warps: [] } };
    let currentMapName = 'default';
    let mapData = allMaps['default'].layout;
    let zoneData = allMaps['default'].encounters;
    let warpData = allMaps['default'].warps || [];
    let cam = { x: 50, y: 50 };
    let mode = 'pen';
    let brush = ' ';
    let activeZone = 1;
    let isDown = false;
    let lastPos = { x: 0, y: 0 };
    let showZones = false;
    let showWarps = false;
    let editingWarp = null; let encounterZones = {}; let monsterDb = {}; let npcLocations = []; let showNpcs = false; let editingNpcIdx = null;

function saveToStorage() {
      allMaps[currentMapName] = { layout: mapData, encounters: zoneData, warps: warpData };
      localStorage.setItem('map_editor_save', JSON.stringify({ allMaps, currentMapName, encounterZones, monsterDb, npcLocations }));
    }

    function loadFromStorage() {
      const saved = localStorage.getItem('map_editor_save');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (data.allMaps) {
            allMaps = data.allMaps;
            currentMapName = data.currentMapName || Object.keys(allMaps)[0];
            mapData = allMaps[currentMapName].layout;
            zoneData = allMaps[currentMapName].encounters;
            warpData = allMaps[currentMapName].warps || [];
            encounterZones = data.encounterZones || {}; monsterDb = data.monsterDb || {};
            npcLocations = data.npcLocations || [];
            updateMapSelector();
          }
        } catch (e) { console.error("Failed to load map", e); }
      }
      document.getElementById('gh-token').value = localStorage.getItem('gh_token') || '';
      document.getElementById('gh-owner').value = localStorage.getItem('gh_owner') || '';
      document.getElementById('gh-repo').value = localStorage.getItem('gh_repo') || '';
      document.getElementById('gh-path').value = localStorage.getItem('gh_path') || '';
    }

    function init() {
      loadFromStorage();
      Object.entries(TILES).forEach(([char, cfg]) => {
        const b = document.createElement('button');
        b.innerHTML = `<div class="swatch" style="background:${cfg.color}"></div>${cfg.type}`;
        b.onclick = (e) => { e.preventDefault(); brush = char; setMode('pen'); };
        b.dataset.char = char;
        palette.appendChild(b);
      });
      document.getElementById('tool-pan').onclick = () => setMode('pan');
      document.getElementById('tool-pen').onclick = () => setMode('pen');
      document.getElementById('tool-zone').onclick = () => setMode('zone');
      document.getElementById('tool-warp').onclick = () => setMode('warp');
      document.getElementById('tool-npc').onclick = () => setMode('npc');
      document.getElementById('tool-toggle-zones').onclick = () => {
        showZones = !showZones;
        document.getElementById('tool-toggle-zones').classList.toggle('active', showZones);
      };
      document.getElementById('tool-toggle-warps').onclick = () => {
        showWarps = !showWarps;
        document.getElementById('tool-toggle-warps').classList.toggle('active', showWarps);
      };
      document.getElementById('tool-toggle-npcs').onclick = () => {
        showNpcs = !showNpcs;
        document.getElementById('tool-toggle-npcs').classList.toggle('active', showNpcs);
      };
      document.getElementById('btn-settings').onclick = () => document.getElementById('settings-modal').classList.add('active');
      document.getElementById('btn-settings-close').onclick = () => document.getElementById('settings-modal').classList.remove('active');
      document.getElementById('btn-manage-encounters').onclick = () => window.openModal1();
      document.getElementById('btn-gh-import').onclick = importFromGitHub;
      document.getElementById('btn-gh-export').onclick = exportToGitHub;
      document.getElementById('btn-warp-save').onclick = saveWarp;
      document.getElementById('btn-warp-delete').onclick = deleteWarp;
      document.getElementById('btn-warp-close').onclick = () => document.getElementById('warp-modal').classList.remove('active');
      document.getElementById('btn-npc-save').onclick = saveNpc;
      document.getElementById('btn-npc-delete').onclick = deleteNpc;
      document.getElementById('btn-npc-close').onclick = () => document.getElementById('npc-modal').classList.remove('active');
      document.getElementById('map-select').onchange = (e) => switchMap(e.target.value);
      document.getElementById('zone-id').onchange = (e) => activeZone = parseInt(e.target.value) || 0;
      window.addEventListener('resize', resize);
      const handleStart = (e) => {
        isDown = true;
        const p = e.touches ? e.touches[0] : e;
        lastPos = { x: p.clientX, y: p.clientY };
        if (mode !== 'pan') paint(p.clientX, p.clientY);
      };
      const handleMove = (e) => {
        const p = e.touches ? e.touches[0] : e;
        const rect = canvas.getBoundingClientRect();
        const mx = Math.floor((p.clientX - rect.left - cam.x) / TILE_SIZE);
        const my = Math.floor((p.clientY - rect.top - cam.y) / TILE_SIZE);
        const curW = mapData[0]?.length || 0;
        const curH = mapData.length;
        if (mx >= 0 && mx < curW && my >= 0 && my < curH) status.innerText = `X: ${mx}, Y: ${my}`;
        if (!isDown) return;
        if (mode === 'pan') {
          cam.x += p.clientX - lastPos.x;
          cam.y += p.clientY - lastPos.y;
        } else paint(p.clientX, p.clientY);
        lastPos = { x: p.clientX, y: p.clientY };
      };
      const handleEnd = () => isDown = false;
      canvas.addEventListener('mousedown', handleStart);
      canvas.addEventListener('touchstart', handleStart, { passive: false });
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('touchmove', handleMove, { passive: false });
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchend', handleEnd);
      window.addEventListener('touchcancel', handleEnd);
      resize();
      setMode('pen');
      render();
    }

    function updateMapSelector() {
      const select = document.getElementById('map-select');
      const container = document.getElementById('map-select-section');
      const keys = Object.keys(allMaps);
      if (keys.length <= 1) {
        container.style.display = 'none';
      } else {
        container.style.display = 'flex';
        select.innerHTML = '';
        keys.forEach(k => {
          const opt = document.createElement('option');
          opt.value = k; opt.textContent = k; opt.selected = (k === currentMapName);
          select.appendChild(opt);
        });
      }
    }

    function switchMap(name) {
      allMaps[currentMapName] = { layout: mapData, encounters: zoneData, warps: warpData };
      currentMapName = name;
      mapData = allMaps[name].layout;
      zoneData = allMaps[name].encounters;
      warpData = allMaps[name].warps || [];
      cam.x = 0; cam.y = 0;
    }

    function openWarpModal(tx, ty) {
      editingWarp = warpData.find(w => w.x === tx && w.y === ty);
      document.getElementById('warp-modal-title').textContent = editingWarp ? 'Edit Warp' : 'New Warp';
      const destSelect = document.getElementById('warp-dest-map');
      destSelect.innerHTML = '';
      Object.keys(allMaps).forEach(m => {
        const opt = document.createElement('option');
        opt.value = m; opt.textContent = m;
        destSelect.appendChild(opt);
      });
      if (editingWarp) {
        destSelect.value = editingWarp.destMap;
        document.getElementById('warp-dest-x').value = editingWarp.destX;
        document.getElementById('warp-dest-y').value = editingWarp.destY;
        document.getElementById('btn-warp-delete').style.display = 'block';
      } else {
        destSelect.value = currentMapName;
        document.getElementById('warp-dest-x').value = tx;
        document.getElementById('warp-dest-y').value = ty;
        document.getElementById('btn-warp-delete').style.display = 'none';
        editingWarp = { x: tx, y: ty };
      }
      document.getElementById('warp-modal').classList.add('active');
    }

    function saveWarp() {
      const w = { x: editingWarp.x, y: editingWarp.y, destMap: document.getElementById('warp-dest-map').value, destX: parseInt(document.getElementById('warp-dest-x').value) || 0, destY: parseInt(document.getElementById('warp-dest-y').value) || 0 };
      const idx = warpData.findIndex(ex => ex.x === w.x && ex.y === w.y);
      if (idx !== -1) warpData[idx] = w; else warpData.push(w);
      saveToStorage();
      document.getElementById('warp-modal').classList.remove('active');
    }

    function deleteWarp() {
      warpData = warpData.filter(w => !(w.x === editingWarp.x && w.y === editingWarp.y));
      saveToStorage();
      document.getElementById('warp-modal').classList.remove('active');
    }

    async function importFromGitHub() {
      const tokenInput = document.getElementById('gh-token').value.trim();
      const owner = document.getElementById('gh-owner').value.trim();
      const repo = document.getElementById('gh-repo').value.trim();
      const path = document.getElementById('gh-path').value.trim();
      if (tokenInput) localStorage.setItem('gh_token', tokenInput);
      localStorage.setItem('gh_owner', owner);
      localStorage.setItem('gh_repo', repo);
      localStorage.setItem('gh_path', path);
      const token = tokenInput || localStorage.getItem('gh_token') || '';
      if (!owner || !repo || !path) return alert('Fill owner, repo and path');
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const headers = token ? { 'Authorization': `token ${token}` } : {};
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        const content = atob(data.content);
        const match = content.match(/(?:const|let|var)\s+MAP_DATA\s*=\s*({[\s\S]*?});/);
        if (!match) throw new Error("MAP_DATA not found in file");
        const parsed = new Function(`return ${match[1]}`)();
        const matchZones = content.match(/(?:const|let|var)\s+ENCOUNTER_ZONES\s*=\s*({[\s\S]*?});/);
        if (matchZones) encounterZones = new Function(`return ${matchZones[1]}`)();
        const matchMonsters = content.match(/(?:const|let|var)\s+MONSTER_DB\s*=\s*({[\s\S]*?});/);
        if (matchMonsters) monsterDb = new Function("return " + matchMonsters[1])();
        const matchNpcs = content.match(/(?:const|let|var)\s+NPC_LOCATIONS\s*=\s*(\[[\s\S]*?\]);/);
        if (matchNpcs) npcLocations = new Function(`return ${matchNpcs[1]}`)();
        allMaps = parsed;
        currentMapName = Object.keys(allMaps)[0];
        mapData = allMaps[currentMapName].layout;
        zoneData = allMaps[currentMapName].encounters;
        warpData = allMaps[currentMapName].warps || [];
        updateMapSelector();
        saveToStorage();
        document.getElementById('settings-modal').classList.remove('active');
        alert("Imported " + Object.keys(allMaps).length + " maps");
      } catch (e) { alert("Error: " + e.message); }
    }

    async function exportToGitHub() {
      saveToStorage();
      const tokenInput = document.getElementById('gh-token').value.trim();
      const owner = document.getElementById('gh-owner').value.trim();
      const repo = document.getElementById('gh-repo').value.trim();
      const path = document.getElementById('gh-path').value.trim();
      if (tokenInput) localStorage.setItem('gh_token', tokenInput);
      localStorage.setItem('gh_owner', owner);
      localStorage.setItem('gh_repo', repo);
      localStorage.setItem('gh_path', path);
      const token = tokenInput || localStorage.getItem('gh_token') || '';
      if (!token || !owner || !repo || !path) return alert('Fill token, owner, repo and path');
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' };
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error("Fetch failed: " + res.statusText);
        const fileData = await res.json();
        const content = decodeURIComponent(escape(atob(fileData.content)));
        const sha = fileData.sha;
        const regex = /((?:const|let|var)\s+MAP_DATA\s*=\s*)({[\s\S]*?});/;
        const regexZones = /((?:const|let|var)\s+ENCOUNTER_ZONES\s*=\s*)({[\s\S]*?});/;
        const match = content.match(regex);
        let remoteMaps = {};
        if (match) {
          try { remoteMaps = new Function(`return ${match[2]}`)(); } catch(e) {}
        }
        const mergedMaps = {};
        Object.keys(allMaps).forEach(key => {
          const remoteEntry = remoteMaps[key] || {};
          mergedMaps[key] = {
            ...remoteEntry,
            layout: allMaps[key].layout,
            encounters: allMaps[key].encounters,
            warps: allMaps[key].warps || []
          };
        });
        const jsonStr = JSON.stringify(mergedMaps);
        let newContent = content.replace(regex, (m, p1, p2) => p1 + jsonStr + ";");
        newContent = newContent.replace(regexZones, (m, p1, p2) => p1 + JSON.stringify(encounterZones) + ";");
        const regexNpcs = /((?:const|let|var)\s+NPC_LOCATIONS\s*=\s*)(\[[\s\S]*?\]);/;
        newContent = newContent.replace(regexNpcs, (m, p1, p2) => p1 + JSON.stringify(npcLocations) + ";");
        const updateRes = await fetch(url, {
          method: 'PUT',
          headers,
          body: JSON.stringify({
            message: 'Update MAP_DATA via Map Editor',
            content: btoa(unescape(encodeURIComponent(newContent))),
            sha: sha
          })
        });
        if (!updateRes.ok) throw new Error((await updateRes.json()).message || updateRes.statusText);
        alert("Successfully exported to GitHub!");
        document.getElementById('settings-modal').classList.remove( 'active');
      } catch (e) { alert("Export Error: " + e.message); }
    }

    function setMode(m) {
      mode = m;
      document.getElementById('tool-pan').classList.toggle('active', mode === 'pan');
      document.getElementById('tool-pen').classList.toggle('active', mode === 'pen');
      document.getElementById('tool-zone').classList.toggle('active', mode === 'zone');
      document.getElementById('tool-warp').classList.toggle('active', mode === 'warp');
      document.getElementById('tool-npc').classList.toggle('active', mode === 'npc');
      Array.from(palette.getElementsByTagName('button')).forEach(b => {
        b.classList.toggle('active', mode === 'pen' && b.dataset.char === brush);
      });
      canvas.style.cursor = mode === 'pan' ? 'grab' : (mode === 'zone' ? 'cell' : (mode === 'warp' ? 'alias' : (mode === 'npc' ? 'pointer' : 'crosshair')));
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
    }

    function paint(ex, ey) {
      const rect = canvas.getBoundingClientRect();
      const tx = Math.floor((ex - rect.left - cam.x) / TILE_SIZE);
      const ty = Math.floor((ey - rect.top - cam.y) / TILE_SIZE);
      const curW = mapData[0]?.length || 0;
      const curH = mapData.length;
      if (tx >= 0 && tx < curW && ty >= 0 && ty < curH) {
        let changed = false;
        if (mode === 'pen') {
          const row = mapData[ty];
          if (row[tx] !== brush) {
            mapData[ty] = row.substring(0, tx) + brush + row.substring(tx + 1);
            changed = true;
          }
        } else if (mode === 'zone') {
          if (zoneData[ty][tx] !== activeZone) {
            zoneData[ty][tx] = activeZone;
            changed = true;
          }
        } else if (mode === 'warp') {
          isDown = false;
          openWarpModal(tx, ty);
        } else if (mode === 'npc') {
          isDown = false;
          openNpcModal(tx, ty);
        }
        if (changed) saveToStorage();
      }
    }

    function render() {
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(cam.x, cam.y);
      const curW = mapData[0]?.length || 0;
      const curH = mapData.length;
      const vX0 = Math.max(0, Math.floor(-cam.x / TILE_SIZE));
      const vX1 = Math.min(curW, Math.ceil((canvas.width - cam.x) / TILE_SIZE));
      const vY0 = Math.max(0, Math.floor(-cam.y / TILE_SIZE));
      const vY1 = Math.min(curH, Math.ceil((canvas.height - cam.y) / TILE_SIZE));
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(0, 0, curW * TILE_SIZE, curH * TILE_SIZE);
      for (let y = vY0; y < vY1; y++) {
        for (let x = vX0; x < vX1; x++) {
          ctx.fillStyle = TILES[mapData[y][x]].color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          const zid = zoneData[y][x];
          if (zid > 0 && (showZones || mode === 'zone')) {
            ctx.fillStyle = 'white';
            ctx.shadowBlur = 3;
            ctx.shadowColor = 'black';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(zid, x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2 + 4);
            ctx.shadowBlur = 0;
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
      if (showWarps || mode === 'warp') {
        warpData.forEach(w => {
          if (w.x >= vX0 && w.x < vX1 && w.y >= vY0 && w.y < vY1) {
            ctx.fillStyle = '#f43f5e';
            ctx.beginPath();
            ctx.arc(w.x * TILE_SIZE + TILE_SIZE/2, w.y * TILE_SIZE + TILE_SIZE/2, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.lineWidth = 1;
          }
        });
      }
      if (showNpcs || mode === 'npc') {
        npcLocations.forEach(n => {
          if (n.mapId === currentMapName && n.x >= vX0 && n.x < vX1 && n.y >= vY0 && n.y < vY1) {
            ctx.fillStyle = '#a855f7';
            ctx.beginPath();
            ctx.moveTo(n.x * TILE_SIZE + TILE_SIZE / 2, n.y * TILE_SIZE + 4);
            ctx.lineTo(n.x * TILE_SIZE + TILE_SIZE - 4, n.y * TILE_SIZE + TILE_SIZE - 4);
            ctx.lineTo(n.x * TILE_SIZE + 4, n.y * TILE_SIZE + TILE_SIZE - 4);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.lineWidth = 1;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(n.id.substring(0, 5), n.x * TILE_SIZE + TILE_SIZE / 2, n.y * TILE_SIZE + TILE_SIZE + 10);
          }
        });
      }
      ctx.restore();
      requestAnimationFrame(render);
    }
        window.currentZoneId = null;
    window.currentEncounterIdx = null;
    window.closeModal = (id) => document.getElementById(id).classList.remove('active');
    window.openModal = (id) => document.getElementById(id).classList.add('active');
    window.openModal1 = () => {
      window.closeModal('modal-zones-2');
      window.closeModal('modal-zones-3');
      const container = document.getElementById('zones-list-container');
      container.innerHTML = '';
      Object.keys(encounterZones).sort((a,b)=>a-b).forEach(zid => {
        const btn = document.createElement('button');
        btn.textContent = `Zone ${zid} (${encounterZones[zid].length} encounters)`;
        btn.style.width = '100%';
        btn.onclick = () => window.openModal2(zid);
        container.appendChild(btn);
      });
      window.openModal('modal-zones-1');
    };
    window.addNewZone = () => {
      let nextId = 1;
      while(encounterZones[nextId]) nextId++;
      encounterZones[nextId] = [];
      saveToStorage();
      window.openModal1();
    };
    window.openModal2 = (zid) => {
      window.currentZoneId = zid;
      window.closeModal('modal-zones-1');
      window.closeModal('modal-zones-3');
      document.getElementById('m2-title').textContent = `Zone ${zid} Details`;
      document.getElementById('m2-zone-id').value = zid;
      const container = document.getElementById('encounters-list-container');
      container.innerHTML = '';
      encounterZones[zid].forEach((enc, idx) => {
        const btn = document.createElement('button');
        btn.textContent = `Encounter ${idx} (Weight: ${enc.weight})`;
        btn.style.width = '100%';
        btn.onclick = () => window.openModal3(idx);
        container.appendChild(btn);
      });
      window.openModal('modal-zones-2');
    };
    window.renameZone = (newId) => {
      if (!newId || newId == window.currentZoneId) return;
      if (encounterZones[newId]) { alert("Zone ID already exists"); return; }
      encounterZones[newId] = encounterZones[window.currentZoneId];
      delete encounterZones[window.currentZoneId];
      window.currentZoneId = newId;
      saveToStorage();
      window.openModal2(newId);
    };
    window.deleteCurrentZone = () => {
      if (confirm(`Delete zone ${window.currentZoneId}?`)) {
        delete encounterZones[window.currentZoneId];
        saveToStorage();
        window.openModal1();
      }
    };
    window.addNewEncounter = () => {
      encounterZones[window.currentZoneId].push({ weight: 0.1, enemies: [] });
      saveToStorage();
      window.openModal2(window.currentZoneId);
    };
    window.openModal3 = (idx) => {
      window.currentEncounterIdx = idx;
      window.closeModal('modal-zones-2');
      const enc = encounterZones[window.currentZoneId][idx];
      document.getElementById('m3-weight').value = enc.weight;
      window.refreshEnemiesList();
      window.openModal('modal-zones-3');
    };
    window.updateWeight = (val) => {
      encounterZones[window.currentZoneId][window.currentEncounterIdx].weight = parseFloat(val) || 0;
      saveToStorage();
    };
    window.refreshEnemiesList = () => {
      const container = document.getElementById('enemies-list-container');
      container.innerHTML = '';
      const enemies = encounterZones[window.currentZoneId][window.currentEncounterIdx].enemies;
      const monsterKeys = Object.keys(monsterDb).sort();
      enemies.forEach((en, enIdx) => {
        const div = document.createElement('div');
        div.style = "display: flex; gap: 4px; align-items: center;";
        const keysToShow = monsterKeys.includes(en.key) ? monsterKeys : [en.key, ...monsterKeys];
        const options = keysToShow.map(k => `<option value="${k}" ${k === en.key ? 'selected' : ''}>${k}</option>`).join('');
        div.innerHTML = `<select style="flex:2; padding:6px; background:#0f172a; border:1px solid #475569; color:white; border-radius:4px;" onchange="window.updateEnemy(${enIdx}, 'key', this.value)">${options}</select><input type="number" value="${en.lvl[0]}" placeholder="Min" style="flex:1; width:40px; padding:6px; background:#0f172a; border:1px solid #475569; color:white; border-radius:4px;" onchange="window.updateEnemy(${enIdx}, 'min', this.value)"><input type="number" value="${en.lvl[1]}" placeholder="Max" style="flex:1; width:40px; padding:6px; background:#0f172a; border:1px solid #475569; color:white; border-radius:4px;" onchange="window.updateEnemy(${enIdx}, 'max', this.value)"><button onclick="window.deleteEnemy(${enIdx})" style="background:#ef4444; border-color:#ef4444; padding: 4px 8px;">Ã—</button>`;
        container.appendChild(div);
      });
    };
    window.updateEnemy = (idx, field, val) => {
      const en = encounterZones[window.currentZoneId][window.currentEncounterIdx].enemies[idx];
      if (field === 'key') en.key = val;
      if (field === 'min') en.lvl[0] = parseInt(val) || 0;
      if (field === 'max') en.lvl[1] = parseInt(val) || 0;
      saveToStorage();
    };
    window.addNewEnemy = () => {
      const keys = Object.keys(monsterDb);
      const defaultKey = keys.length > 0 ? keys[0] : 'slime';
      encounterZones[window.currentZoneId][window.currentEncounterIdx].enemies.push({ key: defaultKey, lvl: [1, 5] });
      saveToStorage();
      window.refreshEnemiesList();
    };
    window.deleteEnemy = (idx) => {
      encounterZones[window.currentZoneId][window.currentEncounterIdx].enemies.splice(idx, 1);
      saveToStorage();
      window.refreshEnemiesList();
    };
    window.deleteCurrentEncounter = () => {
      encounterZones[window.currentZoneId].splice(window.currentEncounterIdx, 1);
      saveToStorage();
      window.openModal2(window.currentZoneId);
    };

    function openNpcModal(tx, ty) {
      editingNpcIdx = npcLocations.findIndex(n => n.mapId === currentMapName && n.x === tx && n.y === ty);
      const npc = editingNpcIdx !== -1 ? npcLocations[editingNpcIdx] : null;
      const destSelect = document.getElementById('npc-map-id');
      destSelect.innerHTML = '';
      Object.keys(allMaps).forEach(m => {
        const opt = document.createElement('option');
        opt.value = m; opt.textContent = m;
        destSelect.appendChild(opt);
      });
      if (npc) {
        document.getElementById('npc-modal-title').textContent = 'Edit NPC';
        document.getElementById('npc-id').value = npc.id;
        document.getElementById('npc-map-id').value = npc.mapId;
        document.getElementById('npc-x').value = npc.x;
        document.getElementById('npc-y').value = npc.y;
        document.getElementById('npc-json').value = JSON.stringify(npc, null, 2);
        document.getElementById('btn-npc-delete').style.display = 'block';
      } else {
        document.getElementById('npc-modal-title').textContent = 'New NPC';
        const newNpc = { id: 'npc_' + Math.random().toString(36).substr(2, 5), x: tx, y: ty, mapId: currentMapName };
        document.getElementById('npc-id').value = newNpc.id;
        document.getElementById('npc-map-id').value = currentMapName;
        document.getElementById('npc-x').value = tx;
        document.getElementById('npc-y').value = ty;
        document.getElementById('npc-json').value = JSON.stringify(newNpc, null, 2);
        document.getElementById('btn-npc-delete').style.display = 'none';
      }
      document.getElementById('npc-modal').classList.add('active');
    }
    function saveNpc() {
      try {
        const data = JSON.parse(document.getElementById('npc-json').value);
        data.id = document.getElementById('npc-id').value;
        data.mapId = document.getElementById('npc-map-id').value;
        data.x = parseInt(document.getElementById('npc-x').value) || 0;
        data.y = parseInt(document.getElementById('npc-y').value) || 0;
        if (editingNpcIdx !== -1) npcLocations[editingNpcIdx] = data;
        else npcLocations.push(data);
        saveToStorage();
        document.getElementById('npc-modal').classList.remove('active');
      } catch (e) { alert("Invalid JSON: " + e.message); }
    }
    function deleteNpc() {
      if (editingNpcIdx !== -1) {
        npcLocations.splice(editingNpcIdx, 1);
        saveToStorage();
      }
      document.getElementById('npc-modal').classList.remove('active');
    }
    init();
  </script>
</body>
</html>