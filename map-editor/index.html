<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Editor</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; height: 100vh; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; background: #0f172a; color: #f8fafc; }
    #toolbar { background: #1e293b; border-bottom: 1px solid #334155; padding: 8px; display: flex; gap: 12px; align-items: center; z-index: 10; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.3); overflow-x: auto; scrollbar-width: none; -ms-overflow-style: none; }
    #toolbar::-webkit-scrollbar { display: none; }
    .tool-section { display: flex; align-items: center; gap: 8px; border-right: 1px solid #475569; padding-right: 12px; flex-shrink: 0; }
    .palette { display: flex; gap: 4px; align-items: center; flex-shrink: 0; }
    .label { font-size: 10px; font-weight: 800; text-transform: uppercase; color: #94a3b8; letter-spacing: 0.05em; }
    button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px; white-space: nowrap; touch-action: manipulation; min-height: 38px; }
    button:hover { background: #475569; }
    button.active { background: #2563eb; border-color: #3b82f6; color: white; }
    #viewport { flex-grow: 1; position: relative; overflow: hidden; }
    canvas { display: block; touch-action: none; }
    .swatch { width: 12px; height: 12px; border: 1px solid rgba(0,0,0,0.3); border-radius: 2px; }
    #status { position: fixed; bottom: 16px; right: 16px; background: rgba(15, 23, 42, 0.9); padding: 4px 12px; border-radius: 100px; font-size: 12px; color: #94a3b8; border: 1px solid #334155; pointer-events: none; }
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 100; }
    .modal.active { display: flex; }
    .modal-content { background: #1e293b; padding: 24px; border-radius: 8px; width: 90%; max-width: 400px; border: 1px solid #475569; }
    .modal-content h2 { margin-top: 0; font-size: 18px; color: #f8fafc; }
    .form-group { margin-bottom: 12px; }
    .form-group label { display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px; text-transform: uppercase; font-weight: 700; }
    .form-group input { width: 100%; background: #0f172a; border: 1px solid #475569; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; outline: none; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
    select { background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; padding: 6px; outline: none; font-size: 13px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-section">
      <span class="label">Mode</span>
      <button id="tool-pan">Pan</button>
      <button id="tool-pen">Tiles</button>
      <button id="tool-zone">Zones</button>
      <button id="tool-toggle-zones">View Zones</button>
      <button id="btn-settings">Settings</button>
    </div>
    <div class="tool-section" id="map-select-section" style="display:none">
      <span class="label">Map</span>
      <select id="map-select"></select>
    </div>
    <div class="tool-section">
      <span class="label">Zone ID</span>
      <input type="number" id="zone-id" value="1" min="0" max="99" style="width: 45px; background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; padding: 4px; outline: none;">
    </div>
    <div class="palette" id="palette">
      <span class="label">Tiles</span>
    </div>
  </div>
  <div id="viewport">
    <canvas id="editorCanvas"></canvas>
  </div>
  <div id="status">X: 0, Y: 0</div>
  <div id="settings-modal" class="modal">
    <div class="modal-content">
      <h2>GitHub Settings</h2>
      <div class="form-group">
        <label>Personal Access Token (Optional)</label>
        <input type="password" id="gh-token">
      </div>
      <div class="form-group">
        <label>Owner</label>
        <input type="text" id="gh-owner" placeholder="username">
      </div>
      <div class="form-group">
        <label>Repo</label>
        <input type="text" id="gh-repo" placeholder="repository-name">
      </div>
      <div class="form-group">
        <label>Path</label>
        <input type="text" id="gh-path" placeholder="path/to/index.html">
      </div>
      <div class="modal-actions">
        <button id="btn-gh-import" style="background: #059669; border-color: #059669;">Import Maps</button>
        <button id="btn-gh-export" style="background: #2563eb; border-color: #2563eb;">Export Maps</button>
        <button id="btn-settings-close">Close</button>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const palette = document.getElementById('palette');
    const status = document.getElementById('status');
    const TILE_SIZE = 32;
    const DEFAULT_SIZE = 60;
    const TILES = {
      'T': { type: 'tree', color: '#064e3b' },
      ' ': { type: 'grass', color: '#2ecc71' },
      'D': { type: 'dirt', color: '#d35400' },
      'f': { type: 'dungeon', color: '#1b5e20' },
      'm': { type: 'dungeon', color: '#7f8c8d' },
      's': { type: 'dungeon', color: '#f1c40f' },
      'W': { type: 'water', color: '#3498db' },
      'b': { type: 'boulder', color: '#475569' }
    };
    let allMaps = { 'default': { layout: Array.from({ length: DEFAULT_SIZE }, () => ' '.repeat(DEFAULT_SIZE)), encounters: Array.from({ length: DEFAULT_SIZE }, () => Array(DEFAULT_SIZE).fill(0)) } };
    let currentMapName = 'default';
    let mapData = allMaps['default'].layout;
    let zoneData = allMaps['default'].encounters;
    let cam = { x: 50, y: 50 };
    let mode = 'pen';
    let brush = ' ';
    let activeZone = 1;
    let isDown = false;
    let lastPos = { x: 0, y: 0 };
    let showZones = false;

function saveToStorage() {
      allMaps[currentMapName] = { layout: mapData, encounters: zoneData };
      localStorage.setItem('map_editor_save', JSON.stringify({ allMaps, currentMapName }));
    }

    function loadFromStorage() {
      const saved = localStorage.getItem('map_editor_save');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (data.allMaps) {
            allMaps = data.allMaps;
            currentMapName = data.currentMapName || Object.keys(allMaps)[0];
            mapData = allMaps[currentMapName].layout;
            zoneData = allMaps[currentMapName].encounters;
            updateMapSelector();
          }
        } catch (e) { console.error("Failed to load map", e); }
      }
      document.getElementById('gh-token').value = localStorage.getItem('gh_token') || '';
      document.getElementById('gh-owner').value = localStorage.getItem('gh_owner') || '';
      document.getElementById('gh-repo').value = localStorage.getItem('gh_repo') || '';
      document.getElementById('gh-path').value = localStorage.getItem('gh_path') || '';
    }

    function init() {
      loadFromStorage();
      Object.entries(TILES).forEach(([char, cfg]) => {
        const b = document.createElement('button');
        b.innerHTML = `<div class="swatch" style="background:${cfg.color}"></div>${cfg.type}`;
        b.onclick = (e) => { e.preventDefault(); brush = char; setMode('pen'); };
        b.dataset.char = char;
        palette.appendChild(b);
      });
      document.getElementById('tool-pan').onclick = () => setMode('pan');
      document.getElementById('tool-pen').onclick = () => setMode('pen');
      document.getElementById('tool-zone').onclick = () => setMode('zone');
      document.getElementById('tool-toggle-zones').onclick = () => {
        showZones = !showZones;
        document.getElementById('tool-toggle-zones').classList.toggle('active', showZones);
      };
      document.getElementById('btn-settings').onclick = () => document.getElementById('settings-modal').classList.add('active');
      document.getElementById('btn-settings-close').onclick = () => document.getElementById('settings-modal').classList.remove('active');
      document.getElementById('btn-gh-import').onclick = importFromGitHub;
      document.getElementById('btn-gh-export').onclick = exportToGitHub;
      document.getElementById('map-select').onchange = (e) => switchMap(e.target.value);
      document.getElementById('zone-id').onchange = (e) => activeZone = parseInt(e.target.value) || 0;
      window.addEventListener('resize', resize);
      const handleStart = (e) => {
        isDown = true;
        const p = e.touches ? e.touches[0] : e;
        lastPos = { x: p.clientX, y: p.clientY };
        if (mode !== 'pan') paint(p.clientX, p.clientY);
      };
      const handleMove = (e) => {
        const p = e.touches ? e.touches[0] : e;
        const rect = canvas.getBoundingClientRect();
        const mx = Math.floor((p.clientX - rect.left - cam.x) / TILE_SIZE);
        const my = Math.floor((p.clientY - rect.top - cam.y) / TILE_SIZE);
        const curW = mapData[0]?.length || 0;
        const curH = mapData.length;
        if (mx >= 0 && mx < curW && my >= 0 && my < curH) status.innerText = `X: ${mx}, Y: ${my}`;
        if (!isDown) return;
        if (mode === 'pan') {
          cam.x += p.clientX - lastPos.x;
          cam.y += p.clientY - lastPos.y;
        } else paint(p.clientX, p.clientY);
        lastPos = { x: p.clientX, y: p.clientY };
      };
      const handleEnd = () => isDown = false;
      canvas.addEventListener('mousedown', handleStart);
      canvas.addEventListener('touchstart', handleStart, { passive: false });
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('touchmove', handleMove, { passive: false });
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchend', handleEnd);
      window.addEventListener('touchcancel', handleEnd);
      resize();
      setMode('pen');
      render();
    }

    function updateMapSelector() {
      const select = document.getElementById('map-select');
      const container = document.getElementById('map-select-section');
      const keys = Object.keys(allMaps);
      if (keys.length <= 1) {
        container.style.display = 'none';
      } else {
        container.style.display = 'flex';
        select.innerHTML = '';
        keys.forEach(k => {
          const opt = document.createElement('option');
          opt.value = k; opt.textContent = k; opt.selected = (k === currentMapName);
          select.appendChild(opt);
        });
      }
    }

    function switchMap(name) {
      allMaps[currentMapName] = { layout: mapData, encounters: zoneData };
      currentMapName = name;
      mapData = allMaps[name].layout;
      zoneData = allMaps[name].encounters;
    }

    async function importFromGitHub() {
      const token = document.getElementById('gh-token').value;
      const owner = document.getElementById('gh-owner').value;
      const repo = document.getElementById('gh-repo').value;
      const path = document.getElementById('gh-path').value;
      localStorage.setItem('gh_token', token);
      localStorage.setItem('gh_owner', owner);
      localStorage.setItem('gh_repo', repo);
      localStorage.setItem('gh_path', path);
      if (!owner || !repo || !path) return alert('Fill owner, repo and path');
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const headers = token ? { 'Authorization': `token ${token}` } : {};
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        const content = atob(data.content);
        const match = content.match(/(?:const|let|var)\s+MAP_DATA\s*=\s*({[\s\S]*?});/);
        if (!match) throw new Error("MAP_DATA not found in file");
        const parsed = new Function(`return ${match[1]}`)();
        allMaps = parsed;
        currentMapName = Object.keys(allMaps)[0];
        mapData = allMaps[currentMapName].layout;
        zoneData = allMaps[currentMapName].encounters;
        updateMapSelector();
        saveToStorage();
        document.getElementById('settings-modal').classList.remove('active');
        alert("Imported " + Object.keys(allMaps).length + " maps");
      } catch (e) { alert("Error: " + e.message); }
    }

    async function exportToGitHub() {
      saveToStorage();
      const token = document.getElementById('gh-token').value;
      const owner = document.getElementById('gh-owner').value;
      const repo = document.getElementById('gh-repo').value;
      const path = document.getElementById('gh-path').value;
      if (!token || !owner || !repo || !path) return alert('Fill token, owner, repo and path');
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' };
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error("Fetch failed: " + res.statusText);
        const fileData = await res.json();
        const content = decodeURIComponent(escape(atob(fileData.content)));
        const sha = fileData.sha;
        const regex = /((?:const|let|var)\s+MAP_DATA\s*=\s*)({[\s\S]*?});/;
        const match = content.match(regex);
        let remoteMaps = {};
        if (match) {
          try { remoteMaps = new Function(`return ${match[2]}`)(); } catch(e) {}
        }
        const mergedMaps = { ...remoteMaps, ...allMaps };
        const jsonStr = JSON.stringify(mergedMaps, null, 2);
        const newContent = content.replace(regex, (m, p1, p2) => p1 + jsonStr + ";");
        const updateRes = await fetch(url, {
          method: 'PUT',
          headers,
          body: JSON.stringify({
            message: 'Update MAP_DATA via Map Editor',
            content: btoa(unescape(encodeURIComponent(newContent))),
            sha: sha
          })
        });
        if (!updateRes.ok) throw new Error((await updateRes.json()).message || updateRes.statusText);
        alert("Successfully exported to GitHub!");
        document.getElementById('settings-modal').classList.remove( 'active');
      } catch (e) { alert("Export Error: " + e.message); }
    }

    function setMode(m) {
      mode = m;
      document.getElementById('tool-pan').classList.toggle('active', mode === 'pan');
      document.getElementById('tool-pen').classList.toggle('active', mode === 'pen');
      document.getElementById('tool-zone').classList.toggle('active', mode === 'zone');
      Array.from(palette.getElementsByTagName('button')).forEach(b => {
        b.classList.toggle('active', mode === 'pen' && b.dataset.char === brush);
      });
      canvas.style.cursor = mode === 'pan' ? 'grab' : (mode === 'zone' ? 'cell' : 'crosshair');
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
    }

    function paint(ex, ey) {
      const rect = canvas.getBoundingClientRect();
      const tx = Math.floor((ex - rect.left - cam.x) / TILE_SIZE);
      const ty = Math.floor((ey - rect.top - cam.y) / TILE_SIZE);
      const curW = mapData[0]?.length || 0;
      const curH = mapData.length;
      if (tx >= 0 && tx < curW && ty >= 0 && ty < curH) {
        let changed = false;
        if (mode === 'pen') {
          const row = mapData[ty];
          if (row[tx] !== brush) {
            mapData[ty] = row.substring(0, tx) + brush + row.substring(tx + 1);
            changed = true;
          }
        } else if (mode === 'zone') {
          if (zoneData[ty][tx] !== activeZone) {
            zoneData[ty][tx] = activeZone;
            changed = true;
          }
        }
        if (changed) saveToStorage();
      }
    }

    function render() {
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(cam.x, cam.y);
      const curW = mapData[0]?.length || 0;
      const curH = mapData.length;
      const vX0 = Math.max(0, Math.floor(-cam.x / TILE_SIZE));
      const vX1 = Math.min(curW, Math.ceil((canvas.width - cam.x) / TILE_SIZE));
      const vY0 = Math.max(0, Math.floor(-cam.y / TILE_SIZE));
      const vY1 = Math.min(curH, Math.ceil((canvas.height - cam.y) / TILE_SIZE));
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(0, 0, curW * TILE_SIZE, curH * TILE_SIZE);
      for (let y = vY0; y < vY1; y++) {
        for (let x = vX0; x < vX1; x++) {
          ctx.fillStyle = TILES[mapData[y][x]].color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          const zid = zoneData[y][x];
          if (zid > 0 && (showZones || mode === 'zone')) {
            ctx.fillStyle = 'white';
            ctx.shadowBlur = 3;
            ctx.shadowColor = 'black';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(zid, x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2 + 4);
            ctx.shadowBlur = 0;
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
      ctx.restore();
      requestAnimationFrame(render);
    }
    init();
  </script>
</body>
</html>