<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Editor</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; height: 100vh; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; background: #0f172a; color: #f8fafc; }
    #toolbar { background: #1e293b; border-bottom: 1px solid #334155; padding: 8px 16px; display: flex; gap: 16px; align-items: center; z-index: 10; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.3); }
    .tool-section { display: flex; align-items: center; gap: 8px; border-right: 1px solid #475569; padding-right: 16px; }
    .palette { display: flex; gap: 4px; overflow-x: auto; }
    .label { font-size: 10px; font-weight: 800; text-transform: uppercase; color: #94a3b8; letter-spacing: 0.05em; }
    button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 6px 10px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px; white-space: nowrap; }
    button:hover { background: #475569; }
    button.active { background: #2563eb; border-color: #3b82f6; color: white; }
    #viewport { flex-grow: 1; position: relative; overflow: hidden; }
    canvas { display: block; touch-action: none; }
    .swatch { width: 12px; height: 12px; border: 1px solid rgba(0,0,0,0.3); border-radius: 2px; }
    #status { position: fixed; bottom: 16px; right: 16px; background: rgba(15, 23, 42, 0.9); padding: 4px 12px; border-radius: 100px; font-size: 12px; color: #94a3b8; border: 1px solid #334155; pointer-events: none; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-section">
      <span class="label">Mode</span>
      <button id="tool-pan">Pan</button>
      <button id="tool-pen">Pen</button>
    </div>
    <div class="palette" id="palette">
      <span class="label">Tiles</span>
    </div>
  </div>
  <div id="viewport">
    <canvas id="editorCanvas"></canvas>
  </div>
  <div id="status">X: 0, Y: 0</div>
  <script>
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const palette = document.getElementById('palette');
    const status = document.getElementById('status');
    const TILE_SIZE = 32;
    const MAP_SIZE = 60;
    const TILES = {
      'T': { type: 'tree', color: '#064e3b' },
      ' ': { type: 'grass', color: '#2ecc71' },
      'D': { type: 'dirt', color: '#d35400' },
      'f': { type: 'dungeon', color: '#1b5e20' },
      'm': { type: 'dungeon', color: '#7f8c8d' },
      's': { type: 'dungeon', color: '#f1c40f' },
      'W': { type: 'water', color: '#3498db' },
      'b': { type: 'boulder', color: '#475569' }
    };
    let mapData = Array.from({ length: MAP_SIZE }, () => ' '.repeat(MAP_SIZE));
    let cam = { x: 50, y: 50 };
    let mode = 'pen';
    let brush = ' ';
    let isDown = false;
    let lastPos = { x: 0, y: 0 };

    function init() {
      Object.entries(TILES).forEach(([char, cfg]) => {
        const b = document.createElement('button');
        b.innerHTML = `<div class="swatch" style="background:${cfg.color}"></div>${cfg.type}`;
        b.onclick = () => { brush = char; setMode('pen'); };
        b.dataset.char = char;
        palette.appendChild(b);
      });
      document.getElementById('tool-pan').onclick = () => setMode('pan');
      document.getElementById('tool-pen').onclick = () => setMode('pen');
      window.addEventListener('resize', resize);
      const handleStart = (e) => {
        isDown = true;
        const p = e.touches ? e.touches[0] : e;
        lastPos = { x: p.clientX, y: p.clientY };
        if (mode === 'pen') paint(p.clientX, p.clientY);
      };
      const handleMove = (e) => {
        const p = e.touches ? e.touches[0] : e;
        const rect = canvas.getBoundingClientRect();
        const mx = Math.floor((p.clientX - rect.left - cam.x) / TILE_SIZE);
        const my = Math.floor((p.clientY - rect.top - cam.y) / TILE_SIZE);
        if (mx >= 0 && mx < MAP_SIZE && my >= 0 && my < MAP_SIZE) status.innerText = `X: ${mx}, Y: ${my}`;
        if (!isDown) return;
        if (mode === 'pan') {
          cam.x += p.clientX - lastPos.x;
          cam.y += p.clientY - lastPos.y;
        } else paint(p.clientX, p.clientY);
        lastPos = { x: p.clientX, y: p.clientY };
      };
      const handleEnd = () => isDown = false;
      canvas.addEventListener('mousedown', handleStart);
      canvas.addEventListener('touchstart', handleStart, { passive: false });
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('touchmove', handleMove, { passive: false });
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchend', handleEnd);
      window.addEventListener('touchcancel', handleEnd);
      resize();
      setMode('pen');
      render();
    }

    function setMode(m) {
      mode = m;
      document.getElementById('tool-pan').classList.toggle('active', mode === 'pan');
      document.getElementById('tool-pen').classList.toggle('active', mode === 'pen');
      Array.from(palette.getElementsByTagName('button')).forEach(b => {
        b.classList.toggle('active', mode === 'pen' && b.dataset.char === brush);
      });
      canvas.style.cursor = mode === 'pan' ? 'grab' : 'crosshair';
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
    }

    function paint(ex, ey) {
      const rect = canvas.getBoundingClientRect();
      const tx = Math.floor((ex - rect.left - cam.x) / TILE_SIZE);
      const ty = Math.floor((ey - rect.top - cam.y) / TILE_SIZE);
      if (tx >= 0 && tx < MAP_SIZE && ty >= 0 && ty < MAP_SIZE) {
        const row = mapData[ty];
        if (row[tx] !== brush) mapData[ty] = row.substring(0, tx) + brush + row.substring(tx + 1);
      }
    }

    function render() {
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(cam.x, cam.y);
      const vX0 = Math.max(0, Math.floor(-cam.x / TILE_SIZE));
      const vX1 = Math.min(MAP_SIZE, Math.ceil((canvas.width - cam.x) / TILE_SIZE));
      const vY0 = Math.max(0, Math.floor(-cam.y / TILE_SIZE));
      const vY1 = Math.min(MAP_SIZE, Math.ceil((canvas.height - cam.y) / TILE_SIZE));
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(0, 0, MAP_SIZE * TILE_SIZE, MAP_SIZE * TILE_SIZE);
      for (let y = vY0; y < vY1; y++) {
        for (let x = vX0; x < vX1; x++) {
          ctx.fillStyle = TILES[mapData[y][x]].color;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
      ctx.restore();
      requestAnimationFrame(render);
    }
    init();
  </script>
</body>
</html>