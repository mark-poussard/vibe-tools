<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Courtisans</title>
  <style>
    :root {
      --bg: #1a1a1a;
      --surface: #2d2d2d;
      --text: #e0e0e0;
      --primary: #d4af37;
      --gold: #FFD700;
      --blue: #1E90FF;
      --purple: #9932CC;
      --sky: #87CEFA;
      --green: #228B22;
      --orange: #FF8C00;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    .screen {
      display: none;
      min-height: 100vh;
      padding: 20px;
      flex-direction: column;
      align-items: center;
    }

    .screen.active {
      display: flex;
    }

    h1, h2, h3 { margin: 10px 0; color: var(--primary); }

    button {
      padding: 12px 24px;
      font-size: 16px;
      background: var(--primary);
      border: none;
      border-radius: 8px;
      color: black;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
    }

    button:disabled {
      background: #555;
      opacity: 0.5;
    }

    .setup-controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      max-width: 300px;
      width: 100%;
    }

    input[type="number"] {
      padding: 10px;
      border-radius: 5px;
      border: 1px solid var(--primary);
      background: #333;
      color: white;
    }

    .game-layout {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding-bottom: 150px;
    }

    .queens-table {
      background: var(--surface);
      padding: 15px;
      border-radius: 12px;
      border: 2px solid var(--primary);
    }

    .family-row {
      display: grid;
      grid-template-columns: 1fr 100px 1fr;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #444;
    }

    .family-label {
      font-weight: bold;
      text-transform: uppercase;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .influence-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 11px;
      background: #3d3d3d;
      padding: 5px;
      border-radius: 4px;
      min-height: 80px;
    }

    .destroyable {
      cursor: pointer;
      box-shadow: 0 0 5px red !important;
      animation: pulse-red 1.5s infinite;
    }

    @keyframes pulse-red {
      0% { box-shadow: 0 0 0px red; }
      50% { box-shadow: 0 0 10px red; }
      100% { box-shadow: 0 0 0px red; }
    }

    .influence-box.targetable {
      border: 2px dashed var(--primary);
      cursor: pointer;
    }

    .influence-count { font-size: 18px; font-weight: bold; }

    .player-area {
      background: #333;
      padding: 10px;
      border-radius: 10px;
      margin-bottom: 10px;
    }

    .player-area.active-target {
      border: 2px solid var(--primary);
      box-shadow: 0 0 10px var(--primary);
    }

    .cards-list {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 5px;
    }

    .card {
      width: 35px;
      height: 50px;
      border-radius: 4px;
      border: 1px solid white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 20px;
      color: white;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
      position: relative;
    }

    .crown, .dagger, .shield {
      position: absolute;
      top: 1px;
      left: 1px;
      font-size: 8px;
    }

    .dagger {
      left: auto;
      right: 1px;
    }

    .mask {
      position: absolute;
      top: 1px;
      left: 1px;
      font-size: 8px;
      z-index: 2;
    }

    .card.hidden-face {
      background: #444 !important;
      background-image: repeating-linear-gradient(45deg, #333, #333 5px, #444 5px, #444 10px) !important;
      border: 1px solid #666 !important;
      color: transparent !important;
    }

    .card.hidden-face * {
      display: none !important;
    }

    .hand-cards .card .crown, .hand-cards .card .dagger, .hand-cards .card .mask, .hand-cards .card .shield {
      font-size: 14px;
      top: 2px;
      left: 2px;
    }
    .hand-cards .card .dagger {
      left: auto;
      right: 2px;
    }

    .card.selected {
      outline: 4px solid var(--primary);
      transform: scale(1.1);
    }

    .Lions { background-color: var(--gold); }
    .Sharks { background-color: var(--blue); }
    .Spiders { background-color: var(--purple); }
    .Falcons { background-color: var(--sky); }
    .Vipers { background-color: var(--green); }
    .Foxes { background-color: var(--orange); }

    .hand-overlay {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.9);
      padding: 15px;
      border-top: 2px solid var(--primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }

    .hand-cards {
      display: flex;
      gap: 15px;
    }

    .hand-cards .card {
      width: 60px;
      height: 90px;
      font-size: 32px;
      cursor: pointer;
    }

    .instruction-text {
      font-weight: bold;
      color: var(--primary);
      text-align: center;
    }

    .family-status {
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      margin-top: 2px;
    }
    .status-good { background: #2e7d32; color: white; }
    .status-bad { background: #c62828; color: white; }
    .status-neutral { background: #616161; color: white; }

    .hidden { display: none !important; }

    .score-summary {
      width: 100%;
      text-align: left;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <div id="screen-setup" class="screen active">
    <h1>COURTISANS</h1>
    <div class="setup-controls">
      <div style="display:flex; flex-direction:column; gap:5px">
        <label>Human Players</label>
        <input type="number" id="player-count" min="1" max="6" value="1">
      </div>
      <div style="display:flex; flex-direction:column; gap:5px">
        <label>AI Players</label>
        <input type="number" id="ai-count" min="0" max="5" value="2">
      </div>
      <button onclick="startGame()">Start Game</button>
    </div>
  </div>

  <div id="screen-game" class="screen">
    <div id="turn-indicator" style="margin-bottom: 10px; font-weight: bold;"></div>
    
    <div class="game-layout">
      <div class="queens-table">
        <h3>Queen's Table</h3>
        <div id="table-rows"></div>
      </div>

      <div id="players-list"></div>
    </div>

    <div class="hand-overlay">
      <div class="instruction-text" id="game-instruction">Select a card from your hand</div>
      <div id="action-buttons" style="display:none">
        <button onclick="skipDestruction()" style="background: #888;">Skip Destruction</button>
      </div>
      <div class="hand-cards" id="player-hand"></div>
    </div>
  </div>

  <div id="screen-end" class="screen">
    <h1>Game Over</h1>
    <div id="final-scores" class="game-layout"></div>
    <button onclick="location.reload()">Play Again</button>
  </div>

  <script>
    const FAMILIES = [
      { name: 'Lions', icon: 'ü¶Å' },
      { name: 'Sharks', icon: 'ü¶à' },
      { name: 'Spiders', icon: 'üï∑Ô∏è' },
      { name: 'Falcons', icon: 'ü¶Ö' },
      { name: 'Vipers', icon: 'üêç' },
      { name: 'Foxes', icon: 'ü¶ä' }
    ];

    let gameState = {
      players: [],
      deck: [],
      currentPlayerIndex: 0,
      table: { spiesAbove: [], spiesBelow: [] }, // familyName: { above: [], below: [] }
      turnPhase: 'SELECT_CARD', 
      gameEnded: false, // SELECT_CARD, SELECT_TARGET, SELECT_DESTROY_TARGET
      actionsDone: { self: false, table: false, other: false },
      hand: [],
      selectedCardIndex: null,
      destructionContext: null
    };

    function initDeck() {
      let deck = [];
      FAMILIES.forEach(f => {
        for (let i = 0; i < 15; i++) {
          deck.push({
            ...f,
            id: Math.random().toString(36).substr(2, 9),
            isNoble: i < 4,
            isAssassin: i >= 4 && i < 6,
            isSpy: i >= 6 && i < 8,
            isGuard: i >= 8 && i < 11
          });
        }
      });
      return deck.sort(() => Math.random() - 0.5);
    }

    function startGame() {
      const humans = parseInt(document.getElementById('player-count').value) || 0;
      const ais = parseInt(document.getElementById('ai-count').value) || 0;
      const total = humans + ais;
      if (total < 2 || total > 6) return alert('Total players (Human + AI) must be between 2 and 6');
      gameState.deck = initDeck();
      if (total === 2) gameState.deck = gameState.deck.slice(30);
      else if (total === 3) gameState.deck = gameState.deck.slice(18);
      else if (total === 4) gameState.deck = gameState.deck.slice(6);
      gameState.players = [];
      for (let i = 0; i < humans; i++) {
        gameState.players.push({ id: i, name: `Player ${i + 1}`, area: [], isAI: false });
      }
      for (let i = 0; i < ais; i++) {
        gameState.players.push({ id: humans + i, name: `AI ${i + 1}`, area: [], isAI: true });
      }
      FAMILIES.forEach(f => { gameState.table[f.name] = { above: [], below: [] }; });
      gameState.table.spiesAbove = [];
      gameState.table.spiesBelow = [];
      gameState.gameEnded = false;
      document.getElementById('screen-setup').classList.remove('active');
      document.getElementById('screen-game').classList.add('active');
      startTurn();
    }

    function startTurn() {
      if (gameState.deck.length < 3) {
        endGame();
        return;
      }
      gameState.hand = [gameState.deck.pop(), gameState.deck.pop(), gameState.deck.pop()];
      gameState.actionsDone = { self: false, table: false, other: false };
      gameState.turnPhase = 'SELECT_CARD';
      gameState.selectedCardIndex = null;
      render();
      if (gameState.players[gameState.currentPlayerIndex].isAI) {
        setTimeout(aiTurn, 1000);
      }
    }

    async function aiTurn() {
      const pIdx = gameState.currentPlayerIndex;
      const hand = [...gameState.hand];
      if (hand.length < 3) return;
      let bestScore = -Infinity;
      let bestMove = null;
      const perms = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]];
      for (const p of perms) {
        const cS = hand[p[0]], cT = hand[p[1]], cO = hand[p[2]];
        for (const side of ['above', 'below']) {
          for (let oIdx = 0; oIdx < gameState.players.length; oIdx++) {
            if (oIdx === pIdx) continue;
            const tableTarget = cT.isSpy ? (side === 'above' ? gameState.table.spiesAbove : gameState.table.spiesBelow) : gameState.table[cT.name][side];
            tableTarget.push(cT);
            gameState.players[pIdx].area.push(cS);
            gameState.players[oIdx].area.push(cO);
            const others = gameState.players.filter((_, i) => i !== pIdx).map(p => calculatePlayerScore(p));
            const maxOther = others.length ? Math.max(...others) : 0;
            const score = calculatePlayerScore(gameState.players[pIdx]) - maxOther;
            if (score > bestScore) {
              bestScore = score;
              bestMove = { cS, cT, cO, side, oIdx };
            }
            gameState.players[oIdx].area.pop();
            gameState.players[pIdx].area.pop();
            tableTarget.pop();
          }
        }
      }
      if (!bestMove) return;
      const steps = [
        { card: bestMove.cS, type: 'self' },
        { card: bestMove.cT, type: 'table', sub: bestMove.side },
        { card: bestMove.cO, type: 'other', target: bestMove.oIdx }
      ];
      for (const s of steps) {
        if (gameState.currentPlayerIndex !== pIdx) break;
        const currentCardIdx = gameState.hand.findIndex(c => c.id === s.card.id);
        if (currentCardIdx === -1) continue;
        gameState.selectedCardIndex = currentCardIdx;
        gameState.turnPhase = 'SELECT_TARGET';
        render();
        await new Promise(r => setTimeout(r, 600));
        executePlaceCard(s.type, s.target, s.sub);
        if (gameState.turnPhase === 'SELECT_DESTROY_TARGET') {
          await new Promise(r => setTimeout(r, 600));
          aiChooseDestruction();
        }
      }
    }

    function aiChooseDestruction() {
      const ctx = gameState.destructionContext;
      if (!ctx) return skipDestruction();
      const pIdx = gameState.currentPlayerIndex;
      const getGap = () => {
        const pScore = calculatePlayerScore(gameState.players[pIdx]);
        const others = gameState.players.filter((_, i) => i !== pIdx).map(calculatePlayerScore);
        return pScore - (others.length ? Math.max(...others) : 0);
      };
      const initialGap = getGap();
      let bestGapDiff = 0;
      let target = null;
      if (ctx.source === 'table') {
        ['spiesAbove', 'spiesBelow'].forEach(sKey => {
          const list = gameState.table[sKey];
          for (let i = 0; i < list.length; i++) {
            if (list[i].id === ctx.cardId || list[i].isGuard) continue;
            const temp = list.splice(i, 1)[0];
            const diff = getGap() - initialGap;
            if (diff > bestGapDiff) {
              bestGapDiff = diff;
              target = { type: 'spyTable', sub: sKey === 'spiesAbove' ? 'above' : 'below', idx: i };
            }
            list.splice(i, 0, temp);
          }
        });
        FAMILIES.forEach(f => {
          ['above', 'below'].forEach(side => {
            const list = gameState.table[f.name][side];
            for (let i = 0; i < list.length; i++) {
              if (list[i].id === ctx.cardId || list[i].isGuard) continue;
              const temp = list.splice(i, 1)[0];
              const diff = getGap() - initialGap;
              if (diff > bestGapDiff) {
                bestGapDiff = diff;
                target = { type: 'table', family: f.name, sub: side, idx: i };
              }
              list.splice(i, 0, temp);
            }
          });
        });
      } else {
        const p = gameState.players[ctx.targetId];
        if (p) {
          for (let i = 0; i < p.area.length; i++) {
            if (p.area[i].id === ctx.cardId || p.area[i].isGuard) continue;
            const temp = p.area.splice(i, 1)[0];
            const diff = getGap() - initialGap;
            if (diff > bestGapDiff) {
              bestGapDiff = diff;
              target = { type: 'player', targetId: ctx.targetId, idx: i };
            }
            p.area.splice(i, 0, temp);
          }
        }
      }
      if (target && bestGapDiff > 0) {
        destroyCard(target.type, target.targetId, target.idx, target.family, target.sub);
      } else {
        skipDestruction();
      }
    }

    function selectCard(index) {
      if (gameState.players[gameState.currentPlayerIndex].isAI) return;
      if (gameState.selectedCardIndex === index) {
        gameState.selectedCardIndex = null;
        gameState.turnPhase = 'SELECT_CARD';
      } else {
        gameState.selectedCardIndex = index;
        gameState.turnPhase = 'SELECT_TARGET';
      }
      render();
    }

    function placeCard(targetType, targetId = null, subTarget = null) {
      if (gameState.players[gameState.currentPlayerIndex].isAI) return;
      executePlaceCard(targetType, targetId, subTarget);
    }

    function executePlaceCard(targetType, targetId = null, subTarget = null) {
      if (gameState.turnPhase !== 'SELECT_TARGET' || gameState.selectedCardIndex === null) return;
      const card = gameState.hand[gameState.selectedCardIndex];
      if (targetType === 'self' && !gameState.actionsDone.self) {
        gameState.players[gameState.currentPlayerIndex].area.push(card);
        gameState.actionsDone.self = true;
      } else if (targetType === 'table' && !gameState.actionsDone.table) {
        if (card.isSpy) {
          gameState.table[subTarget === 'above' ? 'spiesAbove' : 'spiesBelow'].push(card);
        } else {
          gameState.table[card.name][subTarget].push(card);
        }
        gameState.actionsDone.table = true;
      } else if (targetType === 'other' && !gameState.actionsDone.other) {
        if (targetId === gameState.currentPlayerIndex) return;
        gameState.players[targetId].area.push(card);
        gameState.actionsDone.other = true;
      } else return;

      if (card.isAssassin) {
        gameState.turnPhase = 'SELECT_DESTROY_TARGET';
        gameState.destructionContext = { source: targetType, targetId: targetId, cardId: card.id };
        render();
      } else {
        finishPlaceAction();
      }
    }

    function finishPlaceAction() {
      gameState.hand.splice(gameState.selectedCardIndex, 1);
      gameState.selectedCardIndex = null;
      gameState.destructionContext = null;
      if (gameState.actionsDone.self && gameState.actionsDone.table && gameState.actionsDone.other) {
        gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
        startTurn();
      } else {
        gameState.turnPhase = 'SELECT_CARD';
        render();
      }
    }

    function skipDestruction() {
      if (gameState.turnPhase !== 'SELECT_DESTROY_TARGET') return;
      finishPlaceAction();
    }

    function destroyCard(type, pIdx, cIdx, family, sub) {
      if (gameState.turnPhase !== 'SELECT_DESTROY_TARGET') return;
      if (type === 'player') {
        gameState.players[pIdx].area.splice(cIdx, 1);
      } else if (type === 'spyTable') {
        gameState.table[sub === 'above' ? 'spiesAbove' : 'spiesBelow'].splice(cIdx, 1);
      } else {
        gameState.table[family][sub].splice(cIdx, 1);
      }
      finishPlaceAction();
    }

    function getWeight(card) { return card.isNoble ? 2 : 1; }
    function getStanding(familyName, includeSpies = false) {
      const f = gameState.table[familyName];
      let aboveW = f.above.reduce((s, c) => s + getWeight(c), 0);
      let belowW = f.below.reduce((s, c) => s + getWeight(c), 0);
      if (includeSpies) {
        aboveW += gameState.table.spiesAbove.filter(c => c.name === familyName).reduce((s, c) => s + getWeight(c), 0);
        belowW += gameState.table.spiesBelow.filter(c => c.name === familyName).reduce((s, c) => s + getWeight(c), 0);
      }
      if (aboveW > belowW) return 1;
      if (aboveW < belowW) return -1;
      return 0;
    }

    function calculatePlayerScore(player, includeSpies = false) {
      return player.area.reduce((score, card) => {
        if (!includeSpies && card.isSpy) return score;
        const weight = card.isNoble ? 2 : 1;
        return score + (weight * getStanding(card.name, includeSpies));
      }, 0);
    }

    function render() {
      const currentP = gameState.players[gameState.currentPlayerIndex];
      document.getElementById('turn-indicator').innerText = `${currentP.name}'s Turn`;
      document.getElementById('action-buttons').style.display = gameState.turnPhase === 'SELECT_DESTROY_TARGET' ? 'block' : 'none';

      const renderSpyPile = (side) => {
        const list = side === 'above' ? gameState.table.spiesAbove : gameState.table.spiesBelow;
        return `<div class="family-row" style="grid-template-columns: 1fr; border: 1px dashed #555; margin-bottom: 5px;">
            <div class="influence-box" style="min-height: 40px">
              <span style="font-size: 9px">SPIES ${side.toUpperCase()}</span>
              <div class="cards-list" style="justify-content:center">
                ${list.map((c, i) => {
                  const isHidden = !gameState.gameEnded;
                  const isDestroyable = gameState.turnPhase === 'SELECT_DESTROY_TARGET' && gameState.destructionContext.source === 'table' && c.id !== gameState.destructionContext.cardId && !c.isGuard;
                  return `<div class="card ${c.name} ${isHidden ? 'hidden-face' : ''} ${isDestroyable ? 'destroyable' : ''}" style="width:20px;height:28px;font-size:12px" 
                    onclick="event.stopPropagation(); if(${isDestroyable}) destroyCard('spyTable', null, ${i}, null, '${side}')">
                    ${c.isNoble ? '<div class="crown" style="font-size:6px">üëë</div>' : ''}
                    ${c.isAssassin ? '<div class="dagger" style="font-size:6px">üó°Ô∏è</div>' : ''}
                    ${c.isSpy ? '<div class="mask" style="font-size:6px">üé≠</div>' : ''}
                    ${c.isGuard ? '<div class="shield" style="font-size:6px">üõ°Ô∏è</div>' : ''}
                    ${c.icon}</div>`;
                }).join('')}
              </div>
            </div>
          </div>`;
      };

      let tableHtml = renderSpyPile('below');
      tableHtml += FAMILIES.map(f => {
        const standing = getStanding(f.name, gameState.gameEnded);
        const statusClass = standing === 1 ? 'status-good' : (standing === -1 ? 'status-bad' : 'status-neutral');
        const isTableSelectable = gameState.turnPhase === 'SELECT_TARGET' && !gameState.actionsDone.table && 
                             gameState.hand[gameState.selectedCardIndex] && gameState.hand[gameState.selectedCardIndex].name === f.name;

        const renderSlot = (side) => {
          const weight = gameState.table[f.name][side].reduce((s, c) => s + getWeight(c), 0);
          return `
            <div class="influence-box ${isTableSelectable ? 'targetable' : ''}" onclick="placeCard('table', null, '${side}')">
              <span>${side.toUpperCase()}</span>
              <div class="influence-count">${weight}</div>
              <div class="cards-list" style="justify-content:center">
                ${gameState.table[f.name][side].map((c, i) => {
                  const isDestroyable = gameState.turnPhase === 'SELECT_DESTROY_TARGET' && gameState.destructionContext.source === 'table' && c.id !== gameState.destructionContext.cardId && !c.isGuard;
                  return `<div class="card ${c.name} ${isDestroyable ? 'destroyable' : ''}" style="width:20px;height:28px;font-size:12px" 
                    onclick="event.stopPropagation(); if(${isDestroyable}) destroyCard('table', null, ${i}, '${f.name}', '${side}')">
                    ${c.isNoble ? '<div class="crown" style="font-size:6px">üëë</div>' : ''}
                    ${c.isAssassin ? '<div class="dagger" style="font-size:6px">üó°Ô∏è</div>' : ''}
                    ${c.isSpy ? '<div class="mask" style="font-size:6px">üé≠</div>' : ''}
                    ${c.isGuard ? '<div class="shield" style="font-size:6px">üõ°Ô∏è</div>' : ''}
                    ${c.icon}</div>`;
                }).join('')}
              </div>
            </div>`;
        };

        return `
          <div class="family-row">
            ${renderSlot('below')}
            <div class="family-label">
              <div style="font-size: 28px;">${f.icon}</div>
              <div style="font-size: 9px; margin-top: -2px;">${f.name}</div>
              <div class="family-status ${statusClass}">${standing === 1 ? 'GOOD' : (standing === -1 ? 'BAD' : 'NONE')}</div>
            </div>
            ${renderSlot('above')}
          </div>`;
      }).join('') + renderSpyPile('above');
      document.getElementById('table-rows').innerHTML = tableHtml;

      const playersHtml = gameState.players.map((p, idx) => {
        const isSelf = idx === gameState.currentPlayerIndex;
        const canTarget = gameState.turnPhase === 'SELECT_TARGET' && ((isSelf && !gameState.actionsDone.self) || (!isSelf && !gameState.actionsDone.other));
        const areaCards = [...p.area];
        return `
          <div class="player-area ${canTarget ? 'active-target' : ''}" onclick="placeCard('${isSelf ? 'self' : 'other'}', ${idx})">
            <div style="display:flex; justify-content:space-between">
              <strong>${p.name} ${isSelf ? '(You)' : ''}</strong>
              <span>Score: ${calculatePlayerScore(p, gameState.gameEnded)}</span>
            </div>
            <div class="cards-list">
              ${areaCards.map((c, i) => {
                const isHidden = !gameState.gameEnded && c.isSpy;
                const isDestroyable = gameState.turnPhase === 'SELECT_DESTROY_TARGET' && gameState.destructionContext.source !== 'table' && 
                                     gameState.destructionContext.targetId === idx && c.id !== gameState.destructionContext.cardId && !c.isGuard;
                return `<div class="card ${c.name} ${isHidden ? 'hidden-face' : ''} ${isDestroyable ? 'destroyable' : ''}" 
                  onclick="event.stopPropagation(); if(${isDestroyable}) destroyCard('player', ${idx}, ${i})">
                  ${c.isNoble ? '<div class="crown">üëë</div>' : ''}
                  ${c.isAssassin ? '<div class="dagger">üó°Ô∏è</div>' : ''}
                  ${c.isSpy ? '<div class="mask">üé≠</div>' : ''}
                  ${c.isGuard ? '<div class="shield">üõ°Ô∏è</div>' : ''}
                  ${c.icon}</div>`;
              }).join('')}
            </div>
          </div>`;
      }).join('');
      document.getElementById('players-list').innerHTML = playersHtml;

      const handHtml = gameState.hand.map((c, i) => {
        const isAI = currentP.isAI;
        const isSelected = gameState.selectedCardIndex === i;
        const isHidden = isAI ? c.isSpy : (c.isSpy && !isSelected);
        return `<div class="card ${c.name} ${isSelected ? 'selected' : ''} ${isHidden ? 'hidden-face' : ''}" onclick="selectCard(${i})">
          ${c.isNoble ? '<div class="crown">üëë</div>' : ''}
          ${c.isAssassin ? '<div class="dagger">üó°Ô∏è</div>' : ''}
          ${c.isSpy ? '<div class="mask">üé≠</div>' : ''}
          ${c.isGuard ? '<div class="shield">üõ°Ô∏è</div>' : ''}
          ${c.icon}</div>`;
      }).join('');
      document.getElementById('player-hand').innerHTML = handHtml;

      let instruction = "";
      if (gameState.turnPhase === 'SELECT_CARD') {
        instruction = "Select a card to play";
      } else if (gameState.turnPhase === 'SELECT_DESTROY_TARGET') {
        instruction = "ASSASSIN! Destroy another card (Optional)";
      } else {
        const card = gameState.hand[gameState.selectedCardIndex];
        const options = [];
        if (!gameState.actionsDone.self) options.push("your area");
        if (!gameState.actionsDone.table) options.push(`Queen's table (${card.name})`);
        if (!gameState.actionsDone.other) options.push("another player's area");
        instruction = `Place ${card.icon} in: ` + options.join(", ");
      }
      document.getElementById('game-instruction').innerText = instruction;
    }

    function endGame() {
      gameState.gameEnded = true;
      render();
      document.getElementById('screen-game').classList.remove('active');
      document.getElementById('screen-end').classList.add('active');

      const sorted = [...gameState.players].sort((a, b) => calculatePlayerScore(b, true) - calculatePlayerScore(a, true));
      
      const finalHtml = sorted.map((p, i) => {
        const sortedArea = [...p.area].sort((a, b) => a.name.localeCompare(b.name));
        return `
          <div class="player-area">
            <h2>#${i+1} ${p.name}</h2>
            <p>Final Score: ${calculatePlayerScore(p, true)}</p>
            <div class="cards-list">
              ${sortedArea.map(c => `<div class="card ${c.name}">${c.isSpy ? '<div class="mask">üé≠</div>' : ''}${c.isGuard ? '<div class="shield">üõ°Ô∏è</div>' : ''}${c.icon}</div>`).join('')}
            </div>
          </div>
        `;
      }).join('');
      
      document.getElementById('final-scores').innerHTML = finalHtml;
    }
  </script>
</body>
</html>